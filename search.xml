<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开启文章加密]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%BC%80%E5%90%AF%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[密码为P@ssw0rd Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32相关]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[转自“https://blog.csdn.net/sinat_36184075/article/details/70216197” 宏定义USE_STDPERIPH_DRIVER, STM32F10X_HD 不同类型的型号STM32固件库Libraries\CMSIS\Core\CM3\startup\arm中启动文件的文件名英文缩写意义： cl：互联型产品， stm32f105/107 系列 vl：超值型产品， stm32f100 系列 xl：超高密度（容量） 产品， stm32f101/103 系列 ld：低密度产品， FLASH 小于 64K md：中等密度产品， FLASH=64 or 128 hd：高密度产品， FLASH 大于 128 GPIO_TypeDef 型结构123GPIO_TypeDef * GPIOx; //定义一个 GPIO_TypeDef 型结构体指针 GPIOxGPIOx = GPIOA; //把指针地址设置为宏 GPIOA 地址GPIOx-&gt;CRL = 0xffffffff; //通过指针访问并修改 GPIOA_CRL 寄存器 总线AHB 高级高性能总线，一种系统总线。连接模块如CPU、DMA、DSP等APB 一种外围设备总线。连接模块如UART、I2C等// APB1:低速外设总线；APB2:高速外设总线。 时钟 高速外部时钟（HSE） 以外部晶振作时钟源，晶振频率可取范围为4~16MHz，我们一般采用’ 8MHz ‘的晶振。 高速内部时钟（HSI） 由内部 RC 振荡器产生，频率为 8MHz，但不稳定。 低速外部时钟（LSE） 以外部晶振作时钟源，主要提供给实时时钟模块，所以一般采用 32.768KHz。 野火 M3 实验板上用的是 32.768KHz， 6p 负载规格的晶振。 低速内部时钟（LSI） 由内部 RC 振荡器产生，也主要提供给实时时钟模块，频率大约为 40KHz。 锁相环 PLL主要功能是倍频（扩大频率），经过PLL 的时钟称为 PLLCLK。GPIO时钟GPIO 外设是挂载在 APB2 总线上的， APB2 的时钟是 APB2 预分频器的输出，而 APB2 预分频器的时钟来源是 AHB 预分频器。因此，把APB2 预分频器设置为不分频，那么我们就可以得到 GPIO 外设的时钟也等于 HCLK。 PCLK2：外设时钟，由 APB2 预分频器输出得到，最大频率可为72MHz，提供给挂载在 APB2 总线上的外设。 ‘ STM32每个外设都配备了外设时钟的开关，当我们不使用某个外设时，可以把这个外设时钟关闭，从而降低 STM32 的整体功耗。所以，当我们使用外设时，一定要记得开启外设的时钟啊，亲。 （STM32时钟：接收中断事件，降低功耗） 【GPIO相关结构体】123456typedef struct&#123; uint16_t GPIO_Pin; /* 指定将要进行配置的 GPIO 引脚 */ GPIOSpeed_TypeDef GPIO_Speed; /* 指定 GPIO 引脚可输出的最高频率 */ GPIOMode_TypeDef GPIO_Mode; /* 指定 GPIO 引脚将要配置成的工作状态 */&#125; GPIO_InitTypeDef; 123456typedef enum&#123; GPIO_Speed_10MHz = 1, // 枚举常量，值为 1，代表输出速率最高为 10MHz GPIO_Speed_2MHz, // 对不赋值的枚举变量，自动加 1，此常量值为 2 GPIO_Speed_50MHz // 常量值为 3&#125; GPIOSpeed_TypeDef; 12345678910typedef enum&#123; GPIO_Mode_AIN = 0x0, // 模拟输入模式 GPIO_Mode_IN_FLOATING = 0x04, // 浮空输入模式 GPIO_Mode_IPD = 0x28, // 下拉输入模式 GPIO_Mode_IPU = 0x48, // 上拉输入模式 GPIO_Mode_Out_OD = 0x14, // 开漏输入模式 GPIO_Mode_Out_PP = 0x10, // 通用推挽输出模式 GPIO_Mode_AF_OD = 0x1C, // 复用功能开漏输出 GPIO_Mode_AF_PP = 0x18 // 复用功能推挽输出&#125; GPIOMode_TypeDef; 【初始化函数库】#include “stm32f10x_gpio.c”void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)功能：初始化指定的GPIO管脚参数： @ GPIOx ：外设硬件对应的GPIO管脚地址(已在stm32f10x.h中被强转定义) @ GPIO_InitStruct ：需要此函数调用前定义该结构体变量，传其地址。返回值：none 12345/* 代码演示 - 多个GPIO参数同时赋值 */GPIO_InitTypeDef GPIO_InitStruct;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; /* 引脚模式为通用推挽输出 */GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* 引脚速率为50MHz */ 【外设时钟控制函数】#include “stm32f10x_rcc.c”void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)功能：控制挂载在APB2上外设的时钟使能或禁止参数： @ RCC_APB2Periph ：指定外设去控制对应设备的时钟，参数可任意组合，参数如下 * RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB, * RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE, * RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1, * RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1, * RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3, * RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17, * RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11 @ NewState ：指定时钟的新的状态，参数如下 ENABLE or DISABLE返回值：none// 对应的如果挂载在APB1上，对应函数为 void RCC_APB1PeriphClockCmd (.., ..) 【控制I/O输出高、低电平函数】#include “stm32f10x_gpio.c”void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)功能：&lt;设置&gt;选定的GPIO数据端口位参数： @ GPIOx ：GPIO管脚类型，x可指定为AG @ GPIO_Pin ：指定被写入的数据端口位，即引脚号 Pin0Pin15返回值：none #include “stm32f10x_gpio.c”void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)功能：&lt;清除&gt;选定的GPIO数据端口位参数： @ GPIOx ：GPIO管脚类型，x可指定为AG @ GPIO_Pin ：指定被写入的数据端口位，即引脚号 Pin0Pin15返回值：none /*** 规范的位操作实现方法 ***/由于库函数的实现涉及到不少位操作，首先为读者介绍一下几个常用的位操作方法，排除阅读代码的障碍。1、 将 char 型变量 a 的第七位(bit6)清 0， 其它位不变。 a &amp;= ~(1&lt;&lt;6); // 括号内 1 左移 6 位，得二进制数： 0100 0000 // 按位取反，得 1011 1111 ，所得的数与 a 作”位与&amp;”运算， // a 的第 7 位（ bit6） 被置零，而其它位不变。2、 同理，将变量 a 的第七位(bit6)置 1，其它位不变的方法如下。 a |= (1&lt;&lt;6); // 把第七位（ bit6）置 1，其它为不变3、 将变量 a 的第七位(bit6)取反，其它位不变。 a ^=(1&lt;&lt;6); // 把第七位（ bit6）取反，其它位不变 【推挽输出】推挽输出的低电平为 0 伏，高电平为 3.3 伏。STM32 的 GPIO 输出模式就分为： 普通推挽输出(GPIO_Mode_Out_PP) 普通开漏输出(GPIO_Mode_Out_OD) 及复用推挽输出(GPIO_Mode_AF_PP) 复用开漏输出(GPIO_Mode_AF_OD ) 普通推挽输出模式一般应用在输出电平为 0 和 3.3 伏的场合。而普通开漏输出一般应用在电平不匹配的场合，如需要输出 5 伏的高电平，就需要在外部接一个上拉电阻，电源为 5 伏，把 GPIO 设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出 5 伏的电平。对于相应的复用模式，则是根据 GPIO 的复用功能来选择的，如 GPIO 的引脚用作串口的输出，则使用复用推挽输出模式。如果用在 IC、 SMBUS 这些需要线与功能的复用场合，就使用复用开漏模式。其它不同的复用场合的复用模式引脚配置将在具体的例子中讲解。在使用任何一种开漏模式，都需要接上拉电阻。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32-FreeRTOS知识整理总结]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32-FreeRTOS%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考自“https://www.cnblogs.com/lifexy/p/10463050.html” 1. 基础知识 注意:在RTOS中是优先值越高则优先级越高(和ucos/linux的相反) 在移植的时候,主要裁剪FreeRTOS/Source/portable文件夹,该文件夹用来针对不同MCU做的一些处理,如下图所示,我们只需要使用: FreeRTOS/Source/portable/Keil 使用MDK编译环境所需要使用的文件FreeRTOS/Source/portable/RVDS 内存管理相关的文件，移植所必需的FreeRTOS/Source/portable/MemMang 使用MDK编译环境所需要使用的文件 1.1配置工程时,选择memMang时,一般使用heap_4.c heep_1.c只能分配内存而不能释放内存。 heep_2.c可以分配和释放内存但不能合并空闲内存块。 heep_3.c简单的封装了线程安全版的标准C语言malloc和free函数。 heap_4: 优点在于可以有效的利用内存碎片来合并为一个大内存.缺点在于只能用来一个ram里. heap_5: 一般针对有外部RAM才用到,优点在于可以同时利用内部ram和外部ram来进行内存碎片合并. 然后我们在分配释放内存的时候,就尽量使用RTOS带的函数来实现,分配/释放函数如下所示: 12void *pvPortMalloc( size_t xWantedSize ); void vPortFree( void *pv ); 1.2 添加头文件路径添加FreeRTOS\include添加FreeRTOS\portable\RVDS\ARM_CM3并将原子中的FreeRTOSConfig.h也复制到我们项目的FreeRTOS\include中(用来配置RTOS系统) 2. FreeRTOSConfig.h配置介绍一般会写configXXXXX或者INCLUDE_XXXX类似的宏,这两个宏区别在于: configXXXXX用来实现不同功能,比如定义configUSE_COUNTING_SEMAPHORES为1时,表示使用计数信号量 INCLUDE_XXXX用来是否将某个API函数编译进程序中.比如定义INCLUDE_xTaskGetSchedulerState 为1 时,则将会编译xTaskGetSchedulerState()函数,如下图所示: 3. FreeRTOS任务状态3.1 运行态指当前任务正在运行. 3.2 就绪态指当前任务正在等待调度,因为有个高优先级/同优先级的任务正在运行中 3.3 阻塞态当前任务处于等待外部事件通知或通过vTaskDelay()函数进入休眠了,外部事件通知常见有信号量、等待队列、事件标志组、任务通知. 3.4 挂起态类似于暂停,表示不会再参与任务调度了,通过vTaskSuspend()实现,重新恢复调度则使用xTaskResume() 4. FreeRTOS中断配置4.1 回忆stm32 NVIC中断 比如我们设置为NVIC_PriorityGroup_4时:表示抢占优先级为4bit(即为2^4,为0~15个抢占优先级),副优先级为0bit(表示没有). 4.2 抢占优先级和副优先级的区别: 抢占优先级和副优先级的值越低,则优先级越高 高的抢占优先级的中断可以直接打断低的抢占优先级的中断 高的副优先级的中断不可以打断低的副优先级的中断(只是两个相同抢占优先级的中断同时来的时候,只会优先选择高的副优先级) 4.3 FreeRTOS中断配置宏configKERNEL_INTERRUPT_PRIORITY用来配置中断最低抢占优先级,也就是可以FreeRTOS可以管理的最小抢占优先级,所以使用FreeRTOS时,我们尽量设置stm32为NVIC_PriorityGroup_4,这样就可以管理16个优先级了. configMAX_SYSCALL_INTERRUPT_PRIORITY用来配置FreeRTOS能够安全管理的的最高优先级.比如原子的FreeRTOSConfig.h里就设置为5,而0-4的优先级中断就不会被FreeRTOS因为开关中断而禁止掉(一直都会有),并且不能调用RTOS中的”FromISR”结尾的API函数.比如喂看门狗中断函数就需要设置为0-4. 如下图所示(来自原子手册): 4.3 FreeRTOS中断开关函数 12345portENABLE_INTERRUPTS(); //开中断,将configMAX_SYSCALL_INTERRUPT_PRIORITY至 configKERNEL_INTERRUPT_PRIORITY之间的优先级中断打开portDISABLE_INTERRUPTS(); //关中断,将configMAX_SYSCALL_INTERRUPT_PRIORITY至 configKERNEL_INTERRUPT_PRIORITY之间的优先级中断禁止掉 5.任务常用API函数5.1 xTaskCreate创建任务函数定义如下: 1234567891011xTaskCreate( TaskFunction_t pxTaskCode, //任务函数,用来供给函数指针调用的 const char * const pcName, //任务的字符串别名 const uint16_t usStackDepth, //任务堆栈深度,实际申请到的堆栈是该参数的4倍 void * const pvParameters, //函数参数,用来供给指针调用的 UBaseType_t uxPriority, //优先级,越高优先级高,范围为0~configMAX_PRIORITIES-1 //注意优先级0会创建为空闲任务, 优先级configMAX_PRIORITIES-1会创建一个软件定时器服务任务(管理定时器的) TaskHandle_t * const pxCreatedTask //任务句柄,该句柄可以用于挂起/恢复/删除对应的任务 );//返回值 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(-1):表示创建任务堆空间不足pdPASS(1):创建成功 5.2 taskENTER_CRITICAL()和taskEXIT_CRITICAL()用于任务中进入/退出临界区,调用taskENTER_CRITICAL()主要会关闭其他任务调度.而taskEXIT_CRITICAL()则会恢复任务调度,一般用于初始化外设等. 5.3 taskENTER_CRITICAL_FROM_ISR()和taskEXIT_CRITICAL_FROM_ISR()用于在中断函数中进入/退出临界区,作用和上面一样 5.4 挂起/恢复/删除任务函数1234void vTaskSuspend( TaskHandle_t xTaskToSuspend ); //挂起一个任务,参数为挂起任务的句柄,如果为NULL则表示挂起自身任务void vTaskResume( TaskHandle_t xTaskToResume ); //恢复一个任务BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume);//从中断函数中恢复一个任务,返回1表示恢复成功void vTaskDelete( TaskHandle_t xTaskToDelete ); //删除一个任务,如果从任务函数中退出的话,则需要调用vTaskDelete(NULL)来删除自身任务 5.5 vTaskDelay()延时函数1void vTaskDelay( const TickType_t xTicksToDelay ); //参数表示延时的系统滴答数 比如延时500ms可以写为: vTaskDelay( 500/portTICK_RATE_MS );portTICK_RATE_MS是个宏,表示当前系统的1个滴答需要多少ms,而500/portTICK_RATE_MS则表示当前500ms需要多少个系统滴答数. 6. 队列6.1 简介队列用于任务与任务或者任务与中断之间的通信.比如key任务检测到按键按下时,则可以通过队列向lcd显示任务发送信息,使得lcd切换界面.队列采用先进先出存储机制.队列发送数据可以有两种方式:浅拷贝、深拷贝. 数据量不大的情况下,都使用深拷贝(会分配新的空间,并进行数据拷贝,缺点在于耗时) 数据量大的情况下,都使用浅拷贝(通过指针方式,前提是要发送的数据必须不会被释放的) 6.2 队列的优点队列可以通过任何任务或者中断进行访问,可以随时存取数据消息.并且出入队的时候可以进行任务阻塞,比如某个任务进行读消息出队时,如果没有消息,则可以实现进入休眠状态,直到有消息才唤醒任务. 6.3 队列创建删除相关API123456789101112131415161718QueueHandle_t xQueueCreate( uxQueueLength, uxItemSize ); //动态创建队列,内存会交给RTOS自动分配 // uxQueueLength:队列长度(表示队列中最大多少条消息),uxItemSize:每个队列消息的长度(以字节为单位) //返回值: NULL(0, 表示分配失败),非0(表示返回该队列分配好的地址) //注意:使用自动分配时,需要配置configSUPPORT_DYNAMIC_ALLOCATION宏为1,否则只能由用户来分配.QueueHandle_t xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ); //静态创建队列,内存需要由用户事先分配好 // uxQueueLength:队列长度(表示队列中最大多少条消息),uxItemSize:每个队列消息的长度(以字节为单位) // pucQueueStorage:指向用户事先分配好的存储区内存(必须为uint8_t型) // pxQueueBuffer:指向队列结构体,用来提供给RTOS初始化.然后给用户使用 //返回值: NULL(0, 表示分配失败),非0(表示返回该队列分配好的地址)vQueueDelete( QueueHandle_t xQueue ); //删除队列,并释放空间xQueueReset( xQueue ); //将队列里的消息清空一次,也就是恢复初始状态 6.4队列出入队相关API1234567891011121314151617181920212223242526xQueueSend( xQueue, pvItemToQueue, xTicksToWait ); //插入队尾,和xQueueSendToBack函数效果一致 // xQueue:队列句柄 //PvItemToQueue:消息数据,会通过数据拷贝到队列中,如果想使用浅拷贝,则可以发送一个变量来存储要真正发送的缓冲区地址即可. // xTicksToWait:阻塞时间,单位为RTOS时钟滴答值,如果configTICK_RATE_HZ是1000,则填入的值表示阻塞的是多少ms,否则的话需要通过X/portTICK_RATE_MS来转换一下,才能实现阻塞Xms. //xTicksToWait==0:表示入队满了,则直接退出该函数 // xTicksToWait==portMAX_DELAY:表示一直阻塞,直到队列有空位为止. //注意: INCLUDE_vTaskSuspend宏必须为1,否则任务无法进入休眠状态实现阻塞效果. //返回值: errQUEUE_FULL(队列已满) pdPASS(通过)xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ); //插入队头,参数和上面描述一致xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ); //插入队尾,参数和上面描述一致xQueueOverwrite( xQueue, pvItemToQueue ); //将之前未出队的旧数据全部清空,然后再入队,该函数适用于长度为1的队列xQueueReceive( xQueue, pvBuffer, xTicksToWait ); //从队列头部读出一个消息,并且这个消息会出队(删除掉)xQueuePeek( xQueue, pvBuffer, xTicksToWait ); //从队列头部读出一个消息,但是这个消息不会出队(不会删除) PS:这些API函数只能用于任务里调用,如果要在中断服务函数中调用,则在函数名后添加FromQueue即可,比如xQueueSendFromQueue()函数 6.5 中断发送/读取消息队列时,要注意的事情使用中断相关的读写队列相关的API时,第3个参数是不一样的,比如xQueueSendFromISR(): 1xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) PxHigherPriorityTaskWoken用来标记退出该函数后是否需要进行任务切换,因为我们发送队列时,有可能会将某个阻塞任务退出阻塞态,而此时又在中断中,所以当PxHigherPriorityTaskWoken为pdTRUE时,我们则必须进行一次任务切换. 可以通过portYIELD_FROM_ISR()来进行任务切换,并且我们不需要去判断PxHigherPriorityTaskWoken是否为pdTRUE,因为该函数内部有判断的,如下图所示: 来个中断函数发送队列示例: 123456789101112131415161718extern QueueHandle_t Message_Queue; //信息队列句柄void USART1_IRQHandler(void) //串口1中断服务程序&#123; BaseType_t xHigherPriorityTaskWoken; //定义任务切换标志位 if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; //处理中断接收数据 &#125; if (Message_Queue!=NULL) //判断Message_Queue是否已创建 &#123; xQueueSendFromISR(Message_Queue, RX_BUF,&amp;xHigherPriorityTaskWoken); //向队列Message_Queue中发送RX_BUF portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //通过portYIELD_FROM_ISR()判断是否需要切换任务 &#125;&#125; PS:尽量将portYIELD_FROM_ISR()写在中断函数末尾处 6.6示例-任务之间的伪代码按键任务向打印任务发送按键消息队列,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344QueueHandle_t Key_Queue; //按键值消息队列句柄int main()&#123; //...省略N行代码 Key_Queue = xQueueCreate(1,sizeof(u8)); //创建消息Key_Queue,长度为1 //创建两个任务:key_task()、print_task() //...省略N行代码&#125;key_task() //获取按键值&#123; while(1) &#123; key=KEY_Scan(0); //扫描按键 if((Key_Queue!=NULL)&amp;&amp;(key)) //消息队列Key_Queue创建成功,并且按键被按下 &#123; err=xQueueSend(Key_Queue,&amp;key,10); if(err==errQUEUE_FULL) //发送按键值 &#123; printf("队列Key_Queue已满，数据发送失败!\r\n"); &#125; &#125; vTaskDelay(10); //延时10个时钟节拍 &#125;&#125;print_task() //打印按键值&#123; u8 key; while(1) &#123; if(Key_Queue!=NULL) &#123; if(xQueueReceive(Key_Queue,&amp;key,portMAX_DELAY))//请求消息Key_Queue &#123; printf("key=%d\r\n",key); &#125; &#125; vTaskDelay(10); //延时10个时钟节拍 &#125;&#125; 7. RTOS软件定时器7.1简介在之前的任务创建的时候有讲到过,RTOS会自动创建一个优先级configMAX_PRIORITIES-1的软件定时器服务任务(管理定时器的). 所以我们写一个定时器回调函数时,则会被该定时器服务任务调用,所以在我们软件定时器函数中不能使用** vTaskDelay() **阻塞之类的API函数,否则会将系统中的定时器服务函数给阻塞掉. 7.2 FreeRTOSConfig.h相关的定时器配置1234#define configUSE_TIMERS 1 //为1时启用软件定时器#define configTIMER_TASK_PRIORITY 31 //设置软件定时器优先级可设置的值范围为0~31#define configTIMER_QUEUE_LENGTH 5 //软件定时器队列长度#define configTIMER_TASK_STACK_DEPTH 200 //设置每个软件定时器任务堆栈大小 7.3定时创建相关API1234567TimerHandle_t xTimerCreateStatic( const char * const pcTimerName, //定时器字符串别名 const TickType_t xTimerPeriodInTicks, //需要定时的周期值,比如通过200/ portTICK_RATE_MS来转换实现定时200毫秒 const UBaseType_t uxAutoReload, //是否重载(周期性/单次性),若为pdTRUE(1)表示为周期性,为pdFALSE(0)表示为单次 void * const pvTimerID, //定时器ID号,一般用于多个定时器共用一个定时器回调函数,否则填0即可 TimerCallbackFunction_t pxCallbackFunction //定时器回调函数 ); 12xTimerDelete( xTimer, xTicksToWait ); //删除定时器//xTicksToWait:指定该定时器在多少时钟节拍数之前删除掉,为0则立即删除,一般设为100(如果设为0,则如果在该操作之前还有其它设置定时器操作的话,则不会进行阻塞等待,从而返回false) 7.4 定时器其它常用API12345678910111213xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ); //修改定时器周期,在中断中则使用xTimerChangePeriodFromISR() // xNewPeriod:要修改的周期值 //xTicksToWait:指定该定时器在多少时钟节拍数之前修改好,为0则立即删除 //xTimerReset( xTimer, xTicksToWait ); //复位定时器,让定时器重新计数,在中断中则使用xTimerResetFromISR() // xTicksToWait:和上面内容类似xTimerStart( xTimer, xTicksToWait ); //启动定时器,如果定时器正在运行的话调用该函数的结果和xTimerReset()一样, 在中断中则使用xTimerResetFromISR ()xTimerStop( xTimer, xTicksToWait ); //停止定时器, 在中断中则使用xTimerStopFromISR () PS:在中断中使用定时器API时,同样和队列一样,也需要在函数末尾通过portYIELD_FROM_ISR()进行一次任务切换判断 8. 信号量在项目中我们一般用二值信号量,用来同步数据的. 比如任务A要向任务B发送一个很大的数据buf,而用队列的话会进行复制拷贝,从而占用大量时间. 此时我们不妨定义一个全局数据buf,任务A修改这个buf,发送一个信号量给任务B,任务B就去读取这个全局数据buf即可.从而省去了队列复制拷贝的时间. 8.1定义信号量举例12SemaphoreHandle_t BinarySemaphore; //二值信号量句柄BinarySemaphore=xSemaphoreCreateBinary(); //创建二值信号量 8.2在中断中发送信号量过程123BaseType_t xHigherPriorityTaskWoken;xSemaphoreGiveFromISR(BinarySemaphore,&amp;xHigherPriorityTaskWoken);//发送二值信号量portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果需要的话进行一次任务切换 8.3在任务中发送信号量过程1xSemaphoreGive(BinarySemaphore); //返回值: pdPASS(0, 表示发送成功,如果信号量一直未处理,则会返回值失败FULL) 8.4 在任务中接收信号量过程123err = xSemaphoreTake(BinarySemaphore,portMAX_DELAY); //获取信号量// portMAX_DELAY:进入阻塞态一直等待获取//返回值为pdTRUE(OK) pdFALSE(err)]]></content>
      <categories>
        <category>STM32</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32F105RC新建工程，移植FreeRTOS]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32F105RC%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%EF%BC%8C%E7%A7%BB%E6%A4%8DFreeRTOS%2F</url>
    <content type="text"><![CDATA[1. STM32工程创建 注：工程创建方法参照正点原子 1.1 准备 开发环境，Keil MDK 5.26，下载地址 STM32F1 PACK包，下载地址 ST官方标准外设库，目前版本3.5.0，下载地址 开发板 1.2 开始1.2.1 Keil环境安装Keil环境，破解，安装STM32 F1 PACK包 1.2.2 创建工程 创建文件夹为 STM32_F105RC-FreeRTOS 在Template内创建文件夹USER、CORE、OBJ、STM32F10x_FWLib USER 用来存放自己添加的代码 CORE 用来存放核心文件和启动文件 OBJ 是用来存放编译过程文件以及 hex 文件 STM32F10x_FWLib 文件夹顾名思义用来存放 ST 官方提供的库函数源码文件 运行Keil，点击 MDK 的菜单： Project –&gt;New Uvision Project，然后将目录定位到刚才建立的文件夹 STM32_F105RC-FreeRTOS。工程命名为 STM32_F105RC-FreeRTOS，点击保存。 接下来会出现一个选择 CPU 的界面，就是选择我们的芯片型号。STMicroelectronics-&gt;STM32F1 Series-&gt;STM32F105-&gt;STM32F105RCT6 特别注意： 一定要安装对应的器件 pack 才会显示这些内容哦！！ 点击 OK， MDK 会弹出 Manage Run-Time Environment 对话框，直接点击 Cancel。 此时一个框架工程建立完毕，还需要添加启动代码，以及.c 文件等。 修改默认调试工具：魔术棒图标-&gt;Debug-&gt;下拉ST-Link Debugger 修改下载后自动复位运行：魔术棒图标-&gt;Debug-&gt;右侧Setting-&gt;Flash Download-&gt;勾选Reset and Run 调整工程输出文件目录 魔术棒图标-&gt;Output-&gt;Select Folder for Objects…-&gt;选择OBJ目录。同时勾选Create HEX File 魔术棒图标-&gt;Listing-&gt;Select Folder for Objects…-&gt;选择OBJ目录 删除工程目录下的Objects、Listings文件夹 1.2.3 移植固件库包 打开官方固件库包，进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver，将将目录下面的 src，inc 文件夹 copy 到我们刚才建立的 STM32F10x_FWLib 文件夹下面 src 存放的是固件库的.c 文件 inc 存放的是对应的.h 文件 打开官方固件库包，进入目录STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport 下面，将文件 core_cm3.c 和 文件 core_cm3.h 复制到 CORE 内 打开官方固件库包，进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm 下面，将里面 startup_stm32f10x_cl.s 文件复制到 CORE 内 STM32固件库Libraries\CMSIS\Core\CM3\startup\arm中启动文件的文件名英文缩写意义： cl：互联型产品， stm32f105/107 系列 vl：超值型产品， stm32f100 系列 xl：超高密度（容量） 产品， stm32f101/103 系列 ld：低密度产品， FLASH 小于 64K md：中等密度产品， FLASH=64 or 128 hd：高密度产品， FLASH 大于 128 进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x，将文件 stm32f10x.h， system_stm32f10x.c， system_stm32f10x.h，复制到 USER 内 进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template，将文件 main.c， stm32f10x_conf.h， stm32f10x_it.c， stm32f10x_it.h 复制到 USER 内 1.2.4 将固件库文件添加到工程 右键点击 Target1，选择 Manage Project Items。 Project Targets 一栏，我们将 Target 名字修改为 STM32_F105RC-FreeRTOS。然后在 Groups 一栏删掉一个 Source Group1，建立三个 Groups： USER,CORE,FWLIB。然后点击 OK。 右键点击点击 STM32_F105RC-FreeRTOS， 选择 Manage Project Itmes， 然后选择需要添加文件的 Group，这里第一步我们选择 FWLIB，然后点击右边的 Add Files,定位到我们刚才建立的目录 STM32F10x_FWLib/src 下面，将里面所有的文件选中(Ctrl+A)，然后点击 Add，然后 Close.可以看到 Files 列表下面包含我们添加的文件。 如果只用到了其中的某个外设，可以不用添加没有用到的外设的库文件。例如只用 GPIO，可以只用添加 stm32f10x_gpio.c 而其他的可以不用添加。这里全部添加进来是为了后面方便，不用每次添加，当然4这样的坏处是工程太大，编译起来速度慢，可以自行选择。 用同样的方法，将 Groups 定位到 CORE 下面，添加需要的文件：core_cm3.c， startup_stm32f10x_hd.s 注意，默认添加的时候文件类型为.c,也就是添加 startup_stm32f10x_hd.s 启动文件的时候，你需要选择文件类型为 All files 才能看得到这个文件 将 Groups 定位到 USER 下面，添加需要的文件：main.c， stm32f10x_it.c，system_stm32f10x.c 点击OK，返回主界面 1.2.5 添加头文件 点击魔术棒-&gt;C/C++-&gt;Include Pash-&gt;点击… 添加目录 ./COER ./USER ./STM32F10x_FWLib/inc 1.2.6 添加宏定义 点击魔术棒-&gt;C/C++-&gt;Define 填入“STM32F10X_CL,USE_STDPERIPH_DRIVER” 不同芯片，STM32F10X_CL后缀不同，具体参见 章节1.3.3 3. 1.2.7 修改main.c将内容改为以下 1234567891011121314151617181920212223242526272829#include "stm32f10x.h"// 简单延时函数void Delay(u32 count)&#123; u32 i=0; for(;i&lt;count;i++);&#125;// 主函数int main(void)&#123; // GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED0--&gt;PD.2 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 口速度为 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //根据设定参数初始化 GPIOD.2 GPIO_SetBits(GPIOD,GPIO_Pin_2); //PD.2 输出高 // 循环控制D2高低电平 while(1) &#123; GPIO_SetBits(GPIOD,GPIO_Pin_2); Delay(3000000); GPIO_ResetBits(GPIOD,GPIO_Pin_2); Delay(3000000); &#125;&#125; 1.2.8 下载运行LED灯闪烁 1.3 串口打印1.3.1 串口初始化代码 在main.c增加串口初始化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125; 增加Printf映射代码 12345678910111213141516#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125; 包含头文件 1#include &lt;stdio.h&gt; // FILE main()中调用串口初始化，添加printf打印，发现串口打印乱码。找资料说是始终问题。打开stm32f10x.h，找到以下代码，手动定义时钟值 12345678910111213141516/** * @brief In the following line adjust the value of External High Speed oscillator (HSE) used in your application Tip: To avoid modifying this file each time you need to use different HSE, you can define the HSE value in your toolchain compiler preprocessor. */ // 根据板子实际情况手动设置时钟值#define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */#if !defined HSE_VALUE #ifdef STM32F10X_CL #define HSE_VALUE ((uint32_t)25000000) /*!&lt; Value of the External oscillator in Hz */ #else #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* STM32F10X_CL */#endif /* HSE_VALUE */ 修改时钟后，串口正常工作 2. FreeRTOS移植2.1 准备 上一步中建立好的工程 STM32_F105RC-FreeRTOS FreeRTOS源码，运行freertos.exe自解压 2.2 开始2.2.1 移植文件 在 STM32_F105RC-FreeRTOS工程文件夹 中新建文件夹FreeRTOS 进入OS源码路径FreeRTOSv10.2.1\FreeRTOS\Source，将目录内include文件夹，及所有*.c文件复制到刚创建的FreeRTOS文件夹内 这些是平台无关的代码，所有平台都需要使用的 进入OS源码路径FreeRTOSv10.2.1\FreeRTOS\Source\protable\MemMang目录。复制heep_2.c到刚创建的FreeRTOS文件夹内 该目录下是内存管理的相关代码 heep_1.c只能分配内存而不能释放内存。 heep_2.c可以分配和释放内存但不能合并空闲内存块。 heep_3.c简单的封装了线程安全版的标准C语言malloc和free函数。 heep_4.c可以合并相邻的空闲内存块。 heep_5.c可以合并相邻的空闲内存块，且可以管理多个内存。 目标平台是Keil，打开FreeRTOSv10.2.1\FreeRTOS\Source\protable\Keil文件夹看到如下文件“See-also-the-RVDS-directory.txt”。因此打开FreeRTOSv10.2.1\FreeRTOS\Source\portable\RVDS\，根据型号进入目录 \ARM_CM3\，复制文件port.c到刚创建的FreeRTOS文件夹内，复制文件portmacro.h到刚创建的FreeRTOS\include文件夹内 FreeRTOSv10.2.1\FreeRTOS\Source\portable\RVDS路径下有不同的型号，根据实际情况选择 ARM_CA9 ARM_CM0 ARM_CM3 ARM_CM4_MPU ARM_CM4F ARM_CM7 ARM7_LPC21xx 进入路径FreeRTOSv10.2.1\FreeRTOS\Demo，由于使用Keil+STM32F105RC，所以进入CORTEX_STM32F103_Keil，复制FreeRTOSConfig.h到刚创建的FreeRTOS\include文件夹内 2.2.2 将OS文件添加到工程 打开Keil工程，Project Target上右键STM32_F105RC-FreeRTOS，选择 Manage Project Items。 在 Groups 一栏增加 FreeRTOS 分组。然后点击 Add File，将FreeRTOS文件夹内所有*.c添加。 点击OK。 2.2.3 添加头文件 点击魔术棒-&gt;C/C++-&gt;Include Pash-&gt;点击… 添加目录 .\FreeRTOS\include 2.2.4 修改 打开FreeRTOSConfig.h文件，在最后(#endif前)添加宏定义，这些宏将Freertos的这三个回调跟stm32官方的对应起来，这样就不用修改启动文件。 123#define vPortSVCHandler SVC_Handler#define xPortPendSVHandler PendSV_Handler#define xPortSysTickHandler SysTick_Handler 同时需要将stm32f10x_it.c里边对应的三个函数注释掉或者加上weak关键字。 123__weak void SVC_Handler(void)__weak void PendSV_Handler(void)__weak void SysTick_Handler(void) 打开FreeRTOSConfig.h文件，在最后(#endif前)添加宏定义 此宏定义作用未知，不加编译会报错 1#define configUSE_MUTEXES 1 2.2.5 包含头文件在使用FreeRTOS的文件内包含头文件 12345// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量 2.3 测试修改main.c如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include "stm32f10x.h"#include &lt;stdio.h&gt;// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量// 几个打印任务中计数值u32 g_printf1_conter = 0;u32 g_printf2_conter = 0;u32 g_printf3_conter = 0;// 映射Printf相关#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //?úê1ó?printfê±?μí3×??ˉì?ó?′?oˉêy&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125;// 简单延时函数void Delay(u32 count)&#123; static u32 i=0; for(i = 0; i &lt; count; i++);&#125;// 延时1ms（不准确的延时）void Delay_ms(u32 ms)&#123; static u32 i = 0; for(i = 0; i &lt; ms; i++) &#123; Delay(4000); &#125;&#125;// Led IO初始化void Led_Init(void)&#123; // LED GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED2--&gt;PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 速度 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); // IO初始化 GPIO_SetBits(GPIOD, GPIO_Pin_2); // 设置电平PD.2&#125;// Led打开void Led_Open(void)&#123; GPIO_ResetBits(GPIOD,GPIO_Pin_2);&#125;// Led关闭void Led_Close(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_2);&#125;void Led_Test(void *pvParameters)&#123; while(1) &#123; Led_Open(); vTaskDelay( 100/portTICK_RATE_MS ); Led_Close(); vTaskDelay( 100/portTICK_RATE_MS ); &#125;&#125;//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125;void USART_Test1(void *pvParameters)&#123; while(1) &#123; printf("USART 1 hello world %04d\r\n", g_printf1_conter++); vTaskDelay( 500/portTICK_RATE_MS ); &#125;&#125;void USART_Test2(void *pvParameters)&#123; while(1) &#123; printf("USART 2 hello world %04d\r\n", g_printf2_conter++); vTaskDelay( 800/portTICK_RATE_MS ); &#125;&#125;void USART_Test3(void *pvParameters)&#123; while(1) &#123; printf("USART 3 hello world %04d\r\n", g_printf3_conter++); vTaskDelay( 1100/portTICK_RATE_MS ); &#125;&#125;/*-----------------------------------------------------------*/static void prvSetupHardware( void )&#123; SystemInit(); Led_Init(); USART1_init(115200);&#125;/************************************************************/// 主函数/************************************************************/int main(void)&#123; // 初始化硬件平台 prvSetupHardware(); printf("hello world\r\n"); Delay_ms(1000); /* 建立任务 */ xTaskCreate( Led_Test, "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+3, NULL ); xTaskCreate( USART_Test1, "UART1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test2, "UART2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test3, "UART3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); /* 启动OS */ vTaskStartScheduler();&#125; FreeRTOS移植完成，多任务运行基本实现 任务1：100ms设置Led闪烁 任务2：串口每隔500ms打印“USART 1 hello world xxxx” 任务3：串口每隔800ms打印“USART 2 hello world xxxx” 任务4：串口每隔1100ms打印“USART 3 hello world xxxx” 3. FreeRTOS下串口中断接收3.1 main.c代码修改3.1.1 定义变量1xQueueHandle g_xQueueRx; 3.1.2 增加宏定义1#define EN_USART1_RX 1 // 使能了接收 3.1.3 增加串口中断处理函数1234567891011121314#if EN_USART1_RX //如果使能了接收void USART1_IRQHandler(void)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 cChar; if(USART_GetITStatus (USART1,USART_IT_RXNE)!=RESET) &#123; cChar=USART_ReceiveData(USART1); xQueueSendToBackFromISR (g_xQueueRx, &amp;cChar, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); &#125;&#125;#endif 3.1.2 中断向量表配置12345678910111213void NVIC_Configuration(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_4); #if EN_USART1_RX //如果使能了接收 // 配置串口1中断向量 NVIC_InitStructure .NVIC_IRQChannel =USART1_IRQn ; NVIC_InitStructure .NVIC_IRQChannelPreemptionPriority =6; NVIC_InitStructure .NVIC_IRQChannelCmd =ENABLE ; NVIC_Init(&amp;NVIC_InitStructure );#endif&#125; 3.1.3 串口接收任务创建12345678910111213141516void vPC_Communication_Task(void *pvParameters)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 rx=0; g_xQueueRx = xQueueCreate(20,sizeof(u8)); while(1) &#123; if(xQueueReceiveFromISR(g_xQueueRx, &amp;rx, &amp;xHigherPriorityTaskWoken)) &#123; printf("%c\r\n", rx); &#125; vTaskDelay(10/portTICK_RATE_MS ); &#125;&#125; 3.1.4 增加NVIC初始化在函数static void prvSetupHardware( void )中，增加 1NVIC_Configuration(); 3.1.5 增加创建任务1xTaskCreate( vPC_Communication_Task, "UART_RECV", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); 3.2 最终main.c如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include "stm32f10x.h"#include &lt;stdio.h&gt;// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量#define EN_USART1_RX 1// 几个打印任务中计数值u32 g_printf1_conter = 0;u32 g_printf2_conter = 0;u32 g_printf3_conter = 0;xQueueHandle g_xQueueRx;#define EN_USART1_RX 1 // 使能了接收// 映射Printf相关#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //?úê1ó?printfê±?μí3×??ˉì?ó?′?oˉêy&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125;// 简单延时函数void Delay(u32 count)&#123; static u32 i=0; for(i = 0; i &lt; count; i++);&#125;// 延时1ms（不准确的延时）void Delay_ms(u32 ms)&#123; static u32 i = 0; for(i = 0; i &lt; ms; i++) &#123; Delay(4000); &#125;&#125;// Led IO初始化void Led_Init(void)&#123; // LED GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED2--&gt;PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 速度 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); // IO初始化 GPIO_SetBits(GPIOD, GPIO_Pin_2); // 设置电平PD.2&#125;// Led打开void Led_Open(void)&#123; GPIO_ResetBits(GPIOD,GPIO_Pin_2);&#125;// Led关闭void Led_Close(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_2);&#125;void Led_Test(void *pvParameters)&#123; while(1) &#123; Led_Open(); vTaskDelay( 100/portTICK_RATE_MS ); Led_Close(); vTaskDelay( 100/portTICK_RATE_MS ); &#125;&#125;//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125;void USART_Test1(void *pvParameters)&#123; while(1) &#123; printf("USART 1 hello world %04d\r\n", g_printf1_conter++); vTaskDelay( 500/portTICK_RATE_MS ); &#125;&#125;void USART_Test2(void *pvParameters)&#123; while(1) &#123; printf("USART 2 hello world %04d\r\n", g_printf2_conter++); vTaskDelay( 800/portTICK_RATE_MS ); &#125;&#125;void USART_Test3(void *pvParameters)&#123; while(1) &#123; printf("USART 3 hello world %04d\r\n", g_printf3_conter++); vTaskDelay( 1100/portTICK_RATE_MS ); &#125;&#125;#if EN_USART1_RX //如果使能了接收void USART1_IRQHandler(void)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 cChar; if(USART_GetITStatus (USART1,USART_IT_RXNE)!=RESET) &#123; cChar=USART_ReceiveData(USART1); xQueueSendToBackFromISR (g_xQueueRx, &amp;cChar, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); &#125;&#125;#endifvoid NVIC_Configuration(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_4); #if EN_USART1_RX //如果使能了接收 // 配置串口1中断向量 NVIC_InitStructure .NVIC_IRQChannel =USART1_IRQn ; NVIC_InitStructure .NVIC_IRQChannelPreemptionPriority =6; NVIC_InitStructure .NVIC_IRQChannelCmd =ENABLE ; NVIC_Init(&amp;NVIC_InitStructure );#endif&#125;void vPC_Communication_Task(void *pvParameters)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 rx=0; g_xQueueRx = xQueueCreate(20,sizeof(u8)); while(1) &#123; if(xQueueReceiveFromISR(g_xQueueRx, &amp;rx, &amp;xHigherPriorityTaskWoken)) &#123; printf("%c\r\n", rx); &#125; vTaskDelay(10/portTICK_RATE_MS ); &#125;&#125;/*-----------------------------------------------------------*/static void prvSetupHardware( void )&#123; SystemInit(); NVIC_Configuration(); Led_Init(); USART1_init(115200);&#125;/************************************************************/// 主函数/************************************************************/int main(void)&#123; // 初始化硬件平台 prvSetupHardware(); printf("hello world\r\n"); Delay_ms(1000); /* 建立任务 */ xTaskCreate( Led_Test, "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+3, NULL ); xTaskCreate( USART_Test1, "UART1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test2, "UART2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test3, "UART3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( vPC_Communication_Task, "UART_RECV", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); /* 启动OS */ vTaskStartScheduler();&#125;]]></content>
      <categories>
        <category>STM32</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo新建文章]]></title>
    <url>%2F2019%2F05%2F31%2FHexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo server 本地测试，访问http://localhost:4000 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 将文章收缩显示1&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装及关联账户]]></title>
    <url>%2F2019%2F05%2F31%2FGit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%B3%E8%81%94%E8%B4%A6%E6%88%B7%2F</url>
    <content type="text"><![CDATA[安装git 下载git，地址 安装git，默认安装 创建公钥，关联git 安装git后，右键会多出“Git GUI Here”“Git Bash Here”，选择“Git Bash Here”，弹出窗口 执行： cd ~/.ssh 如果返回“… No such file or directory”，说明没有生成过SSH Key，直接进入第4步。否则进入第3步备份! 备份： mkdir key_backup mv id_isa* key_backup 生成新的Key：（引号内的内容替换为你自己的邮箱） ssh-keygen -t rsa -C “your_email@youremail.com“ 输出显示： Generating public/private rsa key pair. Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa): 直接回车，不要修改默认路劲。 Enter passphrase (empty for no passphrase):Enter same passphrase again: 设置一个密码短语，在每次远程操作之前会要求输入密码短语！闲麻烦可以直接回车，不设置。 成功： Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.The key fingerprint is:… … 提交公钥： 6.1 找到.ssh文件夹，用文本编辑器打开“id_rsa.pub”文件，复制内容到剪贴板。 6.2 打开 https://github.com/settings/ssh ，点击 Add SSH Key 按钮，粘贴进去保存即可。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2019%2F05%2F06%2Farticle-title%2F</url>
    <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <tags>
        <tag>Cmd Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[STM32 Can id过滤]]></title>
    <url>%2F2019%2F04%2F08%2FSTM32%20Can%20id%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728CAN_FilterInitTypeDef CAN_FilterInitStructure; u32 slave_id = 0x1C1F1700; // 0b ‭0001 1100 0001 1111 0001 0111 0000 0000‬// 0b 0001 1111 1111 1111 1111 1111 0000 0000// slave_id &amp;lt;&amp;lt; 3 0b ‭1110 0000 1111 1000 1011 1000 0000 0‬000// 0b 1111 1111 1111 1111 1111 1000 0000 0*** /* CAN 过滤器组初始化 */CAN_FilterInit(&amp;amp;CAN_FilterInitStructure); //初始化CAN_FilterInitStructrue结构体变量CAN_FilterInitStructure.CAN_FilterNumber = 0; //设置过滤器组0，范围为0~13CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask; //设置过滤器组0为屏蔽模式CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;//设置过滤器组0位宽为32位#if 0 // 不设置过滤CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000; //设置标识符寄存器高字节CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000; //设置标识符寄存器低字节CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000; //设置屏蔽寄存器高字节CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000; //设置屏蔽寄存器低字节#else//寄存器的设置CAN_FilterInitStructure.CAN_FilterIdHigh = ((slave_id &amp;lt;&amp;lt; 3) &amp;gt;&amp;gt; 16) &amp;amp;0xffff; // 设置标识符寄存器高字节CAN_FilterInitStructure.CAN_FilterIdLow = (u16)(slave_id &amp;lt;&amp;lt; 3) | CAN_ID_EXT;// 设置标识符寄存器低字节CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0xffff; //设置屏蔽寄存器高字节CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x8003; //设置屏蔽寄存器低字节#endifCAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;//过滤器关联邮箱0CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;//激活过滤器CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE); //使能CAN接收中断CAN_FilterInit(&amp;amp;CAN_FilterInitStructure); // 设置过滤器]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil设置]]></title>
    <url>%2F2019%2F03%2F04%2FKeil%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Keil设置下载程序后自动运行 设置字体颜色设置字体颜色主题参照https://blog.csdn.net/qq_20553613/article/details/79615293 设置Tab键设置Tab键参照https://blog.csdn.net/dianzilaoshu/article/details/72457276 中Keil部分]]></content>
      <categories>
        <category>Keil</category>
      </categories>
      <tags>
        <tag>Keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“魔术师地毯”类问题]]></title>
    <url>%2F2019%2F02%2F27%2F%E2%80%9C%E9%AD%94%E6%9C%AF%E5%B8%88%E5%9C%B0%E6%AF%AF%E2%80%9D%E7%B1%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[魔术师地毯里，蓝色三角形和红色三角形根本就不是相似三角形，蓝色直角边2:5，红色3:8，他们组成的大图形不是三角形，是四边形，上面长边往里凹，下面的往外凸]]></content>
  </entry>
  <entry>
    <title><![CDATA[STM32 APB1 APB2]]></title>
    <url>%2F2019%2F02%2F26%2FSTM32-APB1-APB2%2F</url>
    <content type="text"><![CDATA[STM32F103系列运行主频为72MHz 据参考手册有：APB1操作速度限于36MHz， APB2操作于全速(最高72MHz)。 APB2负责AD，I/O，高级TIM，串口1； APB1负责DA，USB，SPI，I2C，CAN，串口2345，普通TIM；]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vivado 2016.4 固化]]></title>
    <url>%2F2019%2F02%2F15%2FVivado-2016-4-%E5%9B%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. bit文件生成mcs文件在vivado2016版本之后，可以直接通过操作来生成mcs文件 2. 固化mcs文件]]></content>
      <categories>
        <category>Vivado</category>
      </categories>
      <tags>
        <tag>Vivado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 异或和校验]]></title>
    <url>%2F2019%2F02%2F14%2FC%20%E5%BC%82%E6%88%96%E5%92%8C%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617//异或校验运算/** const unsigned char *buf 需要运算的buf数组* int id_end 需要运算的buf结尾位置* int id_start = 0 需要预算的buf开始位置，默认为0*/int xor16(const unsigned char *buf, int id_end, int id_start = 0)&#123; int check_buf = 0; int i; for (i = id_start; i &amp;lt; id_end; i++) &#123; check_buf ^= (int)buf[i]; &#125; return check_buf;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SN]]></title>
    <url>%2F2018%2F12%2F12%2FSN%2F</url>
    <content type="text"><![CDATA[DDSM3617 6.1.7 DEZTW73LF1S9D DDSM918+ 6.2.1 DXVTDO4IGF8S5]]></content>
  </entry>
  <entry>
    <title><![CDATA[U盘芯片信息]]></title>
    <url>%2F2018%2F12%2F08%2FU%E7%9B%98%E8%8A%AF%E7%89%87%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[闪迪 酷豆 8G 芯片信息 逻辑盘符 : H:\ 此分区容量: 7.4G设备ID : VID = 0781 PID = 5571设备序列号: 4C530001060105112245设备版本 : 1.00 设备制造商: SanDisk设备型号 : Cruzer Fit当前协议 : USB2.0(连接到USB3端口可以获得更高性能)输入电流 : 224mA 分区系统 : FAT32 是否激活 : 否是否对齐 : 1024 KB 已扇区对齐 网络异常,查询主控信息失败! 系统版本 : Windows 8 Personal 金士顿16G逻辑盘符 : H:\ 此分区容量: 14.4G设备ID : VID = 0930 PID = 6545设备序列号: C86000BDB93EB0907A20EBA6设备版本 : PMAP 设备制造商: Kingston设备型号 : DataTraveler 2.0当前协议 : USB2.0输入电流 : 300mA 分区系统 : FAT32 是否激活 : 是是否对齐 : 128 KB 已扇区对齐 芯片制造商: 群联(Phison)芯片型号 : PS2251-68闪存颗粒 : 东芝(Toshiba) (打开网络可以获取详细信息)固件版本 : 02.02.55 固件日期: 2015.06.12 工具下载 : http://www.upan.cc/tools/mass/Phison/系统版本 : Windows 8 Personal]]></content>
  </entry>
  <entry>
    <title><![CDATA[外网SMB端口映射]]></title>
    <url>%2F2018%2F11%2F28%2F%E5%A4%96%E7%BD%91SMB%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[开启端口映射，从外网访问内网的文件共享：SMB 已经在路由器里开了远端WEB管理设了端口，另外端口映射局域网里的一台电脑，比如WEB端口设的是8080，映射192.168.1.100到4877端口，现在我想访问局域网的共享文件，怎么弄？以前我的做法是远程控制软件比如teamviewer或者radmin控制内网一台电脑后再通过其访问内网，缺点是要装软件，有办法直接通过网关访问内网共享文件夹吗？ Samba服务所使用的端口和协议： Port 137 (UDP) – NetBIOS 名字服务 ； nmbd Port 138 (UDP) – NetBIOS 数据报服务 Port 139 (TCP) – 文件和打印共享 ； smbd （基于SMB(Server Message Block)协议，主要在局域网中使用，文件共享协议） Port 389 (TCP) – 用于 LDAP (Active Directory Mode) Port 445 (TCP) – NetBIOS服务在windos 2000及以后版本使用此端口, (Common Internet File System，CIFS，它是SMB协议扩展到Internet后，实现Internet文件共享) Port 901 (TCP) – 用于 SWAT，用于网页管理Samba 以下为原理：WinXP共享需要137、138、139，445 137端口这个端口是用来请求NetBios名到IP地址达。比如有人喊“123计算机您共享C盘下的ABC.doc这个文件的IP地址是多少”。于是这个呐喊被广播，只有IP地址是123的回答了。 138端口这个端口是您浏览[网络邻居]用达。您网络里有台计算机叫主浏览器计算机维护着共享列表。所以这个端口封了也就不能通过[网络邻居]来查看其他计算机喽。当然并不防碍彼此通信。 139、445端口通信计算机得到了对方的IP地址以后，就用139或者445端口开始通讯了。如果不是域环境，就是SMB调用139端口通讯。如果是域环境，就是CIFS调用445端口通讯。如果您不想别人访问您的文件呢，就把这两个关闭掉。 这样做只能从外网访问内网中的一台机器共享，因为路由器的对外IP是唯一的。若要访问更多内网共享，只能建FTP，或者VPN之类的，但这种方法是最简单的，不需要在共享机器上有额外的软件设置，只需要路由器设置好即可！！！]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有道云笔记：登陆错误]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%99%BB%E9%99%86%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[错误提醒：请检查IE浏览器是否设置了“阻断所有Cookie”？…… 打开“Internet属性”-&gt;“安全”-&gt;“Internet”-&gt;“该区域的安全级别”：由高改为中高]]></content>
      <tags>
        <tag>有道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 开启多用户远程登陆（远程桌面）]]></title>
    <url>%2F2018%2F11%2F21%2FWin10-%E5%BC%80%E5%90%AF%E5%A4%9A%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Win10 开启多用户远程登陆（远程桌面）系统Win10专业版，已激活 1. 添加用户桌面“此电脑”-&gt;右键“管理” 计算器管理-&gt;本地用户和组-&gt;用户 “用户”-&gt;右键“新用户”填写用户名，密码。去除“用户下次登陆更改密码”，勾选“密码永不过期” 2. 添加远程桌面用户桌面“此电脑”-&gt;右键“属性”-&gt;“远程设置” “系统属性”-&gt;“远程”“远程桌面”-&gt;选择“允许远程连接到此计算机”-&gt;点击“选择用户” “远程桌面用户” 3. 编辑本地组策略win10 左下角搜索栏中 输入 gpedit 打开本地组策略编辑器 选择【计算器配置】-&gt;【管理模板】-&gt;【Windows组件】-&gt;【远程桌面服务】-&gt;【远程桌面会话主机】-&gt;【连接】 限制连接的数量配置 【限制连接的数量】，允许的RD最大连接数 即为最大的连接数量 将远程桌面服务用户限制到单独的远程桌面服务会话配置【将远程桌面服务用户限制到单独的远程桌面服务会话】，改成 “已禁用”/“已启用”“已禁用”：代表一个用户可以多次同时登陆桌面“已启用”：代表一个用户同时只能登陆一个桌面 4. 解除Win10对连接数量限制使用工具 rdpwrap，项目地址，下载页面下载后运行“install.bat”，然后运行“RDPConf.exe”。如果全绿则破解成功；如果出现“Listening [not supported]”则还需运行update.bat]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库下载]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[请输入密码. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>文库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++列出当前路径下所有文件名及子文件夹内文件名]]></title>
    <url>%2F2018%2F11%2F14%2FC-C-%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D%E5%8F%8A%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E6%96%87%E4%BB%B6%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在Win10下，使用VS2015测试可用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;io.h&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt; #include &lt;direct.h&gt; // getcwd();#include &lt;conio.h&gt; // getch(); using namespace std; //获取所有的文件名void GetAllFiles(string path, vector&lt;string&gt;&amp; files)&#123; //printf("\033[1A"); //先回到上一行 //printf("\033[K"); //清除该行 cout &lt;&lt; path &lt;&lt; endl; // 打印当前检索路径 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string p; if ((hFile = _findfirst(p.assign(path).append("\\*").c_str(), &amp;fileinfo)) != -1) &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); GetAllFiles(p.assign(path).append("\\").append(fileinfo.name), files); &#125; &#125; else &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125; &#125; //获取特定格式的文件名void GetAllFormatFiles(string path, vector&lt;string&gt;&amp; files, string format)&#123; //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; // string p; if ((hFile = _findfirst(p.assign(path).append("\\*" + format).c_str(), &amp;fileinfo)) != -1) &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) &#123; //files.push_back(p.assign(path).append("\\").append(fileinfo.name) ); GetAllFormatFiles(p.assign(path).append("\\").append(fileinfo.name), files, format); &#125; &#125; else &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125;&#125; // 该函数有两个参数，第一个为路径字符串(string类型，最好为绝对路径)；// 第二个参数为文件夹与文件名称存储变量(vector类型,引用传递)。// 在主函数中调用格式(并将结果保存在文件"AllFiles.txt"中，第一行为总数)： int main()&#123; /****************************** 获取当前工作路径 *******************************/ char *cCurrentWorkingPath; cCurrentWorkingPath = _getcwd(NULL, 0); if (cCurrentWorkingPath == NULL) &#123; cout &lt;&lt; "getcwd error" &lt;&lt; endl; return 1; &#125; cout &lt;&lt; "Current Working Path:(\"" &lt;&lt; cCurrentWorkingPath &lt;&lt; "\")" &lt;&lt; endl; cout &lt;&lt; "Press any key to start searching" &lt;&lt; endl &lt;&lt; endl; int flag = _getch(); //_getch(); /****************************** 检索文件 *******************************/ string sCurrentWorkingPath = cCurrentWorkingPath; vector&lt;string&gt; fileName; // string容器，用于存放文件名（绝对路径） char * distAll = "outAllFileName.txt"; cout &lt;&lt; "Retrieving folder:" &lt;&lt; endl; //读取所有的文件，包括子文件夹的文件 GetAllFiles(sCurrentWorkingPath, fileName); //读取所有格式为jpg的文件 //string format = ".jpg"; //GetAllFormatFiles(sCurrentWorkingPath, fileName, format); int size = fileName.size(); cout &lt;&lt; "A total of "&lt;&lt; size &lt;&lt;" files/folders were retrieved"&lt;&lt; endl; /****************************** 输出文件名 *******************************/ cout &lt;&lt; "1. Print all file names to the screen and save to file" &lt;&lt; endl; cout &lt;&lt; "2. Print all file names to the screen" &lt;&lt; endl; cout &lt;&lt; "3. Save all file names to the file" &lt;&lt; endl; cout &lt;&lt; "Please enter the serial number:" &lt;&lt; endl; flag = _getch(); //_getch(); ofstream ofn(distAll); switch (flag) &#123; case '1': ofn &lt;&lt; size &lt;&lt; endl; for (int i = 0; i&lt;size; i++) &#123; ofn &lt;&lt; fileName[i] &lt;&lt; endl; cout &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; case '2': for (int i = 0; i&lt;size; i++) &#123; cout &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; case '3': cout &lt;&lt; "Writting......" &lt;&lt; endl; ofn &lt;&lt; size &lt;&lt; endl; for (int i = 0; i&lt;size; i++) &#123; ofn &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; default: break; &#125; ofn.close(); free(cCurrentWorkingPath); /****************************** 结束 *******************************/ cout &lt;&lt; "Press any key to end" &lt;&lt; endl; //getchar(); _getch(); return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
