<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开启文章加密]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%BC%80%E5%90%AF%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[密码为P@ssw0rd Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32相关]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[转自“https://blog.csdn.net/sinat_36184075/article/details/70216197” 宏定义USE_STDPERIPH_DRIVER, STM32F10X_HD 不同类型的型号STM32固件库Libraries\CMSIS\Core\CM3\startup\arm中启动文件的文件名英文缩写意义： cl：互联型产品， stm32f105/107 系列 vl：超值型产品， stm32f100 系列 xl：超高密度（容量） 产品， stm32f101/103 系列 ld：低密度产品， FLASH 小于 64K md：中等密度产品， FLASH=64 or 128 hd：高密度产品， FLASH 大于 128 GPIO_TypeDef 型结构123GPIO_TypeDef * GPIOx; //定义一个 GPIO_TypeDef 型结构体指针 GPIOxGPIOx = GPIOA; //把指针地址设置为宏 GPIOA 地址GPIOx-&gt;CRL = 0xffffffff; //通过指针访问并修改 GPIOA_CRL 寄存器 总线AHB 高级高性能总线，一种系统总线。连接模块如CPU、DMA、DSP等APB 一种外围设备总线。连接模块如UART、I2C等// APB1:低速外设总线；APB2:高速外设总线。 时钟 高速外部时钟（HSE） 以外部晶振作时钟源，晶振频率可取范围为4~16MHz，我们一般采用’ 8MHz ‘的晶振。 高速内部时钟（HSI） 由内部 RC 振荡器产生，频率为 8MHz，但不稳定。 低速外部时钟（LSE） 以外部晶振作时钟源，主要提供给实时时钟模块，所以一般采用 32.768KHz。 野火 M3 实验板上用的是 32.768KHz， 6p 负载规格的晶振。 低速内部时钟（LSI） 由内部 RC 振荡器产生，也主要提供给实时时钟模块，频率大约为 40KHz。 锁相环 PLL主要功能是倍频（扩大频率），经过PLL 的时钟称为 PLLCLK。GPIO时钟GPIO 外设是挂载在 APB2 总线上的， APB2 的时钟是 APB2 预分频器的输出，而 APB2 预分频器的时钟来源是 AHB 预分频器。因此，把APB2 预分频器设置为不分频，那么我们就可以得到 GPIO 外设的时钟也等于 HCLK。 PCLK2：外设时钟，由 APB2 预分频器输出得到，最大频率可为72MHz，提供给挂载在 APB2 总线上的外设。 ‘ STM32每个外设都配备了外设时钟的开关，当我们不使用某个外设时，可以把这个外设时钟关闭，从而降低 STM32 的整体功耗。所以，当我们使用外设时，一定要记得开启外设的时钟啊，亲。 （STM32时钟：接收中断事件，降低功耗） 【GPIO相关结构体】123456typedef struct&#123; uint16_t GPIO_Pin; /* 指定将要进行配置的 GPIO 引脚 */ GPIOSpeed_TypeDef GPIO_Speed; /* 指定 GPIO 引脚可输出的最高频率 */ GPIOMode_TypeDef GPIO_Mode; /* 指定 GPIO 引脚将要配置成的工作状态 */&#125; GPIO_InitTypeDef; 123456typedef enum&#123; GPIO_Speed_10MHz = 1, // 枚举常量，值为 1，代表输出速率最高为 10MHz GPIO_Speed_2MHz, // 对不赋值的枚举变量，自动加 1，此常量值为 2 GPIO_Speed_50MHz // 常量值为 3&#125; GPIOSpeed_TypeDef; 12345678910typedef enum&#123; GPIO_Mode_AIN = 0x0, // 模拟输入模式 GPIO_Mode_IN_FLOATING = 0x04, // 浮空输入模式 GPIO_Mode_IPD = 0x28, // 下拉输入模式 GPIO_Mode_IPU = 0x48, // 上拉输入模式 GPIO_Mode_Out_OD = 0x14, // 开漏输入模式 GPIO_Mode_Out_PP = 0x10, // 通用推挽输出模式 GPIO_Mode_AF_OD = 0x1C, // 复用功能开漏输出 GPIO_Mode_AF_PP = 0x18 // 复用功能推挽输出&#125; GPIOMode_TypeDef; 【初始化函数库】#include “stm32f10x_gpio.c”void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)功能：初始化指定的GPIO管脚参数： @ GPIOx ：外设硬件对应的GPIO管脚地址(已在stm32f10x.h中被强转定义) @ GPIO_InitStruct ：需要此函数调用前定义该结构体变量，传其地址。返回值：none 12345/* 代码演示 - 多个GPIO参数同时赋值 */GPIO_InitTypeDef GPIO_InitStruct;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; /* 引脚模式为通用推挽输出 */GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* 引脚速率为50MHz */ 【外设时钟控制函数】#include “stm32f10x_rcc.c”void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)功能：控制挂载在APB2上外设的时钟使能或禁止参数： @ RCC_APB2Periph ：指定外设去控制对应设备的时钟，参数可任意组合，参数如下 * RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB, * RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE, * RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1, * RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1, * RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3, * RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17, * RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11 @ NewState ：指定时钟的新的状态，参数如下 ENABLE or DISABLE返回值：none// 对应的如果挂载在APB1上，对应函数为 void RCC_APB1PeriphClockCmd (.., ..) 【控制I/O输出高、低电平函数】#include “stm32f10x_gpio.c”void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)功能：&lt;设置&gt;选定的GPIO数据端口位参数： @ GPIOx ：GPIO管脚类型，x可指定为AG @ GPIO_Pin ：指定被写入的数据端口位，即引脚号 Pin0Pin15返回值：none #include “stm32f10x_gpio.c”void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)功能：&lt;清除&gt;选定的GPIO数据端口位参数： @ GPIOx ：GPIO管脚类型，x可指定为AG @ GPIO_Pin ：指定被写入的数据端口位，即引脚号 Pin0Pin15返回值：none /*** 规范的位操作实现方法 ***/由于库函数的实现涉及到不少位操作，首先为读者介绍一下几个常用的位操作方法，排除阅读代码的障碍。1、 将 char 型变量 a 的第七位(bit6)清 0， 其它位不变。 a &amp;= ~(1&lt;&lt;6); // 括号内 1 左移 6 位，得二进制数： 0100 0000 // 按位取反，得 1011 1111 ，所得的数与 a 作”位与&amp;”运算， // a 的第 7 位（ bit6） 被置零，而其它位不变。2、 同理，将变量 a 的第七位(bit6)置 1，其它位不变的方法如下。 a |= (1&lt;&lt;6); // 把第七位（ bit6）置 1，其它为不变3、 将变量 a 的第七位(bit6)取反，其它位不变。 a ^=(1&lt;&lt;6); // 把第七位（ bit6）取反，其它位不变 【推挽输出】推挽输出的低电平为 0 伏，高电平为 3.3 伏。STM32 的 GPIO 输出模式就分为： 普通推挽输出(GPIO_Mode_Out_PP) 普通开漏输出(GPIO_Mode_Out_OD) 及复用推挽输出(GPIO_Mode_AF_PP) 复用开漏输出(GPIO_Mode_AF_OD ) 普通推挽输出模式一般应用在输出电平为 0 和 3.3 伏的场合。而普通开漏输出一般应用在电平不匹配的场合，如需要输出 5 伏的高电平，就需要在外部接一个上拉电阻，电源为 5 伏，把 GPIO 设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出 5 伏的电平。对于相应的复用模式，则是根据 GPIO 的复用功能来选择的，如 GPIO 的引脚用作串口的输出，则使用复用推挽输出模式。如果用在 IC、 SMBUS 这些需要线与功能的复用场合，就使用复用开漏模式。其它不同的复用场合的复用模式引脚配置将在具体的例子中讲解。在使用任何一种开漏模式，都需要接上拉电阻。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32-FreeRTOS知识整理总结]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32-FreeRTOS%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考自“https://www.cnblogs.com/lifexy/p/10463050.html” 1. 基础知识 注意:在RTOS中是优先值越高则优先级越高(和ucos/linux的相反) 在移植的时候,主要裁剪FreeRTOS/Source/portable文件夹,该文件夹用来针对不同MCU做的一些处理,如下图所示,我们只需要使用: FreeRTOS/Source/portable/Keil 使用MDK编译环境所需要使用的文件FreeRTOS/Source/portable/RVDS 内存管理相关的文件，移植所必需的FreeRTOS/Source/portable/MemMang 使用MDK编译环境所需要使用的文件 1.1配置工程时,选择memMang时,一般使用heap_4.c heep_1.c只能分配内存而不能释放内存。 heep_2.c可以分配和释放内存但不能合并空闲内存块。 heep_3.c简单的封装了线程安全版的标准C语言malloc和free函数。 heap_4: 优点在于可以有效的利用内存碎片来合并为一个大内存.缺点在于只能用来一个ram里. heap_5: 一般针对有外部RAM才用到,优点在于可以同时利用内部ram和外部ram来进行内存碎片合并. 然后我们在分配释放内存的时候,就尽量使用RTOS带的函数来实现,分配/释放函数如下所示: 12void *pvPortMalloc( size_t xWantedSize ); void vPortFree( void *pv ); 1.2 添加头文件路径添加FreeRTOS\include添加FreeRTOS\portable\RVDS\ARM_CM3并将原子中的FreeRTOSConfig.h也复制到我们项目的FreeRTOS\include中(用来配置RTOS系统) 2. FreeRTOSConfig.h配置介绍一般会写configXXXXX或者INCLUDE_XXXX类似的宏,这两个宏区别在于: configXXXXX用来实现不同功能,比如定义configUSE_COUNTING_SEMAPHORES为1时,表示使用计数信号量 INCLUDE_XXXX用来是否将某个API函数编译进程序中.比如定义INCLUDE_xTaskGetSchedulerState 为1 时,则将会编译xTaskGetSchedulerState()函数,如下图所示: 3. FreeRTOS任务状态3.1 运行态指当前任务正在运行. 3.2 就绪态指当前任务正在等待调度,因为有个高优先级/同优先级的任务正在运行中 3.3 阻塞态当前任务处于等待外部事件通知或通过vTaskDelay()函数进入休眠了,外部事件通知常见有信号量、等待队列、事件标志组、任务通知. 3.4 挂起态类似于暂停,表示不会再参与任务调度了,通过vTaskSuspend()实现,重新恢复调度则使用xTaskResume() 4. FreeRTOS中断配置4.1 回忆stm32 NVIC中断 比如我们设置为NVIC_PriorityGroup_4时:表示抢占优先级为4bit(即为2^4,为0~15个抢占优先级),副优先级为0bit(表示没有). 4.2 抢占优先级和副优先级的区别: 抢占优先级和副优先级的值越低,则优先级越高 高的抢占优先级的中断可以直接打断低的抢占优先级的中断 高的副优先级的中断不可以打断低的副优先级的中断(只是两个相同抢占优先级的中断同时来的时候,只会优先选择高的副优先级) 4.3 FreeRTOS中断配置宏configKERNEL_INTERRUPT_PRIORITY用来配置中断最低抢占优先级,也就是可以FreeRTOS可以管理的最小抢占优先级,所以使用FreeRTOS时,我们尽量设置stm32为NVIC_PriorityGroup_4,这样就可以管理16个优先级了. configMAX_SYSCALL_INTERRUPT_PRIORITY用来配置FreeRTOS能够安全管理的的最高优先级.比如原子的FreeRTOSConfig.h里就设置为5,而0-4的优先级中断就不会被FreeRTOS因为开关中断而禁止掉(一直都会有),并且不能调用RTOS中的”FromISR”结尾的API函数.比如喂看门狗中断函数就需要设置为0-4. 如下图所示(来自原子手册): 4.3 FreeRTOS中断开关函数 12345portENABLE_INTERRUPTS(); //开中断,将configMAX_SYSCALL_INTERRUPT_PRIORITY至 configKERNEL_INTERRUPT_PRIORITY之间的优先级中断打开portDISABLE_INTERRUPTS(); //关中断,将configMAX_SYSCALL_INTERRUPT_PRIORITY至 configKERNEL_INTERRUPT_PRIORITY之间的优先级中断禁止掉 5.任务常用API函数5.1 xTaskCreate创建任务函数定义如下: 1234567891011xTaskCreate( TaskFunction_t pxTaskCode, //任务函数,用来供给函数指针调用的 const char * const pcName, //任务的字符串别名 const uint16_t usStackDepth, //任务堆栈深度,实际申请到的堆栈是该参数的4倍 void * const pvParameters, //函数参数,用来供给指针调用的 UBaseType_t uxPriority, //优先级,越高优先级高,范围为0~configMAX_PRIORITIES-1 //注意优先级0会创建为空闲任务, 优先级configMAX_PRIORITIES-1会创建一个软件定时器服务任务(管理定时器的) TaskHandle_t * const pxCreatedTask //任务句柄,该句柄可以用于挂起/恢复/删除对应的任务 );//返回值 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(-1):表示创建任务堆空间不足pdPASS(1):创建成功 5.2 taskENTER_CRITICAL()和taskEXIT_CRITICAL()用于任务中进入/退出临界区,调用taskENTER_CRITICAL()主要会关闭其他任务调度.而taskEXIT_CRITICAL()则会恢复任务调度,一般用于初始化外设等. 5.3 taskENTER_CRITICAL_FROM_ISR()和taskEXIT_CRITICAL_FROM_ISR()用于在中断函数中进入/退出临界区,作用和上面一样 5.4 挂起/恢复/删除任务函数1234void vTaskSuspend( TaskHandle_t xTaskToSuspend ); //挂起一个任务,参数为挂起任务的句柄,如果为NULL则表示挂起自身任务void vTaskResume( TaskHandle_t xTaskToResume ); //恢复一个任务BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume);//从中断函数中恢复一个任务,返回1表示恢复成功void vTaskDelete( TaskHandle_t xTaskToDelete ); //删除一个任务,如果从任务函数中退出的话,则需要调用vTaskDelete(NULL)来删除自身任务 5.5 vTaskDelay()延时函数1void vTaskDelay( const TickType_t xTicksToDelay ); //参数表示延时的系统滴答数 比如延时500ms可以写为: vTaskDelay( 500/portTICK_RATE_MS );portTICK_RATE_MS是个宏,表示当前系统的1个滴答需要多少ms,而500/portTICK_RATE_MS则表示当前500ms需要多少个系统滴答数. 6. 队列6.1 简介队列用于任务与任务或者任务与中断之间的通信.比如key任务检测到按键按下时,则可以通过队列向lcd显示任务发送信息,使得lcd切换界面.队列采用先进先出存储机制.队列发送数据可以有两种方式:浅拷贝、深拷贝. 数据量不大的情况下,都使用深拷贝(会分配新的空间,并进行数据拷贝,缺点在于耗时) 数据量大的情况下,都使用浅拷贝(通过指针方式,前提是要发送的数据必须不会被释放的) 6.2 队列的优点队列可以通过任何任务或者中断进行访问,可以随时存取数据消息.并且出入队的时候可以进行任务阻塞,比如某个任务进行读消息出队时,如果没有消息,则可以实现进入休眠状态,直到有消息才唤醒任务. 6.3 队列创建删除相关API123456789101112131415161718QueueHandle_t xQueueCreate( uxQueueLength, uxItemSize ); //动态创建队列,内存会交给RTOS自动分配 // uxQueueLength:队列长度(表示队列中最大多少条消息),uxItemSize:每个队列消息的长度(以字节为单位) //返回值: NULL(0, 表示分配失败),非0(表示返回该队列分配好的地址) //注意:使用自动分配时,需要配置configSUPPORT_DYNAMIC_ALLOCATION宏为1,否则只能由用户来分配.QueueHandle_t xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ); //静态创建队列,内存需要由用户事先分配好 // uxQueueLength:队列长度(表示队列中最大多少条消息),uxItemSize:每个队列消息的长度(以字节为单位) // pucQueueStorage:指向用户事先分配好的存储区内存(必须为uint8_t型) // pxQueueBuffer:指向队列结构体,用来提供给RTOS初始化.然后给用户使用 //返回值: NULL(0, 表示分配失败),非0(表示返回该队列分配好的地址)vQueueDelete( QueueHandle_t xQueue ); //删除队列,并释放空间xQueueReset( xQueue ); //将队列里的消息清空一次,也就是恢复初始状态 6.4队列出入队相关API1234567891011121314151617181920212223242526xQueueSend( xQueue, pvItemToQueue, xTicksToWait ); //插入队尾,和xQueueSendToBack函数效果一致 // xQueue:队列句柄 //PvItemToQueue:消息数据,会通过数据拷贝到队列中,如果想使用浅拷贝,则可以发送一个变量来存储要真正发送的缓冲区地址即可. // xTicksToWait:阻塞时间,单位为RTOS时钟滴答值,如果configTICK_RATE_HZ是1000,则填入的值表示阻塞的是多少ms,否则的话需要通过X/portTICK_RATE_MS来转换一下,才能实现阻塞Xms. //xTicksToWait==0:表示入队满了,则直接退出该函数 // xTicksToWait==portMAX_DELAY:表示一直阻塞,直到队列有空位为止. //注意: INCLUDE_vTaskSuspend宏必须为1,否则任务无法进入休眠状态实现阻塞效果. //返回值: errQUEUE_FULL(队列已满) pdPASS(通过)xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ); //插入队头,参数和上面描述一致xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ); //插入队尾,参数和上面描述一致xQueueOverwrite( xQueue, pvItemToQueue ); //将之前未出队的旧数据全部清空,然后再入队,该函数适用于长度为1的队列xQueueReceive( xQueue, pvBuffer, xTicksToWait ); //从队列头部读出一个消息,并且这个消息会出队(删除掉)xQueuePeek( xQueue, pvBuffer, xTicksToWait ); //从队列头部读出一个消息,但是这个消息不会出队(不会删除) PS:这些API函数只能用于任务里调用,如果要在中断服务函数中调用,则在函数名后添加FromQueue即可,比如xQueueSendFromQueue()函数 6.5 中断发送/读取消息队列时,要注意的事情使用中断相关的读写队列相关的API时,第3个参数是不一样的,比如xQueueSendFromISR(): 1xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) PxHigherPriorityTaskWoken用来标记退出该函数后是否需要进行任务切换,因为我们发送队列时,有可能会将某个阻塞任务退出阻塞态,而此时又在中断中,所以当PxHigherPriorityTaskWoken为pdTRUE时,我们则必须进行一次任务切换. 可以通过portYIELD_FROM_ISR()来进行任务切换,并且我们不需要去判断PxHigherPriorityTaskWoken是否为pdTRUE,因为该函数内部有判断的,如下图所示: 来个中断函数发送队列示例: 123456789101112131415161718extern QueueHandle_t Message_Queue; //信息队列句柄void USART1_IRQHandler(void) //串口1中断服务程序&#123; BaseType_t xHigherPriorityTaskWoken; //定义任务切换标志位 if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; //处理中断接收数据 &#125; if (Message_Queue!=NULL) //判断Message_Queue是否已创建 &#123; xQueueSendFromISR(Message_Queue, RX_BUF,&amp;xHigherPriorityTaskWoken); //向队列Message_Queue中发送RX_BUF portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //通过portYIELD_FROM_ISR()判断是否需要切换任务 &#125;&#125; PS:尽量将portYIELD_FROM_ISR()写在中断函数末尾处 6.6示例-任务之间的伪代码按键任务向打印任务发送按键消息队列,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344QueueHandle_t Key_Queue; //按键值消息队列句柄int main()&#123; //...省略N行代码 Key_Queue = xQueueCreate(1,sizeof(u8)); //创建消息Key_Queue,长度为1 //创建两个任务:key_task()、print_task() //...省略N行代码&#125;key_task() //获取按键值&#123; while(1) &#123; key=KEY_Scan(0); //扫描按键 if((Key_Queue!=NULL)&amp;&amp;(key)) //消息队列Key_Queue创建成功,并且按键被按下 &#123; err=xQueueSend(Key_Queue,&amp;key,10); if(err==errQUEUE_FULL) //发送按键值 &#123; printf("队列Key_Queue已满，数据发送失败!\r\n"); &#125; &#125; vTaskDelay(10); //延时10个时钟节拍 &#125;&#125;print_task() //打印按键值&#123; u8 key; while(1) &#123; if(Key_Queue!=NULL) &#123; if(xQueueReceive(Key_Queue,&amp;key,portMAX_DELAY))//请求消息Key_Queue &#123; printf("key=%d\r\n",key); &#125; &#125; vTaskDelay(10); //延时10个时钟节拍 &#125;&#125; 7. RTOS软件定时器7.1简介在之前的任务创建的时候有讲到过,RTOS会自动创建一个优先级configMAX_PRIORITIES-1的软件定时器服务任务(管理定时器的). 所以我们写一个定时器回调函数时,则会被该定时器服务任务调用,所以在我们软件定时器函数中不能使用** vTaskDelay() **阻塞之类的API函数,否则会将系统中的定时器服务函数给阻塞掉. 7.2 FreeRTOSConfig.h相关的定时器配置1234#define configUSE_TIMERS 1 //为1时启用软件定时器#define configTIMER_TASK_PRIORITY 31 //设置软件定时器优先级可设置的值范围为0~31#define configTIMER_QUEUE_LENGTH 5 //软件定时器队列长度#define configTIMER_TASK_STACK_DEPTH 200 //设置每个软件定时器任务堆栈大小 7.3定时创建相关API1234567TimerHandle_t xTimerCreateStatic( const char * const pcTimerName, //定时器字符串别名 const TickType_t xTimerPeriodInTicks, //需要定时的周期值,比如通过200/ portTICK_RATE_MS来转换实现定时200毫秒 const UBaseType_t uxAutoReload, //是否重载(周期性/单次性),若为pdTRUE(1)表示为周期性,为pdFALSE(0)表示为单次 void * const pvTimerID, //定时器ID号,一般用于多个定时器共用一个定时器回调函数,否则填0即可 TimerCallbackFunction_t pxCallbackFunction //定时器回调函数 ); 12xTimerDelete( xTimer, xTicksToWait ); //删除定时器//xTicksToWait:指定该定时器在多少时钟节拍数之前删除掉,为0则立即删除,一般设为100(如果设为0,则如果在该操作之前还有其它设置定时器操作的话,则不会进行阻塞等待,从而返回false) 7.4 定时器其它常用API12345678910111213xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ); //修改定时器周期,在中断中则使用xTimerChangePeriodFromISR() // xNewPeriod:要修改的周期值 //xTicksToWait:指定该定时器在多少时钟节拍数之前修改好,为0则立即删除 //xTimerReset( xTimer, xTicksToWait ); //复位定时器,让定时器重新计数,在中断中则使用xTimerResetFromISR() // xTicksToWait:和上面内容类似xTimerStart( xTimer, xTicksToWait ); //启动定时器,如果定时器正在运行的话调用该函数的结果和xTimerReset()一样, 在中断中则使用xTimerResetFromISR ()xTimerStop( xTimer, xTicksToWait ); //停止定时器, 在中断中则使用xTimerStopFromISR () PS:在中断中使用定时器API时,同样和队列一样,也需要在函数末尾通过portYIELD_FROM_ISR()进行一次任务切换判断 8. 信号量在项目中我们一般用二值信号量,用来同步数据的. 比如任务A要向任务B发送一个很大的数据buf,而用队列的话会进行复制拷贝,从而占用大量时间. 此时我们不妨定义一个全局数据buf,任务A修改这个buf,发送一个信号量给任务B,任务B就去读取这个全局数据buf即可.从而省去了队列复制拷贝的时间. 8.1定义信号量举例12SemaphoreHandle_t BinarySemaphore; //二值信号量句柄BinarySemaphore=xSemaphoreCreateBinary(); //创建二值信号量 8.2在中断中发送信号量过程123BaseType_t xHigherPriorityTaskWoken;xSemaphoreGiveFromISR(BinarySemaphore,&amp;xHigherPriorityTaskWoken);//发送二值信号量portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果需要的话进行一次任务切换 8.3在任务中发送信号量过程1xSemaphoreGive(BinarySemaphore); //返回值: pdPASS(0, 表示发送成功,如果信号量一直未处理,则会返回值失败FULL) 8.4 在任务中接收信号量过程123err = xSemaphoreTake(BinarySemaphore,portMAX_DELAY); //获取信号量// portMAX_DELAY:进入阻塞态一直等待获取//返回值为pdTRUE(OK) pdFALSE(err)]]></content>
      <categories>
        <category>STM32</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32F105RC新建工程，移植FreeRTOS]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32F105RC%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%EF%BC%8C%E7%A7%BB%E6%A4%8DFreeRTOS%2F</url>
    <content type="text"><![CDATA[1. STM32工程创建 注：工程创建方法参照正点原子 1.1 准备 开发环境，Keil MDK 5.26，下载地址 STM32F1 PACK包，下载地址 ST官方标准外设库，目前版本3.5.0，下载地址 开发板 1.2 开始1.2.1 Keil环境安装Keil环境，破解，安装STM32 F1 PACK包 1.2.2 创建工程 创建文件夹为 STM32_F105RC-FreeRTOS 在Template内创建文件夹USER、CORE、OBJ、STM32F10x_FWLib USER 用来存放自己添加的代码 CORE 用来存放核心文件和启动文件 OBJ 是用来存放编译过程文件以及 hex 文件 STM32F10x_FWLib 文件夹顾名思义用来存放 ST 官方提供的库函数源码文件 运行Keil，点击 MDK 的菜单： Project –&gt;New Uvision Project，然后将目录定位到刚才建立的文件夹 STM32_F105RC-FreeRTOS。工程命名为 STM32_F105RC-FreeRTOS，点击保存。 接下来会出现一个选择 CPU 的界面，就是选择我们的芯片型号。STMicroelectronics-&gt;STM32F1 Series-&gt;STM32F105-&gt;STM32F105RCT6 特别注意： 一定要安装对应的器件 pack 才会显示这些内容哦！！ 点击 OK， MDK 会弹出 Manage Run-Time Environment 对话框，直接点击 Cancel。 此时一个框架工程建立完毕，还需要添加启动代码，以及.c 文件等。 修改默认调试工具：魔术棒图标-&gt;Debug-&gt;下拉ST-Link Debugger 修改下载后自动复位运行：魔术棒图标-&gt;Debug-&gt;右侧Setting-&gt;Flash Download-&gt;勾选Reset and Run 调整工程输出文件目录 魔术棒图标-&gt;Output-&gt;Select Folder for Objects…-&gt;选择OBJ目录。同时勾选Create HEX File 魔术棒图标-&gt;Listing-&gt;Select Folder for Objects…-&gt;选择OBJ目录 删除工程目录下的Objects、Listings文件夹 1.2.3 移植固件库包 打开官方固件库包，进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver，将将目录下面的 src，inc 文件夹 copy 到我们刚才建立的 STM32F10x_FWLib 文件夹下面 src 存放的是固件库的.c 文件 inc 存放的是对应的.h 文件 打开官方固件库包，进入目录STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport 下面，将文件 core_cm3.c 和 文件 core_cm3.h 复制到 CORE 内 打开官方固件库包，进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm 下面，将里面 startup_stm32f10x_cl.s 文件复制到 CORE 内 STM32固件库Libraries\CMSIS\Core\CM3\startup\arm中启动文件的文件名英文缩写意义： cl：互联型产品， stm32f105/107 系列 vl：超值型产品， stm32f100 系列 xl：超高密度（容量） 产品， stm32f101/103 系列 ld：低密度产品， FLASH 小于 64K md：中等密度产品， FLASH=64 or 128 hd：高密度产品， FLASH 大于 128 进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x，将文件 stm32f10x.h， system_stm32f10x.c， system_stm32f10x.h，复制到 USER 内 进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template，将文件 main.c， stm32f10x_conf.h， stm32f10x_it.c， stm32f10x_it.h 复制到 USER 内 1.2.4 将固件库文件添加到工程 右键点击 Target1，选择 Manage Project Items。 Project Targets 一栏，我们将 Target 名字修改为 STM32_F105RC-FreeRTOS。然后在 Groups 一栏删掉一个 Source Group1，建立三个 Groups： USER,CORE,FWLIB。然后点击 OK。 右键点击点击 STM32_F105RC-FreeRTOS， 选择 Manage Project Itmes， 然后选择需要添加文件的 Group，这里第一步我们选择 FWLIB，然后点击右边的 Add Files,定位到我们刚才建立的目录 STM32F10x_FWLib/src 下面，将里面所有的文件选中(Ctrl+A)，然后点击 Add，然后 Close.可以看到 Files 列表下面包含我们添加的文件。 如果只用到了其中的某个外设，可以不用添加没有用到的外设的库文件。例如只用 GPIO，可以只用添加 stm32f10x_gpio.c 而其他的可以不用添加。这里全部添加进来是为了后面方便，不用每次添加，当然4这样的坏处是工程太大，编译起来速度慢，可以自行选择。 用同样的方法，将 Groups 定位到 CORE 下面，添加需要的文件：core_cm3.c， startup_stm32f10x_hd.s 注意，默认添加的时候文件类型为.c,也就是添加 startup_stm32f10x_hd.s 启动文件的时候，你需要选择文件类型为 All files 才能看得到这个文件 将 Groups 定位到 USER 下面，添加需要的文件：main.c， stm32f10x_it.c，system_stm32f10x.c 点击OK，返回主界面 1.2.5 添加头文件 点击魔术棒-&gt;C/C++-&gt;Include Pash-&gt;点击… 添加目录 ./COER ./USER ./STM32F10x_FWLib/inc 1.2.6 添加宏定义 点击魔术棒-&gt;C/C++-&gt;Define 填入“STM32F10X_CL,USE_STDPERIPH_DRIVER” 不同芯片，STM32F10X_CL后缀不同，具体参见 章节1.3.3 3. 1.2.7 修改main.c将内容改为以下 1234567891011121314151617181920212223242526272829#include "stm32f10x.h"// 简单延时函数void Delay(u32 count)&#123; u32 i=0; for(;i&lt;count;i++);&#125;// 主函数int main(void)&#123; // GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED0--&gt;PD.2 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 口速度为 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //根据设定参数初始化 GPIOD.2 GPIO_SetBits(GPIOD,GPIO_Pin_2); //PD.2 输出高 // 循环控制D2高低电平 while(1) &#123; GPIO_SetBits(GPIOD,GPIO_Pin_2); Delay(3000000); GPIO_ResetBits(GPIOD,GPIO_Pin_2); Delay(3000000); &#125;&#125; 1.2.8 下载运行LED灯闪烁 1.3 串口打印1.3.1 串口初始化代码 在main.c增加串口初始化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125; 增加Printf映射代码 12345678910111213141516#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125; 包含头文件 1#include &lt;stdio.h&gt; // FILE main()中调用串口初始化，添加printf打印，发现串口打印乱码。找资料说是始终问题。打开stm32f10x.h，找到以下代码，手动定义时钟值 12345678910111213141516/** * @brief In the following line adjust the value of External High Speed oscillator (HSE) used in your application Tip: To avoid modifying this file each time you need to use different HSE, you can define the HSE value in your toolchain compiler preprocessor. */ // 根据板子实际情况手动设置时钟值#define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */#if !defined HSE_VALUE #ifdef STM32F10X_CL #define HSE_VALUE ((uint32_t)25000000) /*!&lt; Value of the External oscillator in Hz */ #else #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* STM32F10X_CL */#endif /* HSE_VALUE */ 修改时钟后，串口正常工作 2. FreeRTOS移植2.1 准备 上一步中建立好的工程 STM32_F105RC-FreeRTOS FreeRTOS源码，运行freertos.exe自解压 2.2 开始2.2.1 移植文件 在 STM32_F105RC-FreeRTOS工程文件夹 中新建文件夹FreeRTOS 进入OS源码路径FreeRTOSv10.2.1\FreeRTOS\Source，将目录内include文件夹，及所有*.c文件复制到刚创建的FreeRTOS文件夹内 这些是平台无关的代码，所有平台都需要使用的 进入OS源码路径FreeRTOSv10.2.1\FreeRTOS\Source\protable\MemMang目录。复制heep_2.c到刚创建的FreeRTOS文件夹内 该目录下是内存管理的相关代码 heep_1.c只能分配内存而不能释放内存。 heep_2.c可以分配和释放内存但不能合并空闲内存块。 heep_3.c简单的封装了线程安全版的标准C语言malloc和free函数。 heep_4.c可以合并相邻的空闲内存块。 heep_5.c可以合并相邻的空闲内存块，且可以管理多个内存。 目标平台是Keil，打开FreeRTOSv10.2.1\FreeRTOS\Source\protable\Keil文件夹看到如下文件“See-also-the-RVDS-directory.txt”。因此打开FreeRTOSv10.2.1\FreeRTOS\Source\portable\RVDS\，根据型号进入目录 \ARM_CM3\，复制文件port.c到刚创建的FreeRTOS文件夹内，复制文件portmacro.h到刚创建的FreeRTOS\include文件夹内 FreeRTOSv10.2.1\FreeRTOS\Source\portable\RVDS路径下有不同的型号，根据实际情况选择 ARM_CA9 ARM_CM0 ARM_CM3 ARM_CM4_MPU ARM_CM4F ARM_CM7 ARM7_LPC21xx 进入路径FreeRTOSv10.2.1\FreeRTOS\Demo，由于使用Keil+STM32F105RC，所以进入CORTEX_STM32F103_Keil，复制FreeRTOSConfig.h到刚创建的FreeRTOS\include文件夹内 2.2.2 将OS文件添加到工程 打开Keil工程，Project Target上右键STM32_F105RC-FreeRTOS，选择 Manage Project Items。 在 Groups 一栏增加 FreeRTOS 分组。然后点击 Add File，将FreeRTOS文件夹内所有*.c添加。 点击OK。 2.2.3 添加头文件 点击魔术棒-&gt;C/C++-&gt;Include Pash-&gt;点击… 添加目录 .\FreeRTOS\include 2.2.4 修改 打开FreeRTOSConfig.h文件，在最后(#endif前)添加宏定义，这些宏将Freertos的这三个回调跟stm32官方的对应起来，这样就不用修改启动文件。 123#define vPortSVCHandler SVC_Handler#define xPortPendSVHandler PendSV_Handler#define xPortSysTickHandler SysTick_Handler 同时需要将stm32f10x_it.c里边对应的三个函数注释掉或者加上weak关键字。 123__weak void SVC_Handler(void)__weak void PendSV_Handler(void)__weak void SysTick_Handler(void) 打开FreeRTOSConfig.h文件，在最后(#endif前)添加宏定义 此宏定义作用未知，不加编译会报错 1#define configUSE_MUTEXES 1 2.2.5 包含头文件在使用FreeRTOS的文件内包含头文件 12345// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量 2.3 测试修改main.c如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include "stm32f10x.h"#include &lt;stdio.h&gt;// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量// 几个打印任务中计数值u32 g_printf1_conter = 0;u32 g_printf2_conter = 0;u32 g_printf3_conter = 0;// 映射Printf相关#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //?úê1ó?printfê±?μí3×??ˉì?ó?′?oˉêy&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125;// 简单延时函数void Delay(u32 count)&#123; static u32 i=0; for(i = 0; i &lt; count; i++);&#125;// 延时1ms（不准确的延时）void Delay_ms(u32 ms)&#123; static u32 i = 0; for(i = 0; i &lt; ms; i++) &#123; Delay(4000); &#125;&#125;// Led IO初始化void Led_Init(void)&#123; // LED GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED2--&gt;PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 速度 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); // IO初始化 GPIO_SetBits(GPIOD, GPIO_Pin_2); // 设置电平PD.2&#125;// Led打开void Led_Open(void)&#123; GPIO_ResetBits(GPIOD,GPIO_Pin_2);&#125;// Led关闭void Led_Close(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_2);&#125;void Led_Test(void *pvParameters)&#123; while(1) &#123; Led_Open(); vTaskDelay( 100/portTICK_RATE_MS ); Led_Close(); vTaskDelay( 100/portTICK_RATE_MS ); &#125;&#125;//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125;void USART_Test1(void *pvParameters)&#123; while(1) &#123; printf("USART 1 hello world %04d\r\n", g_printf1_conter++); vTaskDelay( 500/portTICK_RATE_MS ); &#125;&#125;void USART_Test2(void *pvParameters)&#123; while(1) &#123; printf("USART 2 hello world %04d\r\n", g_printf2_conter++); vTaskDelay( 800/portTICK_RATE_MS ); &#125;&#125;void USART_Test3(void *pvParameters)&#123; while(1) &#123; printf("USART 3 hello world %04d\r\n", g_printf3_conter++); vTaskDelay( 1100/portTICK_RATE_MS ); &#125;&#125;/*-----------------------------------------------------------*/static void prvSetupHardware( void )&#123; SystemInit(); Led_Init(); USART1_init(115200);&#125;/************************************************************/// 主函数/************************************************************/int main(void)&#123; // 初始化硬件平台 prvSetupHardware(); printf("hello world\r\n"); Delay_ms(1000); /* 建立任务 */ xTaskCreate( Led_Test, "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+3, NULL ); xTaskCreate( USART_Test1, "UART1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test2, "UART2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test3, "UART3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); /* 启动OS */ vTaskStartScheduler();&#125; FreeRTOS移植完成，多任务运行基本实现 任务1：100ms设置Led闪烁 任务2：串口每隔500ms打印“USART 1 hello world xxxx” 任务3：串口每隔800ms打印“USART 2 hello world xxxx” 任务4：串口每隔1100ms打印“USART 3 hello world xxxx” 3. FreeRTOS下串口中断接收3.1 main.c代码修改3.1.1 定义变量1xQueueHandle g_xQueueRx; 3.1.2 增加宏定义1#define EN_USART1_RX 1 // 使能了接收 3.1.3 增加串口中断处理函数1234567891011121314#if EN_USART1_RX //如果使能了接收void USART1_IRQHandler(void)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 cChar; if(USART_GetITStatus (USART1,USART_IT_RXNE)!=RESET) &#123; cChar=USART_ReceiveData(USART1); xQueueSendToBackFromISR (g_xQueueRx, &amp;cChar, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); &#125;&#125;#endif 3.1.2 中断向量表配置12345678910111213void NVIC_Configuration(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_4); #if EN_USART1_RX //如果使能了接收 // 配置串口1中断向量 NVIC_InitStructure .NVIC_IRQChannel =USART1_IRQn ; NVIC_InitStructure .NVIC_IRQChannelPreemptionPriority =6; NVIC_InitStructure .NVIC_IRQChannelCmd =ENABLE ; NVIC_Init(&amp;NVIC_InitStructure );#endif&#125; 3.1.3 串口接收任务创建12345678910111213141516void vPC_Communication_Task(void *pvParameters)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 rx=0; g_xQueueRx = xQueueCreate(20,sizeof(u8)); while(1) &#123; if(xQueueReceiveFromISR(g_xQueueRx, &amp;rx, &amp;xHigherPriorityTaskWoken)) &#123; printf("%c\r\n", rx); &#125; vTaskDelay(10/portTICK_RATE_MS ); &#125;&#125; 3.1.4 增加NVIC初始化在函数static void prvSetupHardware( void )中，增加 1NVIC_Configuration(); 3.1.5 增加创建任务1xTaskCreate( vPC_Communication_Task, "UART_RECV", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); 3.2 最终main.c如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include "stm32f10x.h"#include &lt;stdio.h&gt;// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量#define EN_USART1_RX 1// 几个打印任务中计数值u32 g_printf1_conter = 0;u32 g_printf2_conter = 0;u32 g_printf3_conter = 0;xQueueHandle g_xQueueRx;#define EN_USART1_RX 1 // 使能了接收// 映射Printf相关#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //?úê1ó?printfê±?μí3×??ˉì?ó?′?oˉêy&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125;// 简单延时函数void Delay(u32 count)&#123; static u32 i=0; for(i = 0; i &lt; count; i++);&#125;// 延时1ms（不准确的延时）void Delay_ms(u32 ms)&#123; static u32 i = 0; for(i = 0; i &lt; ms; i++) &#123; Delay(4000); &#125;&#125;// Led IO初始化void Led_Init(void)&#123; // LED GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED2--&gt;PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 速度 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); // IO初始化 GPIO_SetBits(GPIOD, GPIO_Pin_2); // 设置电平PD.2&#125;// Led打开void Led_Open(void)&#123; GPIO_ResetBits(GPIOD,GPIO_Pin_2);&#125;// Led关闭void Led_Close(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_2);&#125;void Led_Test(void *pvParameters)&#123; while(1) &#123; Led_Open(); vTaskDelay( 100/portTICK_RATE_MS ); Led_Close(); vTaskDelay( 100/portTICK_RATE_MS ); &#125;&#125;//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125;void USART_Test1(void *pvParameters)&#123; while(1) &#123; printf("USART 1 hello world %04d\r\n", g_printf1_conter++); vTaskDelay( 500/portTICK_RATE_MS ); &#125;&#125;void USART_Test2(void *pvParameters)&#123; while(1) &#123; printf("USART 2 hello world %04d\r\n", g_printf2_conter++); vTaskDelay( 800/portTICK_RATE_MS ); &#125;&#125;void USART_Test3(void *pvParameters)&#123; while(1) &#123; printf("USART 3 hello world %04d\r\n", g_printf3_conter++); vTaskDelay( 1100/portTICK_RATE_MS ); &#125;&#125;#if EN_USART1_RX //如果使能了接收void USART1_IRQHandler(void)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 cChar; if(USART_GetITStatus (USART1,USART_IT_RXNE)!=RESET) &#123; cChar=USART_ReceiveData(USART1); xQueueSendToBackFromISR (g_xQueueRx, &amp;cChar, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); &#125;&#125;#endifvoid NVIC_Configuration(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_4); #if EN_USART1_RX //如果使能了接收 // 配置串口1中断向量 NVIC_InitStructure .NVIC_IRQChannel =USART1_IRQn ; NVIC_InitStructure .NVIC_IRQChannelPreemptionPriority =6; NVIC_InitStructure .NVIC_IRQChannelCmd =ENABLE ; NVIC_Init(&amp;NVIC_InitStructure );#endif&#125;void vPC_Communication_Task(void *pvParameters)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 rx=0; g_xQueueRx = xQueueCreate(20,sizeof(u8)); while(1) &#123; if(xQueueReceiveFromISR(g_xQueueRx, &amp;rx, &amp;xHigherPriorityTaskWoken)) &#123; printf("%c\r\n", rx); &#125; vTaskDelay(10/portTICK_RATE_MS ); &#125;&#125;/*-----------------------------------------------------------*/static void prvSetupHardware( void )&#123; SystemInit(); NVIC_Configuration(); Led_Init(); USART1_init(115200);&#125;/************************************************************/// 主函数/************************************************************/int main(void)&#123; // 初始化硬件平台 prvSetupHardware(); printf("hello world\r\n"); Delay_ms(1000); /* 建立任务 */ xTaskCreate( Led_Test, "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+3, NULL ); xTaskCreate( USART_Test1, "UART1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test2, "UART2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test3, "UART3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( vPC_Communication_Task, "UART_RECV", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); /* 启动OS */ vTaskStartScheduler();&#125;]]></content>
      <categories>
        <category>STM32</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo新建文章]]></title>
    <url>%2F2019%2F05%2F31%2FHexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo server 本地测试，访问http://localhost:4000 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 将文章收缩显示1&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装及关联账户]]></title>
    <url>%2F2019%2F05%2F31%2FGit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%B3%E8%81%94%E8%B4%A6%E6%88%B7%2F</url>
    <content type="text"><![CDATA[安装git 下载git，地址 安装git，默认安装 创建公钥，关联git 安装git后，右键会多出“Git GUI Here”“Git Bash Here”，选择“Git Bash Here”，弹出窗口 执行： cd ~/.ssh 如果返回“… No such file or directory”，说明没有生成过SSH Key，直接进入第4步。否则进入第3步备份! 备份： mkdir key_backup mv id_isa* key_backup 生成新的Key：（引号内的内容替换为你自己的邮箱） ssh-keygen -t rsa -C “your_email@youremail.com“ 输出显示： Generating public/private rsa key pair. Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa): 直接回车，不要修改默认路劲。 Enter passphrase (empty for no passphrase):Enter same passphrase again: 设置一个密码短语，在每次远程操作之前会要求输入密码短语！闲麻烦可以直接回车，不设置。 成功： Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.The key fingerprint is:… … 提交公钥： 6.1 找到.ssh文件夹，用文本编辑器打开“id_rsa.pub”文件，复制内容到剪贴板。 6.2 打开 https://github.com/settings/ssh ，点击 Add SSH Key 按钮，粘贴进去保存即可。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2019%2F05%2F06%2Farticle-title%2F</url>
    <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <tags>
        <tag>Cmd Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[STM32 Can id过滤]]></title>
    <url>%2F2019%2F04%2F08%2FSTM32%20Can%20id%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728CAN_FilterInitTypeDef CAN_FilterInitStructure; u32 slave_id = 0x1C1F1700; // 0b ‭0001 1100 0001 1111 0001 0111 0000 0000‬// 0b 0001 1111 1111 1111 1111 1111 0000 0000// slave_id &amp;lt;&amp;lt; 3 0b ‭1110 0000 1111 1000 1011 1000 0000 0‬000// 0b 1111 1111 1111 1111 1111 1000 0000 0*** /* CAN 过滤器组初始化 */CAN_FilterInit(&amp;amp;CAN_FilterInitStructure); //初始化CAN_FilterInitStructrue结构体变量CAN_FilterInitStructure.CAN_FilterNumber = 0; //设置过滤器组0，范围为0~13CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask; //设置过滤器组0为屏蔽模式CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;//设置过滤器组0位宽为32位#if 0 // 不设置过滤CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000; //设置标识符寄存器高字节CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000; //设置标识符寄存器低字节CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000; //设置屏蔽寄存器高字节CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000; //设置屏蔽寄存器低字节#else//寄存器的设置CAN_FilterInitStructure.CAN_FilterIdHigh = ((slave_id &amp;lt;&amp;lt; 3) &amp;gt;&amp;gt; 16) &amp;amp;0xffff; // 设置标识符寄存器高字节CAN_FilterInitStructure.CAN_FilterIdLow = (u16)(slave_id &amp;lt;&amp;lt; 3) | CAN_ID_EXT;// 设置标识符寄存器低字节CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0xffff; //设置屏蔽寄存器高字节CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x8003; //设置屏蔽寄存器低字节#endifCAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;//过滤器关联邮箱0CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;//激活过滤器CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE); //使能CAN接收中断CAN_FilterInit(&amp;amp;CAN_FilterInitStructure); // 设置过滤器]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil设置]]></title>
    <url>%2F2019%2F03%2F04%2FKeil%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Keil设置下载程序后自动运行 设置字体颜色设置字体颜色主题参照https://blog.csdn.net/qq_20553613/article/details/79615293 设置Tab键设置Tab键参照https://blog.csdn.net/dianzilaoshu/article/details/72457276 中Keil部分]]></content>
      <categories>
        <category>Keil</category>
      </categories>
      <tags>
        <tag>Keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“魔术师地毯”类问题]]></title>
    <url>%2F2019%2F02%2F27%2F%E2%80%9C%E9%AD%94%E6%9C%AF%E5%B8%88%E5%9C%B0%E6%AF%AF%E2%80%9D%E7%B1%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[魔术师地毯里，蓝色三角形和红色三角形根本就不是相似三角形，蓝色直角边2:5，红色3:8，他们组成的大图形不是三角形，是四边形，上面长边往里凹，下面的往外凸]]></content>
  </entry>
  <entry>
    <title><![CDATA[STM32 APB1 APB2]]></title>
    <url>%2F2019%2F02%2F26%2FSTM32-APB1-APB2%2F</url>
    <content type="text"><![CDATA[STM32F103系列运行主频为72MHz 据参考手册有：APB1操作速度限于36MHz， APB2操作于全速(最高72MHz)。 APB2负责AD，I/O，高级TIM，串口1； APB1负责DA，USB，SPI，I2C，CAN，串口2345，普通TIM；]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vivado 2016.4 固化]]></title>
    <url>%2F2019%2F02%2F15%2FVivado-2016-4-%E5%9B%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. bit文件生成mcs文件在vivado2016版本之后，可以直接通过操作来生成mcs文件 2. 固化mcs文件]]></content>
      <categories>
        <category>Vivado</category>
      </categories>
      <tags>
        <tag>Vivado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 异或和校验]]></title>
    <url>%2F2019%2F02%2F14%2FC%20%E5%BC%82%E6%88%96%E5%92%8C%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617//异或校验运算/** const unsigned char *buf 需要运算的buf数组* int id_end 需要运算的buf结尾位置* int id_start = 0 需要预算的buf开始位置，默认为0*/int xor16(const unsigned char *buf, int id_end, int id_start = 0)&#123; int check_buf = 0; int i; for (i = id_start; i &amp;lt; id_end; i++) &#123; check_buf ^= (int)buf[i]; &#125; return check_buf;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SN]]></title>
    <url>%2F2018%2F12%2F12%2FSN%2F</url>
    <content type="text"><![CDATA[DDSM3617 6.1.7 DEZTW73LF1S9D DDSM918+ 6.2.1 DXVTDO4IGF8S5]]></content>
  </entry>
  <entry>
    <title><![CDATA[U盘芯片信息]]></title>
    <url>%2F2018%2F12%2F08%2FU%E7%9B%98%E8%8A%AF%E7%89%87%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[闪迪 酷豆 8G 芯片信息 逻辑盘符 : H:\ 此分区容量: 7.4G设备ID : VID = 0781 PID = 5571设备序列号: 4C530001060105112245设备版本 : 1.00 设备制造商: SanDisk设备型号 : Cruzer Fit当前协议 : USB2.0(连接到USB3端口可以获得更高性能)输入电流 : 224mA 分区系统 : FAT32 是否激活 : 否是否对齐 : 1024 KB 已扇区对齐 网络异常,查询主控信息失败! 系统版本 : Windows 8 Personal 金士顿16G逻辑盘符 : H:\ 此分区容量: 14.4G设备ID : VID = 0930 PID = 6545设备序列号: C86000BDB93EB0907A20EBA6设备版本 : PMAP 设备制造商: Kingston设备型号 : DataTraveler 2.0当前协议 : USB2.0输入电流 : 300mA 分区系统 : FAT32 是否激活 : 是是否对齐 : 128 KB 已扇区对齐 芯片制造商: 群联(Phison)芯片型号 : PS2251-68闪存颗粒 : 东芝(Toshiba) (打开网络可以获取详细信息)固件版本 : 02.02.55 固件日期: 2015.06.12 工具下载 : http://www.upan.cc/tools/mass/Phison/系统版本 : Windows 8 Personal]]></content>
  </entry>
  <entry>
    <title><![CDATA[外网SMB端口映射]]></title>
    <url>%2F2018%2F11%2F28%2F%E5%A4%96%E7%BD%91SMB%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[开启端口映射，从外网访问内网的文件共享：SMB 已经在路由器里开了远端WEB管理设了端口，另外端口映射局域网里的一台电脑，比如WEB端口设的是8080，映射192.168.1.100到4877端口，现在我想访问局域网的共享文件，怎么弄？以前我的做法是远程控制软件比如teamviewer或者radmin控制内网一台电脑后再通过其访问内网，缺点是要装软件，有办法直接通过网关访问内网共享文件夹吗？ Samba服务所使用的端口和协议： Port 137 (UDP) – NetBIOS 名字服务 ； nmbd Port 138 (UDP) – NetBIOS 数据报服务 Port 139 (TCP) – 文件和打印共享 ； smbd （基于SMB(Server Message Block)协议，主要在局域网中使用，文件共享协议） Port 389 (TCP) – 用于 LDAP (Active Directory Mode) Port 445 (TCP) – NetBIOS服务在windos 2000及以后版本使用此端口, (Common Internet File System，CIFS，它是SMB协议扩展到Internet后，实现Internet文件共享) Port 901 (TCP) – 用于 SWAT，用于网页管理Samba 以下为原理：WinXP共享需要137、138、139，445 137端口这个端口是用来请求NetBios名到IP地址达。比如有人喊“123计算机您共享C盘下的ABC.doc这个文件的IP地址是多少”。于是这个呐喊被广播，只有IP地址是123的回答了。 138端口这个端口是您浏览[网络邻居]用达。您网络里有台计算机叫主浏览器计算机维护着共享列表。所以这个端口封了也就不能通过[网络邻居]来查看其他计算机喽。当然并不防碍彼此通信。 139、445端口通信计算机得到了对方的IP地址以后，就用139或者445端口开始通讯了。如果不是域环境，就是SMB调用139端口通讯。如果是域环境，就是CIFS调用445端口通讯。如果您不想别人访问您的文件呢，就把这两个关闭掉。 这样做只能从外网访问内网中的一台机器共享，因为路由器的对外IP是唯一的。若要访问更多内网共享，只能建FTP，或者VPN之类的，但这种方法是最简单的，不需要在共享机器上有额外的软件设置，只需要路由器设置好即可！！！]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有道云笔记：登陆错误]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%99%BB%E9%99%86%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[错误提醒：请检查IE浏览器是否设置了“阻断所有Cookie”？…… 打开“Internet属性”-&gt;“安全”-&gt;“Internet”-&gt;“该区域的安全级别”：由高改为中高]]></content>
      <tags>
        <tag>有道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 开启多用户远程登陆（远程桌面）]]></title>
    <url>%2F2018%2F11%2F21%2FWin10-%E5%BC%80%E5%90%AF%E5%A4%9A%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Win10 开启多用户远程登陆（远程桌面）系统Win10专业版，已激活 1. 添加用户桌面“此电脑”-&gt;右键“管理” 计算器管理-&gt;本地用户和组-&gt;用户 “用户”-&gt;右键“新用户”填写用户名，密码。去除“用户下次登陆更改密码”，勾选“密码永不过期” 2. 添加远程桌面用户桌面“此电脑”-&gt;右键“属性”-&gt;“远程设置” “系统属性”-&gt;“远程”“远程桌面”-&gt;选择“允许远程连接到此计算机”-&gt;点击“选择用户” “远程桌面用户” 3. 编辑本地组策略win10 左下角搜索栏中 输入 gpedit 打开本地组策略编辑器 选择【计算器配置】-&gt;【管理模板】-&gt;【Windows组件】-&gt;【远程桌面服务】-&gt;【远程桌面会话主机】-&gt;【连接】 限制连接的数量配置 【限制连接的数量】，允许的RD最大连接数 即为最大的连接数量 将远程桌面服务用户限制到单独的远程桌面服务会话配置【将远程桌面服务用户限制到单独的远程桌面服务会话】，改成 “已禁用”/“已启用”“已禁用”：代表一个用户可以多次同时登陆桌面“已启用”：代表一个用户同时只能登陆一个桌面 4. 解除Win10对连接数量限制使用工具 rdpwrap，项目地址，下载页面下载后运行“install.bat”，然后运行“RDPConf.exe”。如果全绿则破解成功；如果出现“Listening [not supported]”则还需运行update.bat]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库下载]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[请输入密码. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>文库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++列出当前路径下所有文件名及子文件夹内文件名]]></title>
    <url>%2F2018%2F11%2F14%2FC-C-%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D%E5%8F%8A%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E6%96%87%E4%BB%B6%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在Win10下，使用VS2015测试可用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;io.h&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt; #include &lt;direct.h&gt; // getcwd();#include &lt;conio.h&gt; // getch(); using namespace std; //获取所有的文件名void GetAllFiles(string path, vector&lt;string&gt;&amp; files)&#123; //printf("\033[1A"); //先回到上一行 //printf("\033[K"); //清除该行 cout &lt;&lt; path &lt;&lt; endl; // 打印当前检索路径 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string p; if ((hFile = _findfirst(p.assign(path).append("\\*").c_str(), &amp;fileinfo)) != -1) &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); GetAllFiles(p.assign(path).append("\\").append(fileinfo.name), files); &#125; &#125; else &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125; &#125; //获取特定格式的文件名void GetAllFormatFiles(string path, vector&lt;string&gt;&amp; files, string format)&#123; //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; // string p; if ((hFile = _findfirst(p.assign(path).append("\\*" + format).c_str(), &amp;fileinfo)) != -1) &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) &#123; //files.push_back(p.assign(path).append("\\").append(fileinfo.name) ); GetAllFormatFiles(p.assign(path).append("\\").append(fileinfo.name), files, format); &#125; &#125; else &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125;&#125; // 该函数有两个参数，第一个为路径字符串(string类型，最好为绝对路径)；// 第二个参数为文件夹与文件名称存储变量(vector类型,引用传递)。// 在主函数中调用格式(并将结果保存在文件"AllFiles.txt"中，第一行为总数)： int main()&#123; /****************************** 获取当前工作路径 *******************************/ char *cCurrentWorkingPath; cCurrentWorkingPath = _getcwd(NULL, 0); if (cCurrentWorkingPath == NULL) &#123; cout &lt;&lt; "getcwd error" &lt;&lt; endl; return 1; &#125; cout &lt;&lt; "Current Working Path:(\"" &lt;&lt; cCurrentWorkingPath &lt;&lt; "\")" &lt;&lt; endl; cout &lt;&lt; "Press any key to start searching" &lt;&lt; endl &lt;&lt; endl; int flag = _getch(); //_getch(); /****************************** 检索文件 *******************************/ string sCurrentWorkingPath = cCurrentWorkingPath; vector&lt;string&gt; fileName; // string容器，用于存放文件名（绝对路径） char * distAll = "outAllFileName.txt"; cout &lt;&lt; "Retrieving folder:" &lt;&lt; endl; //读取所有的文件，包括子文件夹的文件 GetAllFiles(sCurrentWorkingPath, fileName); //读取所有格式为jpg的文件 //string format = ".jpg"; //GetAllFormatFiles(sCurrentWorkingPath, fileName, format); int size = fileName.size(); cout &lt;&lt; "A total of "&lt;&lt; size &lt;&lt;" files/folders were retrieved"&lt;&lt; endl; /****************************** 输出文件名 *******************************/ cout &lt;&lt; "1. Print all file names to the screen and save to file" &lt;&lt; endl; cout &lt;&lt; "2. Print all file names to the screen" &lt;&lt; endl; cout &lt;&lt; "3. Save all file names to the file" &lt;&lt; endl; cout &lt;&lt; "Please enter the serial number:" &lt;&lt; endl; flag = _getch(); //_getch(); ofstream ofn(distAll); switch (flag) &#123; case '1': ofn &lt;&lt; size &lt;&lt; endl; for (int i = 0; i&lt;size; i++) &#123; ofn &lt;&lt; fileName[i] &lt;&lt; endl; cout &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; case '2': for (int i = 0; i&lt;size; i++) &#123; cout &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; case '3': cout &lt;&lt; "Writting......" &lt;&lt; endl; ofn &lt;&lt; size &lt;&lt; endl; for (int i = 0; i&lt;size; i++) &#123; ofn &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; default: break; &#125; ofn.close(); free(cCurrentWorkingPath); /****************************** 结束 *******************************/ cout &lt;&lt; "Press any key to end" &lt;&lt; endl; //getchar(); _getch(); return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS设置静态编译]]></title>
    <url>%2F2018%2F11%2F02%2FVS%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[代码有时依赖一些特殊的库，为保证运行，设置为“静态编译”，直接将所需要的系统动态库包含到exe文件中，这样在新电脑上就不会存在缺少动态库问题。设置方法：“项目-&gt;属性-&gt;配置属性-&gt;常规-&gt;MFC的使用：在静态库中使用MFC”]]></content>
      <categories>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宝塔环境下，设置OneIndex伪静态]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%AE%9D%E5%A1%94%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E8%AE%BE%E7%BD%AEOneIndex%E4%BC%AA%E9%9D%99%E6%80%81%2F</url>
    <content type="text"><![CDATA[123456789if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break;&#125;if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php;&#125;if (!-f $request_filename)&#123; rewrite (.*) /index.php;&#125;]]></content>
      <categories>
        <category>宝塔</category>
      </categories>
      <tags>
        <tag>宝塔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OneDrive]]></title>
    <url>%2F2018%2F10%2F26%2FOneDrive%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX1/LYp8CbMIx6ncSznQY8y1U/kwlfs155hrOMy/2/S0hTpMWNXVYiK+otWB91hmjaBA8MSgszVCUWkKsS62c+nLrOlEfKhzXyenZNrVLMPFGeQxgS7her2QwkvO2Ya/CpFJhmCjeJ2BgX+W40VLHiU1FsJIg7AFIew73b4HRdObcT1ORbwcaVfRhxs1sWMeiKCJiNY559zRgO7Nw8APnqlbUvuoRVsUD6ASP7jZLui7bzzPy1zGQ3DP9ymD1UcLFdDoEoeDiAIvdyqf91/R5wqspOdrK8MLQUT1uTWmEcX4ZcGN92rHXrBoHbiJ2CJjAYedxr2zZWNnQdpGTSwno7ViGZDsu+wsLFSPeWDH8Wb1nvnwOD7OY7sRgsBzDyIVCVbSi0gPGfHLIaoDbbgZmt8MjJq3uaCl+bfFK+swh7jVDRQxK9Erti1q9bnxvvL7CDy6UqO9LU7dpMrjhz1kxK9/EVTGvaEV5JQjbwlw87oMZaqbFFZsnYoemGzLGRI6gxuGXvb67ObEP5LpFBJeKOuHEqI/dJAa9T4pn+Ipfz92LVmhrAp6ebBnGy/nqRWPepzLls7dLsDNJPazCFVZhxRC8jymmyj9gzTE79ePab5e1y97JiGnqevF/tk8AK73bFCdwJuB7Deop1Q==]]></content>
      <categories>
        <category>OneDrive</category>
      </categories>
      <tags>
        <tag>OneDrive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1024]]></title>
    <url>%2F2018%2F10%2F24%2F1024%2F</url>
    <content type="text"><![CDATA[1024]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录站点运行时间html]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%AE%B0%E5%BD%95%E7%AB%99%E7%82%B9%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4html%2F</url>
    <content type="text"><![CDATA[记录站点运行时间html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;显示XX年XX天XX时XX秒，秒数显示为一秒一秒的走动&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!----&gt; &lt;br /&gt; 网站稳定运行： &lt;span id="htmer_time" style="color: crimson;"&gt;&lt;/span&gt; &lt;!--JavaScript部分--&gt; &lt;script&gt; function secondToDate(second)&#123; if(!second) &#123;return 0;&#125; var time = new Array(0, 0, 0, 0, 0); if(second &gt;= 365 * 24 * 3600) &#123; time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; &#125; if(second &gt;= 24 * 3600) &#123; time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; &#125; if(second &gt;= 3600) &#123; time[2] = parseInt(second / 3600); second %= 3600; &#125; if(second &gt;= 60) &#123; time[3] = parseInt(second / 60); second %= 60; &#125; if(second &gt; 0) &#123; time[4] = second; &#125; return time; &#125; &lt;/script&gt; &lt;script type="text/javascript" language="javascript"&gt; function setTime() &#123; var create_time = Math.round(new Date(Date.UTC(2018, 4, 10, 00, 00, 00)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = currentTime[0] + '年' + currentTime[1] + '天' + currentTime[2] + '时' + currentTime[3] + '分' + currentTime[4] + '秒'; document.getElementById("htmer_time").innerHTML = currentTimeHtml; &#125; setInterval(setTime, 1000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>站点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt关闭按钮事件closeEvent]]></title>
    <url>%2F2018%2F09%2F26%2FQt%E5%85%B3%E9%97%AD%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6closeEvent%2F</url>
    <content type="text"><![CDATA[在对应头文件中包含QCloseEvent12#include &lt;QMessageBox&gt;#include &lt;QCloseEvent&gt; 在对应头文件对应类中添加 123protected: //这是一个虚函数，继承自QEvent.只要重写了这个虚函数，当你按下窗口右上角的"×"时，就会调用你所重写的此函数. void closeEvent(QCloseEvent*event); 在对应.cpp文件中添加 123456789101112131415161718void Widget::closeEvent(QCloseEvent* event)&#123; //跳出信息框，你是否要关闭. auto temp = QMessageBox::information(this, "Warning", tr("你是否要关闭?"), QMessageBox::Yes | QMessageBox::No); if (temp == QMessageBox::Yes) &#123; // 接受了 要关闭这个窗口的事件. accept和ignore只是作为一个标志. event-&gt;accept(); &#125; else &#123; //忽略了 要关闭这个窗口的事件.当前窗口就不会被关闭. event-&gt;ignore(); &#125;&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt QSettings 配置文件]]></title>
    <url>%2F2018%2F09%2F21%2FQt-QSettings-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637QSettings *m_config; // 配置文件名，若文件不存在则会自动创建; 文件格式：*.ini格式的配置文件m_config = new QSettings("Config.ini",QSettings::IniFormat); // 进入节点：若节点存在则进入；若不存在则创建后进入 （与endGroup配套使用）m_config-&gt;beginGroup("com1"); //可以理解为进入到 节 com1 m_config-&gt;setValue("baud1","115200"); // 设置键值，若键已存在则修改值；若键不存在则创建键后设置值 if(!m_config-&gt;childKeys().contains("baud"))//判断节com1中是否存在键 baud&#123; m_config-&gt;setValue("baud","9600"); //若不存在则创建并赋值为9600&#125;else&#123; QString baud = m_config-&gt;value("baud").toString(); //存在则取出键baud的值 qDebug()&lt;&lt; "---com1 baud = " &lt;&lt; baud;&#125;m_config-&gt;endGroup(); //beginGroup后必须endGroup ，可以理解为退出com1 m_config-&gt;setValue("com2/baud",38400); //直接设置节com2下键baud的值：如果不存在节com2或键baud则创建qDebug()&lt;&lt;"***com2 baud = "+m_config-&gt;value("com2/baud").toString(); if(!m_config-&gt;contains("com5/baud")) // 判断是否存在&#123; m_config-&gt;setValue("com5/baud",19200); //不存在则创建则赋初值&#125;else&#123; int baud = m_config-&gt;value("com5/baud").toInt();&#125; if(!m_config-&gt;contains("com8")) //判断节com8是否存在 但不会创**************&#123; &#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ GPIO（EMIO）中断]]></title>
    <url>%2F2018%2F09%2F20%2FZYNQ-GPIO%EF%BC%88EMIO%EF%BC%89%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[PL侧PL侧GPIO设置 EMIO0设置为输入（PS侧读EMIO0状态高/低） EMIO1设置为输出（PS侧写EMIO1为高/低） 连接EMIO0、EMIO1 EMIO[63:32]中存放中断响应时间，供PS侧读取 流程 PS侧写EMIO1值为1，使EMIO0值更新为1 EMIO0由0à1，触发PS侧中断（PS侧在进入中断后，会将EMIO1重新写为0，EMIO0也随之变为0） EMIO[63:32]中存放EMIO0高电平持续时间（拍数，时钟100MHz），及从中断产生到中断响应的时间 PS侧PS侧GPIO设置 EMIO0（GPIO54）设置为输入 EMIO1（GPIO55）设置为输出 EMIO[63:32]设置为输入 配置EMIO0相关中断设置 主函数中，每隔5s将EMIO1值写1（在PL侧，EMIO1变为1后，会关联EMIO0也变为1） EMIO0变为1，触发中断，进入中断服务函数 在中断服务函数中，将EMIO1写为0（PL侧，EMIO0也随之变为0，并统计中断响应时间，将时间存放在EMIO[63:32]中） 读取EMIO[63:32]，获取中断响应时间 PS侧C代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371/******************************************************************************** Copyright (C) 2009 - 2014 Xilinx, Inc. All rights reserved.** Permission is hereby granted, free of charge, to any person obtaining a copy* of this software and associated documentation files (the "Software"), to deal* in the Software without restriction, including without limitation the rights* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the Software is* furnished to do so, subject to the following conditions:** The above copyright notice and this permission notice shall be included in* all copies or substantial portions of the Software.** Use of the Software is limited solely to applications:* (a) running on a Xilinx device, or* (b) that interact with a Xilinx device through a bus or interconnect.** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL* XILINX BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE* SOFTWARE.** Except as contained in this notice, the name of the Xilinx shall not be used* in advertising or otherwise to promote the sale, use or other dealings in* this Software without prior written authorization from Xilinx.*******************************************************************************/ /* * helloworld.c: simple test application * * This application configures UART 16550 to baud rate 9600. * PS7 UART (Zynq) is not initialized by this application, since * bootrom/bsp configures it to baud rate 115200 * * ------------------------------------------------ * | UART TYPE BAUD RATE | * ------------------------------------------------ * uartns550 9600 * uartlite Configurable only in HW design * ps7_uart 115200 (configured by bootrom/bsp) */ #include &lt;stdio.h&gt;#include "platform.h"#include "xil_printf.h"#include "xparameters.h"#include "xgpiops.h"#include "xscugic.h"#include "xil_exception.h"#include "xplatform_info.h"#include &lt;xil_printf.h&gt;#include "sleep.h" /************************** Constant Definitions *****************************//* * The following constants map to the names of the hardware instances that * were created in the EDK XPS system. They are defined here such that * the user can easily change all the needed device IDs in one place. */#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID // 0#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID // 0U#define GPIO_INTERRUPT_ID XPAR_XGPIOPS_0_INTR // 52U /************************** Function Prototypes ******************************/ static int GpioIntrExample(XScuGic *Intc, XGpioPs *Gpio, u16 DeviceId,u16 GpioIntrId);static void IntrHandler(void *CallBackRef, u32 Bank, u32 Status);static int SetupInterruptSystem(XScuGic *Intc, XGpioPs *Gpio, u16 GpioIntrId); /************************** Variable Definitions *****************************/ /* * The following are declared globally so they are zeroed and so they are * easily accessible from a debugger. */static XGpioPs g_Gpio; /* The Instance of the GPIO Driver */ static XScuGic g_Intc; /* The Instance of the Interrupt Controller Driver */ static u32 g_Input_Pin; /* Switch button */static u32 g_Output_Pin; /* LED button */ int main()&#123; int Status; u32 WriteValue = 0; u32 ReadValue = 0; init_platform(); print("******** Hello World ********\n\r"); /* * Run the GPIO interrupt example, specify the parameters that * are generated in xparameters.h. */ Status = GpioIntrExample(&amp;g_Intc, &amp;g_Gpio, GPIO_DEVICE_ID, GPIO_INTERRUPT_ID); if (Status != XST_SUCCESS) &#123; xil_printf("GPIO Interrupt Example Test Failed\r\n"); return XST_FAILURE; &#125; xil_printf("Successfully ran GPIO Interrupt Example Test\r\n"); while(1) &#123;#if 0 WriteValue = 0; XGpioPs_WritePin(&amp;g_Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(&amp;g_Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5); WriteValue = 1; XGpioPs_WritePin(&amp;g_Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(&amp;g_Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5);#else WriteValue = 1; XGpioPs_WritePin(&amp;g_Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(&amp;g_Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5);#endif &#125; cleanup_platform(); return 0;&#125; /****************************************************************************//*** This function shows the usage of interrupt fucntionality of the GPIO device.* It is responsible for initializing the GPIO device, setting up interrupts and* providing a foreground loop such that interrupts can occur in the background.** @param Intc is a pointer to the XScuGic driver Instance.* @param Gpio is a pointer to the XGpioPs driver Instance.* @param DeviceId is the XPAR_&lt;Gpio_Instance&gt;_PS_DEVICE_ID value* from xparameters.h.* @param GpioIntrId is XPAR_&lt;GIC&gt;_&lt;GPIO_Instance&gt;_VEC_ID value* from xparameters.h** @return* - XST_SUCCESS if the example has completed successfully.* - XST_FAILURE if the example has failed.** @note None******************************************************************************/int GpioIntrExample(XScuGic *Intc, XGpioPs *Gpio, u16 DeviceId, u16 GpioIntrId)&#123; XGpioPs_Config *ConfigPtr; int Status; //u32 WriteValue = 0; //u32 ReadValue = 0; g_Input_Pin = 0 + 54; g_Output_Pin = 1 + 54; /* Initialize the Gpio driver. */ ConfigPtr = XGpioPs_LookupConfig(DeviceId); if (ConfigPtr == NULL) &#123; return XST_FAILURE; &#125; XGpioPs_CfgInitialize(Gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr); print("GPIO initial complete\n\r"); /* Run a self-test on the GPIO device. */ Status = XGpioPs_SelfTest(Gpio); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* Set the direction for the specified pin to be input */ XGpioPs_SetDirectionPin(Gpio, g_Input_Pin, 0x0); /* Set the direction for the specified pin to be output. */ XGpioPs_SetDirectionPin(Gpio, g_Output_Pin, 1); XGpioPs_SetOutputEnablePin(Gpio, g_Output_Pin, 1); XGpioPs_WritePin(Gpio, g_Output_Pin, 0x0); XGpioPs_SetDirection(Gpio, 3, 0x00000000); /* * Setup the interrupts such that interrupt processing can occur. If * an error occurs then exit. */ Status = SetupInterruptSystem(Intc, Gpio, GPIO_INTERRUPT_ID); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* * Loop forever while the button changes are handled by the interrupt * level processing. */ /*while(1) &#123; WriteValue = 0; XGpioPs_WritePin(Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5); WriteValue = 1; XGpioPs_WritePin(Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5); &#125;*/ return XST_SUCCESS;&#125; /*****************************************************************************//**** This function sets up the interrupt system for the example. It enables falling* edge interrupts for all the pins of bank 0 in the GPIO device.** @param GicInstancePtr is a pointer to the XScuGic driver Instance.* @param GpioInstancePtr contains a pointer to the instance of the GPIO* component which is going to be connected to the interrupt* controller.* @param GpioIntrId is the interrupt Id and is typically* XPAR_&lt;GICPS&gt;_&lt;GPIOPS_instance&gt;_VEC_ID value from* xparameters.h.** @return XST_SUCCESS if successful, otherwise XST_FAILURE.** @note None.*****************************************************************************/static int SetupInterruptSystem(XScuGic *GicInstancePtr, XGpioPs *Gpio, u16 GpioIntrId)&#123; int Status; XScuGic_Config *IntcConfig; /* Instance of the interrupt controller */ Xil_ExceptionInit(); /* * Initialize the interrupt controller driver so that it is ready to * use. */ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); if (NULL == IntcConfig) &#123; return XST_FAILURE; &#125; Status = XScuGic_CfgInitialize(GicInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* * Connect the interrupt controller interrupt handler to the hardware * interrupt handling logic in the processor. */ Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, GicInstancePtr); #if 0 // 关联中断服务函数 ：一次跳变沿，会造成2次进中断服务函数，原因未知 /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ Status = XScuGic_Connect(GicInstancePtr, GpioIntrId, (Xil_ExceptionHandler)XGpioPs_IntrHandler, (void *)Gpio); if (Status != XST_SUCCESS) &#123; return Status; &#125; /* Set the handler for gpio interrupts. 设置gpio中断的处理程序 */ XGpioPs_SetCallbackHandler(Gpio, (void *)Gpio, IntrHandler);#else // 关联中断服务函数 ：一次跳变沿，进1次中断服务函数 /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ Status = XScuGic_Connect(GicInstancePtr, GpioIntrId, (Xil_ExceptionHandler)IntrHandler, (void *)Gpio); if (Status != XST_SUCCESS) &#123; return Status; &#125;#endif /* Enable falling edge interrupts for all the pins in bank 2. 设置中断类型，沿/电平、上升下降、高低*/ XGpioPs_SetIntrType(Gpio, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000); //XGpioPs_SetIntrType(Gpio, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); //XGpioPs_SetIntrType(Gpio, 2, 0xFFFFFFFF, 0x00000000, 0x00000000); /* Enable the GPIO interrupts of Bank 2. 启用Bank2的GPIO中断 */ //XGpioPs_IntrEnable(Gpio, 2, 1); XGpioPs_IntrEnable(Gpio, 2, 0xFFFFFFFF); /* Enable the interrupt for the GPIO device. 为GPIO设备启用中断 */ XScuGic_Enable(GicInstancePtr, GpioIntrId); /* Enable interrupts in the Processor. 在处理器中启用中断 */ Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ); return XST_SUCCESS;&#125; /****************************************************************************//*** This function is the user layer callback function for the bank 0 interrupts of* the GPIO device. It checks if all the switches have been pressed to stop the* interrupt processing and exit from the example.** @param CallBackRef is a pointer to the upper layer callback reference.* @param Status is the Interrupt status of the GPIO bank.** @return None.** @note None.*******************************************************************************/static void IntrHandler(void *CallBackRef, u32 Bank, u32 Status)&#123; XGpioPs *Gpio = (XGpioPs *)CallBackRef; u32 WriteValue = 0; u32 ReadValue = 0; // Disable GPIO interrupts XGpioPs_IntrDisablePin(Gpio, g_Input_Pin); usleep(1); XGpioPs_WritePin(Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(Gpio, g_Input_Pin); printf("IntrHandler ____ WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); ReadValue = XGpioPs_Read(Gpio, 3); printf("IntrHandler ____ Read Bank3 Value : %ld \r\n", ReadValue); // Acknowledge GPIO interrupts XGpioPs_IntrClearPin(Gpio, g_Input_Pin); // Enable GPIO interrupts XGpioPs_IntrEnablePin(Gpio, g_Input_Pin);&#125;]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad++设置]]></title>
    <url>%2F2018%2F09%2F07%2Fnotepad-%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[将tab键设置为4个空格 设置–&gt;首选项–&gt;语言–&gt;制表符设置–&gt;(勾选上)替换为空格注：这样使用Tab键时，等同于使用了4个空格（不再是制表符） 显示空格及制表符视图–&gt;显示符号–&gt;(勾选上)显示空格及制表符制表符(tab)显示为：“—&gt;”空格显示为：“.” 显示缩进参考线视图–&gt;显示符号–&gt;(勾选上)显示缩进参考线 显示边界线（80字符标志）设置—首选项—编辑—勾选“显示列边界”]]></content>
      <categories>
        <category>Notepad++</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows driver kits 7600]]></title>
    <url>%2F2018%2F09%2F05%2Fwindows-driver-kits-7600%2F</url>
    <content type="text"><![CDATA[下载地址:https://download.microsoft.com/download/4/A/2/4A25C7D5-EFBE-4182-B6A9-AE6850409A78/GRMWDK_EN_7600_1.ISO 1. 安装默认安装 2. 使用工具WDK（windows driver kits）编译（仅仅编译已经写好的驱动工程文件）2.1 在开始菜单中找到WDK 2.2 要编译不同的系统的驱动，选择对应的文件夹打开（比如说win server 2008就选择“Windows Vista and Windows Server 2008”），然后打开“x64 Checked Build Environment” 2.3 打开“x64 Checked Build Environment”后，会弹出如下窗口 2.4 使用命令跳转到驱动工程所在的文件夹内 2.5 使用命令build 编译工程。 2.6 编译成功后，到工程文件夹下，会出现一个新的文件夹。（编译不同系统的驱动，文件夹名称不同） 2.7 objchk_wlh_amd64文件夹内的amd64文件夹内，就有我们新编译的驱动文件PcieDrvX64.sys]]></content>
      <categories>
        <category>windows driver</category>
      </categories>
      <tags>
        <tag>windows driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt,… 格式化I/O输出]]></title>
    <url>%2F2018%2F09%2F05%2Ffmt-%E2%80%A6-%E6%A0%BC%E5%BC%8F%E5%8C%96I-O%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718#ifndef __MAIN_H__#define __MAIN_H__ #include "drivers/mss_uart/mss_uart.h"#include &lt;stdio.h&gt; char g_buf[64];int g_buf_len;#define uart0_printf(fmt,...) &#123; \sprintf(g_buf, fmt, ##__VA_ARGS__);\for(g_buf_len = 0; g_buf_len &lt; 64; g_buf_len++)\&#123;\ if(g_buf[g_buf_len] == '#')\ break;\&#125;\MSS_UART_polled_tx(gp_my_uart, (const uint8_t*)g_buf, g_buf_len-1);&#125; #endif /* __MAIN_H__ */]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xilinx Jtag 驱动问题]]></title>
    <url>%2F2018%2F08%2F30%2FXilinx-Jtag-%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Win10 64位系统，原先由Vivado 2016.4，又安装Vivado18.1后，Jtag识别异常 第一次连接USB-JTAG下载器时，在设备管理器指定驱动程序位置：C:\Xilinx\Vivado\2017.4\data\xicom\cable_drivers\nt64后，显示驱动安装成功，出现如下现象； 现象：下载器上的连接指示灯不亮，但系统设备列表里显示USB连接设备正常，名称为：xilinx embedded platform. usb firmware loader，vivado识别不到JTAG设备 解决方法： 安装Jungo驱动：找到低版本vivado安装后文件夹，如C:\Xilinx_16.4\Vivado\2016.4\data\xicom\cable_drivers\nt64\：管理员运行install_drivers_wrapper.bat，安装完成后设备管理器中出现Jungo–WinDriver设备； 插入Cable插入Cable后，在设备管理器中选中xilinx embedded platform. usb firmware loader设备，右击“卸载设备”，勾选“删除此设备的驱动程序软件”，删除之前驱动；某些机器会提示重启 重新拔插Usb Cable重新拔插Usb Cable，系统将自动识别设备并自动安装正确驱动，此时设备列表显示：Xilinx USB CableVivado可识别到JTAG设备。 参照：Xilinx Platform Cable USB下载器识别]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ设置程序运行位置]]></title>
    <url>%2F2018%2F08%2F21%2FZYNQ%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ZYNQ PS侧程序可选运行ddr,flash,及片内ram上 设置方法选中对应的SDK工程]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境Qt打包-linuxdeployqt]]></title>
    <url>%2F2018%2F08%2F21%2FLinux%E7%8E%AF%E5%A2%83Qt%E6%89%93%E5%8C%85-linuxdeployqt%2F</url>
    <content type="text"><![CDATA[使用linuxdeployqt工具，git项目地址：https://github.com/probonopd/linuxdeployqt 1. Qt环境确保设备已经安装了Qt环境 2. 设置qmake环境变量PATH1root@ubuntu:~# export PATH=/opt/Qt5.11.1/5.11.1/gcc_64/bin:$PATH 检查qmake环境变量设置情况 123root@ubuntu:~# qmake -vQMake version 3.1Using Qt version 5.11.1 in /opt/Qt5.11.1/5.11.1/gcc_64/lib 3. 下载linuxdeployqtlinuxdeployqt release版：https://github.com/probonopd/linuxdeployqt/releases 1wget https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage 将linuxdeployqt-continuous-x86_64.AppImage移动到/opt/linuxdeployqt-continuous-x86_64目录下 12mkdir /opt/linuxdeployqt-continuous-x86_64cp linuxdeployqt-continuous-x86_64.AppImage /opt/linuxdeployqt-continuous-x86_64/ 4.设置linuxdeployqt环境变量1root@ubuntu:~# export PATH=/opt/linuxdeployqt-continuous-x86_64/:$PATH 准备工作完成。 5. Qt工程生成Release版程序Qt工程生成Release版程序，将生成的二进制文件单独复制到一个路径，shell切换到二进制文件所在路径,执行如下命令（其中K7_PCIe2-DMA为生成的二进制文件） 1root@ubuntu:~/Desktop/K7_PCIe2-DMA# linuxdeployqt-continuous-x86_64.AppImage K7_PCIe2-DMA -appimage 参考：https://blog.csdn.net/enaldick12/article/details/63255934https://blog.csdn.net/zjx18915341085/article/details/79715075]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32 设置 A13、A14、B15、B3、B4为普通IO使用]]></title>
    <url>%2F2018%2F08%2F18%2FSTM32-%E8%AE%BE%E7%BD%AE-A13%E3%80%81A14%E3%80%81B15%E3%80%81B3%E3%80%81B4%E4%B8%BA%E6%99%AE%E9%80%9AIO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[STM32 的PA13、PA14、PA15、PB3、PB4主要是用来JTAG调试用的，于是在默认下是启动后为JTAG模式，但是对于不需要JTAG而需要充分利用GPIO口时，就需要将JTAG关闭，设置为GPIO模式。 与JTAG有关的为PA13、PA14、PA15、PB3、PB4 与SWD有关的为PA13、PA14 1234567891011// 使能对应管脚的时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //打开PA时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //打开PB时钟 // 这几个管脚的复位后功能不是IO口，而是JTAG口，需要复用为IORCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //打开复用时钟----重要 // 关掉JTAG功能，保留SW 即PB3、PB4、PA15设置为普通IO，PA13、PA14仍为调试管脚GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);//关掉JTAG，不关SW// 关掉SW 即PA13、PA14、PA15、PB3、PB4全部设置为普通IOGPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);//关掉SW 注： 关掉JTAG功能，保留SW后，将不再可以使用JTAG调试下载程序，只能通过SW进行下载调试 关掉SW功能后，将不再可以使用JTAG、SW功能调试下载程序 参考文章：STM32 关闭JTAG 使用相应GPIO口 简单记录stm32不小心把SWD和JTAG都给关了，程序下载不进去，解决办法]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构详解]]></title>
    <url>%2F2018%2F08%2F13%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[详解 /根目录。Linux文件系统的入口.也是最高一级的目录.包含了几乎所的文件目录。相当于中央系统。进入的最简单方法是： 1cd / /boot引导程序，内核等存放的目录。这个目录，包括了在引导过程中所必需的文件，引导程序的相关文件（例如grub，lilo以及相应的配置文件以及Linux操作系统内核相关文件（例如vmlinuz等一般都存放在这里。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候，虚拟文件系统还不存在，加载的内核虽然是从硬盘读取的，但是没经过Linux的虚拟文件系统，这是比较底层的东西来实现的。然后内核自己创建好虚拟文件系统，并且从虚拟文件系统的其他子目录中（例如/sbin 和 /etc加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如grub.conf来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数。 /sbin超级用户可以使用的命令的存放目录。存放大多涉及系统管理的命令（例如引导系统的init程序，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是时普通用户也可能会用到。这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin等目录是相似的，我们要记住，凡是目录sbin中包含的都是root权限才能执行的，这样就行了。后面会具体区分。 /bin普通用户可以使用的命令的存放目录。系统所需要的那些命令位于此目录，比如ls、cp、mkdir等命令；类似的目录还/usr/bin，/usr/local/bin等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。 /lib根目录下的所有程序的共享库目录。此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于Windows上面的system32目录。按理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还有/usr/lib，/usr/local/lib等等。 /dev设备文件目录。在Linux中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用mknod命令来创建，具体参见相应的命令；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个*.ko类型的二进制文件，在内核启动之后，再通过insmod等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要Linux系统支持某个设备，只要个东西：相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。 /home普通用户的家目录（$HOME目录）。在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都有自己的家目录，目录以用户名作为名字存放在/home下面（例如quietheart用户，其家目录的名字为/home/quietheart。该目录中保存了绝大多数的用户文件(用户自己的配置文件，定制文件，文档，数据等)，root用户除外（参见后面的/root目录。由于这个目录包含了用户实际的数据，通常系统管理员为这个目录单独挂载一个独立的磁盘分区，这样这个目录的文件系统格式就可能和其他目录不一样了（尽管表面上看，这个目录还是属于根目录的一棵子树上），有利于数据的维护。 /root用户root的$HOME目录系统管理员(就是root用户或超级用户)的主目录比较特殊，不存放在/home中，而是直接放在/root目录下了。 /etc全局的配置文件存放目录。系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在/etc目录中，所以想要配置什么东西的话，可以在/etc下面寻找我们可能需要修改的文件。一些大型套件，如X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所有程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc。另外，还有一个需要注意的常见现象就是，当某个程序在某个用户下运行的时候，可能会在该用户的家目录中生成一个配置文件（一般这个文件最开始就是/etc下相应配置文件的拷贝，存放相应于“当前用户”的配置，这样当前用户可以通过配置这个家目录的配置文件，来改变程序的行为，并且这个行为只是该用户特有的。原因就是：一般来说一个程序启动，如果需要读取一些配置文件的话，它会首先读取当前用户家目录的配置文件，如果存在就使用；如果不存在它就到/etc下读取全局的配置文件进而启动程序。就是这个配置文件不自动生成，我们手动在自己的家目录中创建一个文件的话，也有许多程序会首先读取到这个家目录的文件并且以它的配置作为启动的选项（例如我们可以在家目录中创建vim程序的配置文件.vimrc，来配置自己的vim程序。 /usr这个目录中包含了命令库文件和在通常操作中不会修改的文件。这个目录对于系统来说也是一个非常重要的目录，其地位类似Windows上面的”Program Files”目录（请原谅我可能这样做比较不太恰当^_^。安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行/usr/bin下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。 /usr/lib目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录，理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。 /usr/bin一般使用者使用并且不是系统自检等所必需可执行文件的目录。此目录相当于根文件系统下的对应目录（/bin），非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。 /usr/sbin管理员使用的非系统必须的可执行文件存放目录。此目录相当于根文件系统下的对应目录（/sbin），保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。 /usr/share存放共享文件的目录。在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据(例如程序文档信息)。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些类似数据。 /usr/includeC程序语言编译使用的头文件。linux下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。 /usr/local安装本地程序的一般默认路径。当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。例如，安装的程序可执行文件被安装（安装实质就是复制到了/usr/local/bin下面，此程序（可执行文件所需要依赖的库文件被安装到了/usr/local/lib目录下，被安装的软件如果是某个开发库（例如Qt，Gtk等那么相应的头文件可能就被安装到了/usr/local/include中等等。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。 /proc特殊文件目录。这个目录采用一种特殊的文件系统格式（proc格式，内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间(尽管命令ls -c会显示它们的大小)。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如： ├ 1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。├ cpuinfo 处理器信息，如类型、制造商、型号和性能。├ devices 当前运行的核心配置的设备驱动的列表。├ dma 显示当前使用的DMA通道。├ filesystems 核心配置的文件系统。├ interrupts 显示使用的中断，and how many of each there have been.├ ioports 当前使用的I/O端口。├ kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存；├ kmsg 核心输出的消息。也被送到syslog 。├ ksyms 核心符号表。├ loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。├ meminfo 存储器使用信息，包括物理内存和swap。├ modules 当前加载了哪些核心模块。├ net 网络协议状态信息。├ self 到查看/proc 的程序的进程目录的符号连接。├ stat 系统的不同状态├ uptime 系统启动的时间长度。└ version 核心版本。 /opt可选择的文件目录。这个目录表示的是可选择的意思，有些自定义软件包或者第三方工具，就可以安装在这里。比如在Fedora Core 5.0中，OpenOffice就是安装在这里。些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以把它们的安装路径设置成/opt这样来安装。这个目录的作用一点类似/usr/local。 /mnt临时挂载目录。 这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在/mnt目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧? /media挂载的媒体设备目录。挂载的媒体设备目录，一般外部设备挂载到这里，例如cdrom等。比如我们插入一个U盘，我们一般会发现，Linux自动在这个目录下建立一个disk目录，然后把U盘挂载到这个disk目录上，通过访问这个disk来访问U盘。 /var内容经常变化的目录。此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。 /tmp临时文件目录。该目录存放系统中的一些临时文件，文件可能会被系统自动清空。有的系统直接把tmpfs类型的文件系统挂载到这个目录上，tmpfs文件系统由Linux内核支持，在这个文件系统中的数据，实际上是内存中的，由于内存的数据断电易失，当系统重新启动的时候我们就会发现这个目录被清空了。 /lost+found恢复文件存放的位置。当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。 容易混淆的目录以上目录，是最常见的重要目录。其中，有些目录初学者容易混淆，这里简单区分一下： /bin,/sbin与/usr/bin,/usr/sbin:/bin一般存放 对于用户和系统来说“必须”的程序（二进制文件）。/sbin一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。/usr/bin一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。/usr/sbin一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。 /lib与/usr/lib:/lib和/usr/lib的区别类似/bin,/sbin与/usr/bin,/usr/sbin。/lib一般存放对于用户和系统来说“必须”的库（二进制文件。/usr/lib一般存放的只是对用户和系统来说“不是必需的”库（二进制文件。 其他其他还一些目录例如/home/user/bin，/home/user/opt，/home/user/etc，/usr/local/etc等等，其作用都是类似于/etc，/bin等目录的，可能只是层次概念不同了，使用Linux时间长了，会逐渐体会到其中的含义。 当然，我们可以无视这些目录，像使用Windows那样自由的，不管啥文件，想往哪存就往哪存，还是那句话，使用Linux时间长了，会逐渐体会到其中的含义，到时候也许我们想要乱来都不行了呢。^_^ man帮助在大多数Linux系统上面，我们可以使用一个命令：“man hier”，通过这个命令的输出，就知道“根目录”中所子目录的作用了。这个命令含义我不多说了，总之这里的hier就是对Linux文件系统中各级目录的标准功能，是一个大家都约定俗成了的东西。想要了解每个目录更详细的信息，需要仔细参考”man hier”的输出。下面就是一个比较简短的中文描述的对文件系统目录分类的FHS标准，也就是对”man hier”的简单翻译。 NAME 名称 hier – 文件系统描述 DESCRIPTION 描述 一个典型的Linux系统具以下几个目录结构：/ 根目录，是所目录树开始的地方。/bin 此目录下包括了单用户方式及系统启动或修复所用到的所执行程序。/boot 包括了引导程序的静态文件。此目录下包括了在引导过程中所必需的文件。系统装载程序及配制文件在 /sbin 和 /etc 目录中找到。/dev 对应物理设备的指定文件或驱动程序。参见mknod(1)。/dos 如果MS-DOS和Linux共存于一台计算机时，这里通常用于存放DOS 文件系统。/etc 用于存放本地机的配置文件。一些大型套件，如X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc./etc/skel 当建立一个新用户账号时，此目录下的文件通常被复制到用户的主目录下。/etc/X11X11 window system所需的配置文件。/home 在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。/lib 此目录下包含系统引导和在根用户执行命令所必需用到的共享库。/mnt 挂载临时文件系统的挂载点。/proc 这是提供运行过程和核心文件系统 proc 挂载点。这一”伪”文件系统在以下章节中详细叙述 proc(5)。/sbin 类似于 /bin 此目录保存了系统引导所需的命令，但这些命令一般使用者不能执行。/tmp 此目录用于保存临时文件，临时文件在日常维护或在系统启动时无需通知便可删除/usr 此目录通常用于从一个独立的分区上挂载文件。它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。/usr/X11R6 X-Window系统 Version 11 release 6./usr/X11R6/bin X-Windows系统使用的二进制文件；通常是在对更传统的 /usr/bin/X11 中文件的符号连接。/usr/X11R6/lib 保存与X-Windows系统关数据文件。/usr/X11R6/lib/X11 此目录保存与运行X-Windows系统关其他文件。通常是对来自 /usr/lib/X11 中文件的符号连接。/usr/X11R6/include/X11 此目录保存包括使用X11窗口系统进行编译程序所需的文件。通常是对来自 /usr/lib/X11 中文件的符号连接。/usr/bin 这是执行程序的主要目录，其中的绝大多数为一般使用者使用，除了那些启动系统或修复系统或不是本地安装的程序一般都放在此目录下。/usr/bin/X11X11执行文件放置的地方；在Linux系统中，它通常是对 /usr/X11R6/bin. 符号连接表 /usr/dict此目录保存拼写检查器所使用的词汇表文件。 /usr/doc此目录下应可以找到那些已安装的软件文件。 /usr/etc此目录可用来那些存放整个网共享的配置文件。然而那可执行命令指向总是使用参照使用 /etc 目录下的文件。 /etc 目录下连接文件应指向 /usr/etc. 目录下适当的文件。 /usr/includeC程序语言编译使用的Include”包括”文件。 /usr/include/X11C程序语言编译和X-Windows系统使用的 Include”包括”文件。它通常中指向 /usr/X11R6/include/X11. 符号连接表。 /usr/include/asm申明汇编函数的Include”包括”文件，它通常是指向 /usr/src/linux/include/asm 目录的符号连接 /usr/include/linux包含系统变更的信息通常是指向 /usr/src/linux/include/linux 目录的符号连接表，来获得操作系统特定信息。 (注：使用者应在此自行包含那些保证自己开发的程序正常运行所需的libc 函数库。不管怎样，Linux核心系统不是设计用来执行直接运行用户程序的，它并不知道用户程序需要使用哪个版本的libc库 。如果你随意将 /usr/include/asm 和 /usr/include/linux 指向一个系统核心，系统很可能崩溃。Debian系统不这么做。它使用 libc*-dev运行包中提供的核心系统标识，以保证启动所正确的文件。) /usr/include/g++GNU C++编译程序所使用的Include”包括”文件。 /usr/lib目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件案。一些复杂的程序可能在此占用整个子目录。 /usr/lib/X11存放X系统数据文件及系统配置文件的地方。 Linux中通常是指向 /usr/X11R6/lib/X11 目录的符号连接表。 /usr/lib/gcc-libGNU C 编译程序所使用的可执行文件案和”包括”文件。 gcc(1). /usr/lib/groffGNU groff 文件格式系统所使用的文件。 /usr/lib/uucpuucp(1) 所使用的文件。 /usr/lib/zoneinfo关时区信息文件文件。 /usr/local安装在本地执行程序的地方。 /usr/local/bin在此地放置本地执行程序的二进制文件。 /usr/local/doc放置本地文件。 /usr/local/etc安装在本地程序的配置文件。 /usr/local/lib安装在本地程序的库文件。 /usr/local/info安装在本地程序关信息文件。 /usr/local/man安装在本地程序使用手册。 /usr/local/sbin 安装在本地的系统管理程序。 /usr/local/src安装在本地程序的原始码。 /usr/man手册页通常放在此目录，或相关子目录下。 /usr/man//man[1-9]此目录在指定的地方以原始码形式存放手册页。系统在所的手册页中使用自己独特的语言及代码集，可能会省略 substring 子字符串。 /usr/sbin此目录保存系统管理程序的二进制码，这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。 /usr/share在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些数据。 /usr/src系统不同组成部份的源文件包括参考数据报。不要将你自己与项目关的文件放这里，因为在安装软件外，/usr下的文件属性除通常设为只读。 /usr/src/linux系统核心资源通常拆包安装于此。这是系统中重要的一环，因为 /usr/include/linux 符号连接表指向此目录。你应当使用其他目录来来编译建立新核心。 /usr/tmp此目录不再使用了。它应指向目录 /var/tmp。 这个链接只是出于系统兼容的目的，一般不再使用。 /var此目录下文件的大小可能会改变，如缓冲文件可日志文件。 /var/adm此目录为 /var/log 甩替代，通常是指向 /var/log 的符号连接表。 /var/backups此目录用来存放重要系统文件的后备文件 /var/catman/cat[1-9] or /var/cache/man/cat[1-9]此目录存储根据手册分类预先格式化的参考手册页。(这些参考手册页是相互独立的) /var/lock此目录存储锁定文件。依据命名习惯，设备锁定文件是 LCKxxxxx xxxxx与在文件系统中该设备名相同，使用的格式是HDU UUCP锁定文件，例如包含进程标识PID的锁定文件是一个10字节的ASCII格式的数字，后面跟一个换行符。 /var/log各种日志文件。 /var/preserve这是 vi(1) 存放正在编辑中的文件，以便以后可以恢复。 /var/run运行时的变量文件，如存放进程标识和登入使用者信息的文件。 (utmp) 此目录下文件在系统启动时被自动清除。 /var/spool各种程序产生的缓冲或排除等待的文件 /var/spool/atat(1) 的作业存缓区 /var/spool/croncron(1) 的作业存缓区 /var/spool/lpd打印缓存文件。 /var/spool/mail使用者邮箱。 /var/spool/smail存放 smail(1) 邮件发送程序的缓冲文件。 /var/spool/news新闻子系统的缓冲目录 /var/spool/uucpuucp(1) 的缓冲文件 /var/tmp类似 /tmp, 此目录保存未指定持续时间的临时文件。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu-18.04 以root登录桌面]]></title>
    <url>%2F2018%2F08%2F09%2FUbuntu-18-04-%E4%BB%A5root%E7%99%BB%E5%BD%95%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Ubuntu 18.04默认是不允许以root用户进行登录的，想要以root用户进行登录需要进行一些操作，主要是以下几个步骤： 第一步：以普通用户登录系统，创建root用户的密码在终端输入命令：sudo passwd root然后输入你要设置的密码，这样就完成了设置root用户密码的步骤 第二步：修改文件50-unity-greeter.conf文件：123cd /usr/share/lightdm/lightdm.conf.d/cp 50-unity-greeter.conf 50-unity-greeter.conf_bakvi 50-unity-greeter.conf 将文件修改为 123456789[SeatDefaults]#启动后以root身份自动登录autologin-user=rootgreeter-session=unity-greeteruser-session=ubuntu#手工输入登陆系统的用户名和密码greeter-show-manual-login=true#禁用guest用户allow-guest=false 保存 第三步：修改gdm-autologin和gdm-password文件：1234567cd /etc/pam.d cp gdm-autologin gdm-autologin_bakvi gdm-autologin 注释掉auth required pam_succeed_if.so user != root quiet_success这一行，保存 cp gdm-password gdm-password_bakvi gdm-password 注释掉 auth required pam_succeed_if.so user != root quiet_success这一行，保存 第四步：修改/root/.profile文件123cd /root/vi .profile 将文件末尾的mesg n || true这一行修改成tty -s&amp;&amp;mesg n || true， 保存 第五步：重启系统，输入root用户名和密码，登录系统。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Linux 安装 .7z 解压和压缩文件]]></title>
    <url>%2F2018%2F08%2F09%2FUbuntu-Linux-%E5%AE%89%E8%A3%85-7z-%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[安装方法： 1sudo apt-get install p7zip 解压文件： 17z x manager.7z -r -o /home/xx 解释如下：x 代表解压缩文件，并且是按原始目录解压（还有个参数 e 也是解压缩文件，但其会将所有文件都解压到根下，而不是自己原有的文件夹下）manager.7z 是压缩文件，这里大家要换成自己的。如果不在当前目录下要带上完整的目录-r 表示递归所有的子文件夹-o 是指定解压到的目录，这里大家要注意-o后是没有空格的直接接目录 压缩文件： 17z a -t7z -r manager.7z /home/manager/* 解释如下：a 代表添加文件／文件夹到压缩包-t 是指定压缩类型 一般我们定为7z-r 表示递归所有的子文件夹，manager.7z 是压缩好后的压缩包名，/home/manager/* 是要压缩的目录，*是表示该目录下所有的文件。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统查看内存占用和CPU使用率的方法]]></title>
    <url>%2F2018%2F08%2F06%2FUbuntu%E7%B3%BB%E7%BB%9F%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%92%8CCPU%E4%BD%BF%E7%94%A8%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单独查看内存使用情况的命令： 1free -m 查看内存及cpu使用情况的命令： 1top 可以安装htop工具，这样更直观，安装命令如下： 1sudo apt-get install htop 安装完后，直接输入命令： 1htop 就可以看到内存或cpu的使用情况了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synergy—一套键鼠同时控制多台电脑的神器（Ubuntu16.04+Win10）]]></title>
    <url>%2F2018%2F08%2F06%2FSynergy%E2%80%94%E4%B8%80%E5%A5%97%E9%94%AE%E9%BC%A0%E5%90%8C%E6%97%B6%E6%8E%A7%E5%88%B6%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E7%A5%9E%E5%99%A8%EF%BC%88Ubuntu16-04-Win10%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/qq_35451572/article/details/79284549 很多人自己有两台电脑，但是桌面空间有限不想使用两套鼠标键盘，这时就需要一个神器来将两台机器连接起来。天下之大无奇不有，你们期待的神器已经诞生————Synergy. Synergy 可以让你的多台电脑共享一套键鼠，甚至还可以共享剪贴板，而你只需动动鼠标，指针就可以轻松地在各台电脑屏幕之间来回穿梭，就像一台电脑使用多个显示器一样。而且 Synergy 完全免费开源，并跨平台支持 Win/Mac/Linux，相当给力！ 就是注册码暂时是没有的，需要到某宝上去购买一个（你们懂得）. 在Ubuntu中Synergy安装在网上有些博客说在Ubuntu Software中可以直接下载Synergy安装包，但是并没有看到～～ 直接将终端切换到安装包存放的目录中，直接dpkg安装 1sudo dpkg -i synergy-v1.8.8-stable-25a8cb2-Linux-x86_64.deb 如果出现以下界面就是说明你没有安装相应的库文件； 这时就需要安装两个必须的库 12sudo apt-get install libavahi-compat-libdnssd1sudo apt-get install libavahi-compat-libdnssd-dev 安装成两个上述所示的两个库以后，重新执行安装命令，如果没有别的意外就可以安装好程序。 1sudo dpkg -i synergy-v1.8.8-stable-25a8cb2-Linux-x86_64.deb 安装成功以后的图片如下图所示 在Win中Synergy安装这个就相对来说简单多了，不需要太多的库支持直接选择下一步就是可以的。 两台电脑Synergy设置 首先在客户端设置自己的电脑的位置信息，Synergy电脑初始名称是根据系统名称设定的。我自己的两台电脑如上图所示名字分别设定为Gao与gao,主机不能够重名是知道的，但是没有想到Synergy是不区分英文字母大小写的，这样就需要修改一台机器的名称不发生冲突。Synergy ERROR: ipc connection error INFO: watchdog status: error这个问题有些时候重启服务也是不可以的，这个时候可以尝试进行重新的激活，我测试过重新激活一下是可以的。]]></content>
      <categories>
        <category>Synergy</category>
      </categories>
      <tags>
        <tag>Synergy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt .Pro]]></title>
    <url>%2F2018%2F08%2F06%2FQt-Pro%2F</url>
    <content type="text"><![CDATA[123456CONFIG += releaseMOC_DIR = temp/mocRCC_DIR = temp/rccUI_DIR = temp/uiOBJECTS_DIR = temp/objDESTDIR = bin]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本中echo显示内容带颜色]]></title>
    <url>%2F2018%2F08%2F02%2Fshell%E8%84%9A%E6%9C%AC%E4%B8%ADecho%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9%E5%B8%A6%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[shell脚本中echo显示内容带颜色显示,echo显示带颜色，需要使用参数-e格式如下： 1 echo -e “\033[字背景颜色；文字颜色m字符串\033[0m” 例如： 1echo -e &quot;\033[41;36m something here \033[0m&quot; 其中41的位置代表底色， 36的位置是代表字的颜色注： 1、字背景颜色和文字颜色之间是英文的”” 2、文字颜色后面有个m 3、字符串前后可以没有空格，如果有的话，输出也是同样有空格 字颜色：30—–37 12345678echo -e &quot;\033[30m 黑色字 \033[0m&quot;echo -e &quot;\033[31m 红色字 \033[0m&quot;echo -e &quot;\033[32m 绿色字 \033[0m&quot;echo -e &quot;\033[33m 黄色字 \033[0m&quot;echo -e &quot;\033[34m 蓝色字 \033[0m&quot;echo -e &quot;\033[35m 紫色字 \033[0m&quot;echo -e &quot;\033[36m 天蓝字 \033[0m&quot;echo -e &quot;\033[37m 白色字 \033[0m&quot; 字背景颜色范围：40—–47 12345678echo -e &quot;\033[40;37m 黑底白字 \033[0m&quot;echo -e &quot;\033[41;37m 红底白字 \033[0m&quot;echo -e &quot;\033[42;37m 绿底白字 \033[0m&quot;echo -e &quot;\033[43;37m 黄底白字 \033[0m&quot;echo -e &quot;\033[44;37m 蓝底白字 \033[0m&quot;echo -e &quot;\033[45;37m 紫底白字 \033[0m&quot;echo -e &quot;\033[46;37m 天蓝底白字 \033[0m&quot;echo -e &quot;\033[47;30m 白底黑字 \033[0m&quot; 最后面控制选项说明 12345678910111213141516171819\33[0m 关闭所有属性 \33[1m 设置高亮度 \33[4m 下划线 \33[5m 闪烁 \33[7m 反显 \33[8m 消隐 \33[30m — \33[37m 设置前景色 \33[40m — \33[47m 设置背景色 \33[nA 光标上移n行 \33[nB 光标下移n行 \33[nC 光标右移n行 \33[nD 光标左移n行 \33[y;xH设置光标位置 \33[2J 清屏 \33[K 清除从光标到行尾的内容 \33[s 保存光标位置 \33[u 恢复光标位置 \33[?25l 隐藏光标 \33[?25h 显示光标]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[截图工具]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[免安Snipaste 需要安装Lightshot]]></content>
  </entry>
  <entry>
    <title><![CDATA[联通hg8347r光猫破解改桥接]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%81%94%E9%80%9Ahg8347r%E5%85%89%E7%8C%AB%E7%A0%B4%E8%A7%A3%E6%94%B9%E6%A1%A5%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[破解华为HG8346R/HG8347R光猫 启用有线桥接_Cherrot`s北京联通华为光猫HG8346R破解改桥接_什么值得买北京联通华为HG8347R破解_宽带技术网HG8347R破解_雲月冠上-简书 工具下载“https://file.xbao.org/?dir=HG8347R%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7”]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMS]]></title>
    <url>%2F2018%2F07%2F24%2FKMS%2F</url>
    <content type="text"><![CDATA[Kms激活工具没有官网，搜索工具搜出来的都是第三方网站或者一些假官网。Kms作者只将其发布在了MDL论坛。MDL论坛 Kms工具所在页面https://forums.mydigitallife.net/threads/kmspico-official-thread.65739/，需要登陆 账号是谷歌邮箱注册的 自己下载的目前最新版本10.2.0：https://file.xbao.org/?dir=KMSpico]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10安装hp m1216打印机驱动]]></title>
    <url>%2F2018%2F07%2F23%2FWin10%E5%AE%89%E8%A3%85hp-m1216%E6%89%93%E5%8D%B0%E6%9C%BA%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[下载LJM1130_M1210_MFP_Full_Solution.exe 双击，程序会自解压。但是到100%后，就没有反应了。。。。。。。 找到路径“C:\Users\10700\AppData\Local\Temp\7zS713F”，双击“HpSetup.exe”进行安装。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Beyond Compare 4 破解]]></title>
    <url>%2F2018%2F07%2F21%2FBeyond-Compare-4-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2018年11月24日更新原方法已失效，需要更改注册表 在搜索栏中输入 regedit，打开注册表 找到“计算机\HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId”，将“CacheId”重命名或删除 Beyond Compare 4这个软件安装完成后在C:\Users\用户名\AppData\Roaming\BCompare 下会生成一个文件BCompare.ini，记录安装的时间，最近一次打开软件的时间。如下图这样Beyond Compare 4 调用 time_t time(time_t *t) 生成的一个时间戳而已，那么试用时间就显而易见了，两个时间戳一减，超过30天就不让你用了。将BCompare.ini文件中LastLoading值改为与InstallTime值相同，保存关闭。将BCompare.ini文件修改为只读。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vs_Qt工程，无Pro文件，添加模块]]></title>
    <url>%2F2018%2F07%2F21%2FVs-Qt%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%97%A0Pro%E6%96%87%E4%BB%B6%EF%BC%8C%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[项目名右键，选择“Qt Project Settings” 选择“Qt Modules”，添加相应的模块]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++注释规范]]></title>
    <url>%2F2018%2F07%2F16%2FC-C-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[整理自互联网，整合了许多大佬及公司的规范，谨记 文件头 123456789/***************************************************************************** * Copyright: zhou * File name: 文件名 * Description: 用于详细说明此程序文件完成的主要功能，与其他模块或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系 * Author: 作者 * Version: 版本 * Date: 完成日期 * History: 修改历史记录列表， 每条修改记录应包括修改日期、修改者及修改内容简述。 *****************************************************************************/ 函数注释 123456789/***************************************************************************** * Function: // 函数名称 * Description: // 函数功能、性能等的描述 * Input: // 输入参数说明，包括每个参数的作 * // 用、取值说明及参数间关系。 * Output: // 对输出参数的说明。 * Return: // 函数返回值的说明 * Others: // 其它说明 *****************************************************************************/]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt_打开|保存文件对话框]]></title>
    <url>%2F2018%2F06%2F29%2FQt-%E6%89%93%E5%BC%80-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[Qt_打开|保存文件对话框 12345678910111213// 打开文件对话框QString fileName = QFileDialog::getOpenFileName( this, tr("open file"), " ", tr("Allfile(*.*);;mp3file(*.mp3)"));/* * 说明：这样就会产生一个对话框，和系统的资源管理器差不多的。返回的是你选择文件的 绝对路径。 * 参数1：父窗口 * 参数2：对话框的标题 * 参数3：默认的打开的位置，如”我的文档“等 * 参数4：文件的过滤器，注意文件类型之间用 ;; 分开 * */ 12345678910111213// 保存文件对话框QString fileName = QFileDialog::getSaveFileName( this, tr("save file"), " ", tr("file(*.bin);;Allfile(*.*)"));/* * 说明：这样就会产生一个对话框，和系统的资源管理器差不多的。返回的是你要保存文件的 绝对路径。 * 参数1：父窗口 * 参数2：对话框的标题 * 参数3：默认的保存的位置，如”我的文档“等 * 参数4：文件的过滤器，注意文件类型之间用 ;; 分开 * */]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体里的冒号“:”]]></title>
    <url>%2F2018%2F06%2F28%2F%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E7%9A%84%E5%86%92%E5%8F%B7%E2%80%9C-%E2%80%9D%2F</url>
    <content type="text"><![CDATA[结构体里的冒号“:” 位结构是一种特殊的结构, 在需按位访问一个字节或字的多个位时, 位结构比按位运算符更加方便。 位结构定义的一般形式为: 12345struct 位结构名&#123; 数据类型 变量名: 整型常数; 数据类型 变量名: 整型常数; &#125; 位结构变量; 数据类型必须是int(unsigned或signed)。 整型常数必须是非负的整数, 范围是0~15, 表示二进制位的个数, 即表示有多少位。变量名是选择项, 可以不命名, 这样规定是为了排列需要。 123456struct id_flag&#123; unsigned is_keyword:1; unsigned is_external:1 unsigned is_static:1;&#125;flag; 本例定义了is_keyword、is_external、is_static三个位字段，它们各占1位（1bit）存储空间。同时，也定义了一个名为flag的struct id_flag类型的结构体变量。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++中单冒号: 和双冒号:: 的用法]]></title>
    <url>%2F2018%2F06%2F28%2FC-C-%E4%B8%AD%E5%8D%95%E5%86%92%E5%8F%B7-%E5%92%8C%E5%8F%8C%E5%86%92%E5%8F%B7-%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一.单冒号（:）1. 位域结构 有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： struct 位域结构名{ 位域列表 };其中位域列表的形式为： 类型说明符 位域名：位域长度例如： 123456struct bs &#123; int a:8; int b:2; int c:6; &#125;; 位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如： 123456struct bs &#123; int a:8; int b:2; int c:6; &#125;data; 说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：a) 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： 1234567struct bs &#123; unsigned a:4 unsigned :0 /*空域*/ unsigned b:4 /*从下一单元开始存放*/ unsigned c:4 &#125; 在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。 b) 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如： 1234567struct k &#123; int a:1 int :2 /*该2位不能使用*/ int b:3 int c:2 &#125;; 从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。 2. 条件语句( ? : )与?构成条件语句，作用相当于if else，如下； 1234int a,b,c;a=3;b=2;c=a&gt;b?a:b;// 如果a&gt;b成立，则反a赋给c，否则把b赋给c 条件语句的结构为：条件表达式?表达式1:表达式2当条件表达式为true时，表达式的值为表达式1的值，否则为表达式2的值。几点说明：1）?:可以嵌套，但不推荐使用（难懂），下面的表达式你能看懂啥意思不 1int max = i&gt;j ? i&gt;k ? i : k : j&gt;k ? j : k; 脑袋大了吧，呵呵。2）?:具有很低的优先级，这个要注意哦，下面的程序执行结果是啥呢？ 12345int i = 3;int j = 2;cout &lt;&lt; i&gt;j?i:j;// 出错，&lt;&lt;比&gt;具有更高的优先级，执行顺序为 ((cout&lt;&lt;i)&gt;j)?i:j,相当于是比较cout&lt;&lt;i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout&lt;&lt;i的值是cout，不能跟整型数j进行比较。cout &lt;&lt; (i&gt;j)?i:j;//输出1或0，相当于(cout&lt;&lt;(i&gt;j))作为判决条件，来决定表达式的值为i或j，而cout&lt;&lt;(i&gt;j)，i&gt;j则输出1否则0，然后再将(cout&lt;&lt;(i&gt;j))作为？：的条件，如果cout正确执行则为1（true），否则为0（false），以此决定表达式值为i或jcout &lt;&lt;(i&gt;j?i:j);//i&gt;j则输出i，否则输出j，表达式值为true如果cout正确执行，否则为false 更多的关于优先级的问题就不说了。 3. 语句标签通常跟goto配合使用，如： 123step1: a = f1(); .... goto step1; 这种作法也不是很推荐，原因在于它破坏了语句的顺序执行，这样的代价大家应该清楚吧。不过存在即为合理嘛，既然它还存在，肯定还是有它的用处有它的好处的，比如说，多层嵌套的退出（会比break continue直观一点吧），也可以避免重复代码之类之类的 4. switch语句中case后这个不说了，要是不会的话，我也没话可说了。 5. 汇编指令模板具体参考：http://developer.e800.com.cn/articles/2006/43/1144846933898_1.html 6. 类构造函数(Constructor）的初始化列表在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号(,)隔开。下面举个例子。 123456789101112class myClass&#123;public : myClass();// 构造函数，无返回类型，可以有参数列表，这里省去 ~myClass();// 析构函数 int a; const int b;&#125; myClass::myClass():a(1),b(1)// 初始化列表&#123;&#125; 上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明：a)初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错： 12345myClass::myClass（）&#123; a = 1;// 没错，效果相当于在初始化列表中进行初始化 b = 1;// 出错，const变量不能进行赋值操作；&#125; b）初始化的顺序与成员变量声名的顺序相同。先看一下下面的程序： 123myClass::myClass():b(1),a(b)&#123;&#125; 这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。c）对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。 7. 声明基类假设我们重新定义一个类，继承自myClass类。定义方式如下： 1234class derivedClass : public myClass&#123;// 略去&#125; 这里的冒号起到的就是声名基类的作用，在基类类名前面可以加public\private\protected等标签，用于标识继承的类型，也可以省略，省略的话，用class定义的类默认为private，用struct定义的类默认为public，至于具体各个标签有什么区别这里就不说了。与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。 二．双冒号（::）用法1. 表示“域操作符”例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成void A::f()，表示这个f()函数是类A的成员函数。 2. 直接用在全局函数前，表示是全局函数例：在VC里，你可以在调用API 函数里，在API函数名前加：： 3. 表示引用成员函数及变量，作用域成员运算符例：System::Math::Sqrt() 相当于System.Math.Sqrt() 4. 命名空间作用域符，即2直接用在全局函数前，表示是全局函数在运算符等级中属于最高级的！using namespace 命名空间名（如，abc）；表示在以下程序代码中所使用的标示符（如果此标示符在abc中定义）是abc中的，包括类型名（类），变量名，函数名，对象名。。。using abc::标示符(i)；只表示在以下代码中使用的标示符i是abc中的。如果你要使用abc中的多个标示符的话，你就只能用 1234using abc::a;using abc::b;using abc::c;... 等一个一个列举出来！当然用using 语句是比较方便的但是不安全（1）using namespace；万一不同的两个命名空间中使用了同名的标示符，系统则不能判断，这个标示符是属于哪个命名空间的；（2）using abc::；万一你的程序中也用到了一个函数（函数名与abc中的这个函数同名），那么系统也不能判断你使用的是abc中的那个函数，还是本程序中的那个函数；最安全的办法（当然也是最繁琐的）就是，每当你用到一个变量（函数…)时，你都要明确他的来历（即属于哪个命名空间）除非它没有命名空间例如： 123456#include &lt;iostream&gt; int main ()&#123; std::cout &lt;&lt; "hello, world!" &lt;&lt; std::endl;&#125; 这里就用到了iostream文件中的两个对象（cout，endl）因为C++标准库中绝大部分的函数，对象…都放在了命名空间std中所以上面的代码就等同于 1234567#include &lt;iostream&gt;using std::cout；using std::endl;int main ()&#123; cout &lt;&lt; "hello, world!" &lt;&lt; endl;&#125; 1234567#include &lt;iostream&gt;using namespace std; int main ()&#123; cout &lt;&lt; "hello, world!" &lt;&lt; endl;&#125; 重新举个例子，再加以说明： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt; int main ()&#123; int a; std::string b; std::cin &gt;&gt; a; std::cin &gt;&gt; b; std::cout &lt;&lt; "hello, world!" &lt;&lt; std::endl; return 0;&#125; 1) using std::； 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::endl;using std::string; int main ()&#123; int a; string b; cin &gt;&gt; a; cin &gt;&gt; b; std::cout &lt;&lt; "hello, world!" &lt;&lt; endl; //注意cout没用用using return 0;&#125; 2) using namespace ； 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int main ()&#123; int a; string b; cin &gt;&gt; a; cin &gt;&gt; b; cout &lt;&lt; "hello, world!" &lt;&lt; endl; return 0;&#125; 其中cout endl cin string都是std中的！]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt Timer]]></title>
    <url>%2F2018%2F06%2F27%2FQt-Timer%2F</url>
    <content type="text"><![CDATA[*.h 12public slots: void Timeout_Slots(); *.cpp 1234567891011121314#include &lt;QTimer&gt;#include &lt;QDebug&gt; // 创建定时器QTimer *timer = new QTimer(this);timer-&gt;start(1000);connect(timer, SIGNAL(timeout()), this, SLOT(Timeout_Slots())); // 关联定时器槽函数 // 定时器槽函数void Widget::Timeout_Slots()&#123; qDebug() &lt;&lt; "[FILE:" &lt;&lt; __FILE__ &lt;&lt; ",LINE" &lt;&lt; __LINE__ &lt;&lt; ",FUNC" &lt;&lt; __FUNCTION__ &lt;&lt; "]"; ......&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ_MIO_C代码]]></title>
    <url>%2F2018%2F06%2F27%2FZYNQ-MIO-C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[全局变量 12#define MIO_PinNumber 34 // 宏定义对应MIO引脚static XGpioPs g_psGpioInstancePtr;//定义结构体 初始化函数 1234567891011121314151617181920212223int MIO_Init()&#123; //MIO struct initial int xStatus; XGpioPs_Config* GpioConfigPtr; //--MIO的初始化 GpioConfigPtr = XGpioPs_LookupConfig(XPAR_PS7_GPIO_0_DEVICE_ID);//获取GPIO_0配置 if(GpioConfigPtr == NULL) &#123; return XST_FAILURE; &#125; xStatus = XGpioPs_CfgInitialize(&amp;g_psGpioInstancePtr, GpioConfigPtr, GpioConfigPtr-&gt;BaseAddr); if (Status != XST_SUCCESS) &#123; print("gpio_mio config error!\n"); return XST_FAILURE; &#125; //--MIO的输入输出操作 XGpioPs_SetDirectionPin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 1); //配置MIO34 direct is out；第二个参数为引脚号；第三个参数为控制输入输出：0为输入、1为输出 XGpioPs_SetOutputEnablePin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 1); //配置MIO引脚的输出使能；第二个参数为引脚号；第三个参数为控制使能：1代表使能、0代表失能&#125; 控制IO 1234567891011121314151617181920// 控制IO，方法一XGpioPs_WritePin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 0); // 设置对应引脚为低电平XGpioPs_WritePin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 1); // 设置对应引脚为高电平 // 控制IO，方法二/** 参数一：MIO基地址：固定为0xE000A000* 参数二：MIO偏移地址： 0x00000000，MIO 0~15* 0x00000004，MIO 16~31* 0x00000008，MIO 32~47* 0x0000000b，MIO 48~54* 参数三：32位的参数，分成2个16位： 低16位为设置管脚高低电平* 高16位为控制低16为的设置是否有效，只有当高16位的对应bit为0时，低16位对应bit设置高低电平才有效*/// 34引脚XGpioPs_WriteReg(0xE000A000, 0x00000008, 0xFFFBFFFF &amp; 0xFFFF0004); // 设置对应引脚为高电平XGpioPs_WriteReg(0xE000A000, 0x00000008, 0xFFFBFFFF &amp; 0xFFFF0000); // 设置对应引脚为低电平// 0引脚XGpioPs_WriteReg(0xE000A000, 0x00000000, 0xFFFFFFFE &amp; 0xFFFF0001); // 设置对应引脚为高电平XGpioPs_WriteReg(0xE000A000, 0x00000000, 0xFFFFFFFE &amp; 0xFFFF0000); // 设置对应引脚为低电平]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制补码转原码_C实现]]></title>
    <url>%2F2018%2F06%2F26%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81%E8%BD%AC%E5%8E%9F%E7%A0%81-C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920typedef struct _Point&#123; int nx; int ny;&#125;Point; Point originalPoint; //原始坐标 // 数据有效位为12位originalPoint.nx = (constell &amp; 0xfff); // x轴数值，为2进制补码；originalPoint.ny = ((constell &gt;&gt; 12) &amp; 0xfff); // y轴数值，为2进制补码；// 得到补码，将其转换为原码if(originalPoint.nx &gt;&gt; 11) //最高位是1，代表是负数的反码，计算原码&#123; originalPoint.nx -= 4096; // &#125;if(originalPoint.ny &gt;&gt; 11) //最高位是1，代表是负数的反码，计算原码&#123; originalPoint.ny -= 4096; // &#125; 1234567891011121314// 指定位数的二进制补码转原码int ComplementToSource(int Complement, int bits)&#123; int Source = Complement; int flag = (1 &lt;&lt; bits) - 1; if ((Complement &amp; flag) &gt;&gt; (bits - 1)) &#123; Source = Complement - (1 &lt;&lt; bits); &#125; return Source;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建并调用Win32 DLL]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%B0%83%E7%94%A8Win32-DLL%2F</url>
    <content type="text"><![CDATA[1. 生成Win32 DLL1.1 创建Win32 DLL工程File-&gt;New-&gt;Projects-&gt;Win32 Dynamic Link Library,在”Project name” 中输入MyDll-&gt;OK-&gt;An empty DLL project-&gt;Finish-&gt;OK 1.2 添加头文件mydll.hFile-&gt;new-&gt;Files-&gt;C/C++ Header File,输入文件名为:mydll.h-&gt;OK添加对应函数名mydll.h: 1extern "C" _declspec(dllexport) int Add(int x,int y); 1.3 添加源文件mydll.cpp File-&gt;new-&gt;Files-&gt;C/C++ Source File,输入文件名为:mydll-&gt;OK mydll.cpp: 123456#include&lt;stdio.h&gt;#include "mydll.h"int Add(int x,int y)&#123; return x+y;&#125; 1.4 编译,连接后,在Debug目录生成MyDll.dll,MyDll.lib 2. 调用Win32 DLL隐式调用 (1)File-&gt;New-&gt;Projects-&gt;Win32 Console Application,在”Project name” 中输入TestMyDll,OK,An empty project-&gt;Finish-&gt;OK将MyDll.dll,MyDll.lib拷贝到TestMyDll目录下。 (2)File-&gt;new-&gt;Files-&gt;C/C++ Source File,输入文件名为:testmydll-&gt;OKtestmydll.cpp: 12345678#include&lt;stdio.h&gt;#pragma comment(lib,"MyDll.lib")extern "C" _declspec(dllimport) int Add(int x,int y);void main()&#123; int i=Add(1,2); printf("1+2=%d/n",i);&#125; 注：也可将#pragma comment(lib,”MyDll.lib”)注释掉，并在Project-&gt;Settings-&gt;Link&gt;Object/library modules 中加入MyDll.lib 显式调用只须将MyDll.dll拷贝到TestMyDll目录下。 1234567891011121314#include&lt;stdio.h&gt;#include&lt;windows.h&gt; typedef int (*lpAdd)(int x,int y); void main()&#123; int i=0; HINSTANCE hinstance=LoadLibrary("MyDll.dll"); lpAdd add=(lpAdd)GetProcAddress(hinstance,"Add"); i=add(1,2); FreeLibrary(hinstance); printf("1+2=%d/n",i);&#125; 注：1.LoadLibrary:加载可执行模块 1234&gt; HINSTANCE LoadLibrary(&gt; LPCTSTR lpLibFileName // address of filename of executable module&gt; );&gt; 如果应用程序使用LoadLibrary显式链接，那么在这个函数的参数中可以指定DLL文件的完整路径。如果不指定路径，或是进行隐式链接，Windows将遵循下面的搜索顺序来定位DLL： 1． 包含EXE文件的目录， 2． 进程的当前工作目录， 3． Windows系统目录， 4． Windows目录， 5． 列在Path环境变量中的一系列目录。 2.GetProcAddress:返回指定导出Dll函数的地址 12345&gt; FARPROC GetProcAddress(&gt; HMODULE hModule, // handle to DLL module&gt; LPCSTR lpProcName // name of function&gt; );&gt;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种DLL（Win32DLL，MFC常规DLL和MFC拓展DLL）的简单学习总结]]></title>
    <url>%2F2018%2F06%2F23%2F%E4%B8%89%E7%A7%8DDLL%EF%BC%88Win32DLL%EF%BC%8CMFC%E5%B8%B8%E8%A7%84DLL%E5%92%8CMFC%E6%8B%93%E5%B1%95DLL%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习了三种动态链接库的基本知识，分别是Win32DLL，MFC常规DLL和MFC拓展DLL。 Win32DLL使用的是Win32的API实现的，只能导出函数，能被各种应用程序调用，适用范围最广。 MFC常规DLL是适用MFC创建的，就像MFC程序跟Win32程序的关系一样，MFC常规DLL和Win32DLL的关系也是如此。它使用MFC的机制，只能导出标准C函数。如此，它便可以被大部分Win32程序调用。 MFC拓展DLL也也使用的是MFC机制创建的，相比于MFC常规DLL，拓展DLL可以导出C++类和MFC派生类，如此扩大了DLL的接口范围。此长彼消，MFC拓展DLL的适用范围较小，只能被MFC程序调用。因为它导出的不只是函数，还有C++类和MFC派生类。 另外，所有的动态链接库都有两种链接方式：隐式调用和显示调用。隐式链接使用起来比较方便，不过不够灵活；显示链接可以在真正要用DLL的时候才装入，并在适当的时候释放，操作相对复杂一些。]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt打印文件名、函数名、行号]]></title>
    <url>%2F2018%2F06%2F23%2FQt%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D%E3%80%81%E8%A1%8C%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[1qDebug() &lt;&lt; "[FILE:" &lt;&lt; __FILE__ &lt;&lt; ",LINE" &lt;&lt; __LINE__ &lt;&lt; ",FUNC" &lt;&lt; __FUNCTION__ &lt;&lt; "]";]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt打包（Qt自带Windep打包工具）]]></title>
    <url>%2F2018%2F06%2F23%2FQt%E6%89%93%E5%8C%85%EF%BC%88Qt%E8%87%AA%E5%B8%A6Windep%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Qt工程生成Release版 找到Release版exe，将其复制到一个单独的文件夹内（也可在默认路径内） 打开工具，与Qt工程版本一致 使用cd命令，切换至exe文件所在的路径 输入命令 1windeployqt ***.exe]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP文章页面警告解决方法]]></title>
    <url>%2F2018%2F06%2F22%2FWP%E6%96%87%E7%AB%A0%E9%A1%B5%E9%9D%A2%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在文章页内容最下方会有如下警告 1Warning: Missing argument 1 for cwppos_show_review(), called in /www/wwwroot/xbao.org/wp-content/themes/flat/content-single.php on line 29 and defined in /www/wwwroot/xbao.org/wp-content/plugins/wp-product-review/includes/legacy.php on line 18 找到cwppos_show_review();函数调用的地方，将其改为cwppos_show_review(void);]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt4->Qt5 error]]></title>
    <url>%2F2018%2F06%2F22%2FQt4-Qt5-error%2F</url>
    <content type="text"><![CDATA[“error: C1083: 无法打开包括文件: “QWidget”: No such file or directory”在.pro文件中添加 1greaterThan(QT_MAJOR_VERSION, 4): QT += widgets “error: C1083: 无法打开包括文件: “QSound”: No such file or directory”在.pro文件中添加 1greaterThan(QT_MAJOR_VERSION, 4): QT += multimedia]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
</search>
