<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开启文章加密]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%BC%80%E5%90%AF%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[密码为P@ssw0rd Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32相关]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[转自“https://blog.csdn.net/sinat_36184075/article/details/70216197” 宏定义USE_STDPERIPH_DRIVER, STM32F10X_HD 不同类型的型号STM32固件库Libraries\CMSIS\Core\CM3\startup\arm中启动文件的文件名英文缩写意义： cl：互联型产品， stm32f105/107 系列 vl：超值型产品， stm32f100 系列 xl：超高密度（容量） 产品， stm32f101/103 系列 ld：低密度产品， FLASH 小于 64K md：中等密度产品， FLASH=64 or 128 hd：高密度产品， FLASH 大于 128 GPIO_TypeDef 型结构123GPIO_TypeDef * GPIOx; //定义一个 GPIO_TypeDef 型结构体指针 GPIOxGPIOx = GPIOA; //把指针地址设置为宏 GPIOA 地址GPIOx-&gt;CRL = 0xffffffff; //通过指针访问并修改 GPIOA_CRL 寄存器 总线AHB 高级高性能总线，一种系统总线。连接模块如CPU、DMA、DSP等APB 一种外围设备总线。连接模块如UART、I2C等// APB1:低速外设总线；APB2:高速外设总线。 时钟 高速外部时钟（HSE） 以外部晶振作时钟源，晶振频率可取范围为4~16MHz，我们一般采用’ 8MHz ‘的晶振。 高速内部时钟（HSI） 由内部 RC 振荡器产生，频率为 8MHz，但不稳定。 低速外部时钟（LSE） 以外部晶振作时钟源，主要提供给实时时钟模块，所以一般采用 32.768KHz。 野火 M3 实验板上用的是 32.768KHz， 6p 负载规格的晶振。 低速内部时钟（LSI） 由内部 RC 振荡器产生，也主要提供给实时时钟模块，频率大约为 40KHz。 锁相环 PLL主要功能是倍频（扩大频率），经过PLL 的时钟称为 PLLCLK。GPIO时钟GPIO 外设是挂载在 APB2 总线上的， APB2 的时钟是 APB2 预分频器的输出，而 APB2 预分频器的时钟来源是 AHB 预分频器。因此，把APB2 预分频器设置为不分频，那么我们就可以得到 GPIO 外设的时钟也等于 HCLK。 PCLK2：外设时钟，由 APB2 预分频器输出得到，最大频率可为72MHz，提供给挂载在 APB2 总线上的外设。 ‘ STM32每个外设都配备了外设时钟的开关，当我们不使用某个外设时，可以把这个外设时钟关闭，从而降低 STM32 的整体功耗。所以，当我们使用外设时，一定要记得开启外设的时钟啊，亲。 （STM32时钟：接收中断事件，降低功耗） 【GPIO相关结构体】123456typedef struct&#123; uint16_t GPIO_Pin; /* 指定将要进行配置的 GPIO 引脚 */ GPIOSpeed_TypeDef GPIO_Speed; /* 指定 GPIO 引脚可输出的最高频率 */ GPIOMode_TypeDef GPIO_Mode; /* 指定 GPIO 引脚将要配置成的工作状态 */&#125; GPIO_InitTypeDef; 123456typedef enum&#123; GPIO_Speed_10MHz = 1, // 枚举常量，值为 1，代表输出速率最高为 10MHz GPIO_Speed_2MHz, // 对不赋值的枚举变量，自动加 1，此常量值为 2 GPIO_Speed_50MHz // 常量值为 3&#125; GPIOSpeed_TypeDef; 12345678910typedef enum&#123; GPIO_Mode_AIN = 0x0, // 模拟输入模式 GPIO_Mode_IN_FLOATING = 0x04, // 浮空输入模式 GPIO_Mode_IPD = 0x28, // 下拉输入模式 GPIO_Mode_IPU = 0x48, // 上拉输入模式 GPIO_Mode_Out_OD = 0x14, // 开漏输入模式 GPIO_Mode_Out_PP = 0x10, // 通用推挽输出模式 GPIO_Mode_AF_OD = 0x1C, // 复用功能开漏输出 GPIO_Mode_AF_PP = 0x18 // 复用功能推挽输出&#125; GPIOMode_TypeDef; 【初始化函数库】#include “stm32f10x_gpio.c”void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)功能：初始化指定的GPIO管脚参数： @ GPIOx ：外设硬件对应的GPIO管脚地址(已在stm32f10x.h中被强转定义) @ GPIO_InitStruct ：需要此函数调用前定义该结构体变量，传其地址。返回值：none 12345/* 代码演示 - 多个GPIO参数同时赋值 */GPIO_InitTypeDef GPIO_InitStruct;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; /* 引脚模式为通用推挽输出 */GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /* 引脚速率为50MHz */ 【外设时钟控制函数】#include “stm32f10x_rcc.c”void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)功能：控制挂载在APB2上外设的时钟使能或禁止参数： @ RCC_APB2Periph ：指定外设去控制对应设备的时钟，参数可任意组合，参数如下 * RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB, * RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE, * RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1, * RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1, * RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3, * RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17, * RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11 @ NewState ：指定时钟的新的状态，参数如下 ENABLE or DISABLE返回值：none// 对应的如果挂载在APB1上，对应函数为 void RCC_APB1PeriphClockCmd (.., ..) 【控制I/O输出高、低电平函数】#include “stm32f10x_gpio.c”void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)功能：&lt;设置&gt;选定的GPIO数据端口位参数： @ GPIOx ：GPIO管脚类型，x可指定为AG @ GPIO_Pin ：指定被写入的数据端口位，即引脚号 Pin0Pin15返回值：none #include “stm32f10x_gpio.c”void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)功能：&lt;清除&gt;选定的GPIO数据端口位参数： @ GPIOx ：GPIO管脚类型，x可指定为AG @ GPIO_Pin ：指定被写入的数据端口位，即引脚号 Pin0Pin15返回值：none /*** 规范的位操作实现方法 ***/由于库函数的实现涉及到不少位操作，首先为读者介绍一下几个常用的位操作方法，排除阅读代码的障碍。1、 将 char 型变量 a 的第七位(bit6)清 0， 其它位不变。 a &amp;= ~(1&lt;&lt;6); // 括号内 1 左移 6 位，得二进制数： 0100 0000 // 按位取反，得 1011 1111 ，所得的数与 a 作”位与&amp;”运算， // a 的第 7 位（ bit6） 被置零，而其它位不变。2、 同理，将变量 a 的第七位(bit6)置 1，其它位不变的方法如下。 a |= (1&lt;&lt;6); // 把第七位（ bit6）置 1，其它为不变3、 将变量 a 的第七位(bit6)取反，其它位不变。 a ^=(1&lt;&lt;6); // 把第七位（ bit6）取反，其它位不变 【推挽输出】推挽输出的低电平为 0 伏，高电平为 3.3 伏。STM32 的 GPIO 输出模式就分为： 普通推挽输出(GPIO_Mode_Out_PP) 普通开漏输出(GPIO_Mode_Out_OD) 及复用推挽输出(GPIO_Mode_AF_PP) 复用开漏输出(GPIO_Mode_AF_OD ) 普通推挽输出模式一般应用在输出电平为 0 和 3.3 伏的场合。而普通开漏输出一般应用在电平不匹配的场合，如需要输出 5 伏的高电平，就需要在外部接一个上拉电阻，电源为 5 伏，把 GPIO 设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出 5 伏的电平。对于相应的复用模式，则是根据 GPIO 的复用功能来选择的，如 GPIO 的引脚用作串口的输出，则使用复用推挽输出模式。如果用在 IC、 SMBUS 这些需要线与功能的复用场合，就使用复用开漏模式。其它不同的复用场合的复用模式引脚配置将在具体的例子中讲解。在使用任何一种开漏模式，都需要接上拉电阻。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32-FreeRTOS知识整理总结]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32-FreeRTOS%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考自“https://www.cnblogs.com/lifexy/p/10463050.html” 1. 基础知识 注意:在RTOS中是优先值越高则优先级越高(和ucos/linux的相反) 在移植的时候,主要裁剪FreeRTOS/Source/portable文件夹,该文件夹用来针对不同MCU做的一些处理,如下图所示,我们只需要使用: FreeRTOS/Source/portable/Keil 使用MDK编译环境所需要使用的文件FreeRTOS/Source/portable/RVDS 内存管理相关的文件，移植所必需的FreeRTOS/Source/portable/MemMang 使用MDK编译环境所需要使用的文件 1.1配置工程时,选择memMang时,一般使用heap_4.c heep_1.c只能分配内存而不能释放内存。 heep_2.c可以分配和释放内存但不能合并空闲内存块。 heep_3.c简单的封装了线程安全版的标准C语言malloc和free函数。 heap_4: 优点在于可以有效的利用内存碎片来合并为一个大内存.缺点在于只能用来一个ram里. heap_5: 一般针对有外部RAM才用到,优点在于可以同时利用内部ram和外部ram来进行内存碎片合并. 然后我们在分配释放内存的时候,就尽量使用RTOS带的函数来实现,分配/释放函数如下所示: 12void *pvPortMalloc( size_t xWantedSize ); void vPortFree( void *pv ); 1.2 添加头文件路径添加FreeRTOS\include添加FreeRTOS\portable\RVDS\ARM_CM3并将原子中的FreeRTOSConfig.h也复制到我们项目的FreeRTOS\include中(用来配置RTOS系统) 2. FreeRTOSConfig.h配置介绍一般会写configXXXXX或者INCLUDE_XXXX类似的宏,这两个宏区别在于: configXXXXX用来实现不同功能,比如定义configUSE_COUNTING_SEMAPHORES为1时,表示使用计数信号量 INCLUDE_XXXX用来是否将某个API函数编译进程序中.比如定义INCLUDE_xTaskGetSchedulerState 为1 时,则将会编译xTaskGetSchedulerState()函数,如下图所示: 3. FreeRTOS任务状态3.1 运行态指当前任务正在运行. 3.2 就绪态指当前任务正在等待调度,因为有个高优先级/同优先级的任务正在运行中 3.3 阻塞态当前任务处于等待外部事件通知或通过vTaskDelay()函数进入休眠了,外部事件通知常见有信号量、等待队列、事件标志组、任务通知. 3.4 挂起态类似于暂停,表示不会再参与任务调度了,通过vTaskSuspend()实现,重新恢复调度则使用xTaskResume() 4. FreeRTOS中断配置4.1 回忆stm32 NVIC中断 比如我们设置为NVIC_PriorityGroup_4时:表示抢占优先级为4bit(即为2^4,为0~15个抢占优先级),副优先级为0bit(表示没有). 4.2 抢占优先级和副优先级的区别: 抢占优先级和副优先级的值越低,则优先级越高 高的抢占优先级的中断可以直接打断低的抢占优先级的中断 高的副优先级的中断不可以打断低的副优先级的中断(只是两个相同抢占优先级的中断同时来的时候,只会优先选择高的副优先级) 4.3 FreeRTOS中断配置宏configKERNEL_INTERRUPT_PRIORITY用来配置中断最低抢占优先级,也就是可以FreeRTOS可以管理的最小抢占优先级,所以使用FreeRTOS时,我们尽量设置stm32为NVIC_PriorityGroup_4,这样就可以管理16个优先级了. configMAX_SYSCALL_INTERRUPT_PRIORITY用来配置FreeRTOS能够安全管理的的最高优先级.比如原子的FreeRTOSConfig.h里就设置为5,而0-4的优先级中断就不会被FreeRTOS因为开关中断而禁止掉(一直都会有),并且不能调用RTOS中的”FromISR”结尾的API函数.比如喂看门狗中断函数就需要设置为0-4. 如下图所示(来自原子手册): 4.3 FreeRTOS中断开关函数 12345portENABLE_INTERRUPTS(); //开中断,将configMAX_SYSCALL_INTERRUPT_PRIORITY至 configKERNEL_INTERRUPT_PRIORITY之间的优先级中断打开portDISABLE_INTERRUPTS(); //关中断,将configMAX_SYSCALL_INTERRUPT_PRIORITY至 configKERNEL_INTERRUPT_PRIORITY之间的优先级中断禁止掉 5.任务常用API函数5.1 xTaskCreate创建任务函数定义如下: 1234567891011xTaskCreate( TaskFunction_t pxTaskCode, //任务函数,用来供给函数指针调用的 const char * const pcName, //任务的字符串别名 const uint16_t usStackDepth, //任务堆栈深度,实际申请到的堆栈是该参数的4倍 void * const pvParameters, //函数参数,用来供给指针调用的 UBaseType_t uxPriority, //优先级,越高优先级高,范围为0~configMAX_PRIORITIES-1 //注意优先级0会创建为空闲任务, 优先级configMAX_PRIORITIES-1会创建一个软件定时器服务任务(管理定时器的) TaskHandle_t * const pxCreatedTask //任务句柄,该句柄可以用于挂起/恢复/删除对应的任务 );//返回值 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(-1):表示创建任务堆空间不足pdPASS(1):创建成功 5.2 taskENTER_CRITICAL()和taskEXIT_CRITICAL()用于任务中进入/退出临界区,调用taskENTER_CRITICAL()主要会关闭其他任务调度.而taskEXIT_CRITICAL()则会恢复任务调度,一般用于初始化外设等. 5.3 taskENTER_CRITICAL_FROM_ISR()和taskEXIT_CRITICAL_FROM_ISR()用于在中断函数中进入/退出临界区,作用和上面一样 5.4 挂起/恢复/删除任务函数1234void vTaskSuspend( TaskHandle_t xTaskToSuspend ); //挂起一个任务,参数为挂起任务的句柄,如果为NULL则表示挂起自身任务void vTaskResume( TaskHandle_t xTaskToResume ); //恢复一个任务BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume);//从中断函数中恢复一个任务,返回1表示恢复成功void vTaskDelete( TaskHandle_t xTaskToDelete ); //删除一个任务,如果从任务函数中退出的话,则需要调用vTaskDelete(NULL)来删除自身任务 5.5 vTaskDelay()延时函数1void vTaskDelay( const TickType_t xTicksToDelay ); //参数表示延时的系统滴答数 比如延时500ms可以写为: vTaskDelay( 500/portTICK_RATE_MS );portTICK_RATE_MS是个宏,表示当前系统的1个滴答需要多少ms,而500/portTICK_RATE_MS则表示当前500ms需要多少个系统滴答数. 6. 队列6.1 简介队列用于任务与任务或者任务与中断之间的通信.比如key任务检测到按键按下时,则可以通过队列向lcd显示任务发送信息,使得lcd切换界面.队列采用先进先出存储机制.队列发送数据可以有两种方式:浅拷贝、深拷贝. 数据量不大的情况下,都使用深拷贝(会分配新的空间,并进行数据拷贝,缺点在于耗时) 数据量大的情况下,都使用浅拷贝(通过指针方式,前提是要发送的数据必须不会被释放的) 6.2 队列的优点队列可以通过任何任务或者中断进行访问,可以随时存取数据消息.并且出入队的时候可以进行任务阻塞,比如某个任务进行读消息出队时,如果没有消息,则可以实现进入休眠状态,直到有消息才唤醒任务. 6.3 队列创建删除相关API123456789101112131415161718QueueHandle_t xQueueCreate( uxQueueLength, uxItemSize ); //动态创建队列,内存会交给RTOS自动分配 // uxQueueLength:队列长度(表示队列中最大多少条消息),uxItemSize:每个队列消息的长度(以字节为单位) //返回值: NULL(0, 表示分配失败),非0(表示返回该队列分配好的地址) //注意:使用自动分配时,需要配置configSUPPORT_DYNAMIC_ALLOCATION宏为1,否则只能由用户来分配.QueueHandle_t xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ); //静态创建队列,内存需要由用户事先分配好 // uxQueueLength:队列长度(表示队列中最大多少条消息),uxItemSize:每个队列消息的长度(以字节为单位) // pucQueueStorage:指向用户事先分配好的存储区内存(必须为uint8_t型) // pxQueueBuffer:指向队列结构体,用来提供给RTOS初始化.然后给用户使用 //返回值: NULL(0, 表示分配失败),非0(表示返回该队列分配好的地址)vQueueDelete( QueueHandle_t xQueue ); //删除队列,并释放空间xQueueReset( xQueue ); //将队列里的消息清空一次,也就是恢复初始状态 6.4队列出入队相关API1234567891011121314151617181920212223242526xQueueSend( xQueue, pvItemToQueue, xTicksToWait ); //插入队尾,和xQueueSendToBack函数效果一致 // xQueue:队列句柄 //PvItemToQueue:消息数据,会通过数据拷贝到队列中,如果想使用浅拷贝,则可以发送一个变量来存储要真正发送的缓冲区地址即可. // xTicksToWait:阻塞时间,单位为RTOS时钟滴答值,如果configTICK_RATE_HZ是1000,则填入的值表示阻塞的是多少ms,否则的话需要通过X/portTICK_RATE_MS来转换一下,才能实现阻塞Xms. //xTicksToWait==0:表示入队满了,则直接退出该函数 // xTicksToWait==portMAX_DELAY:表示一直阻塞,直到队列有空位为止. //注意: INCLUDE_vTaskSuspend宏必须为1,否则任务无法进入休眠状态实现阻塞效果. //返回值: errQUEUE_FULL(队列已满) pdPASS(通过)xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ); //插入队头,参数和上面描述一致xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ); //插入队尾,参数和上面描述一致xQueueOverwrite( xQueue, pvItemToQueue ); //将之前未出队的旧数据全部清空,然后再入队,该函数适用于长度为1的队列xQueueReceive( xQueue, pvBuffer, xTicksToWait ); //从队列头部读出一个消息,并且这个消息会出队(删除掉)xQueuePeek( xQueue, pvBuffer, xTicksToWait ); //从队列头部读出一个消息,但是这个消息不会出队(不会删除) PS:这些API函数只能用于任务里调用,如果要在中断服务函数中调用,则在函数名后添加FromQueue即可,比如xQueueSendFromQueue()函数 6.5 中断发送/读取消息队列时,要注意的事情使用中断相关的读写队列相关的API时,第3个参数是不一样的,比如xQueueSendFromISR(): 1xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) PxHigherPriorityTaskWoken用来标记退出该函数后是否需要进行任务切换,因为我们发送队列时,有可能会将某个阻塞任务退出阻塞态,而此时又在中断中,所以当PxHigherPriorityTaskWoken为pdTRUE时,我们则必须进行一次任务切换. 可以通过portYIELD_FROM_ISR()来进行任务切换,并且我们不需要去判断PxHigherPriorityTaskWoken是否为pdTRUE,因为该函数内部有判断的,如下图所示: 来个中断函数发送队列示例: 123456789101112131415161718extern QueueHandle_t Message_Queue; //信息队列句柄void USART1_IRQHandler(void) //串口1中断服务程序&#123; BaseType_t xHigherPriorityTaskWoken; //定义任务切换标志位 if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; //处理中断接收数据 &#125; if (Message_Queue!=NULL) //判断Message_Queue是否已创建 &#123; xQueueSendFromISR(Message_Queue, RX_BUF,&amp;xHigherPriorityTaskWoken); //向队列Message_Queue中发送RX_BUF portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //通过portYIELD_FROM_ISR()判断是否需要切换任务 &#125;&#125; PS:尽量将portYIELD_FROM_ISR()写在中断函数末尾处 6.6示例-任务之间的伪代码按键任务向打印任务发送按键消息队列,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344QueueHandle_t Key_Queue; //按键值消息队列句柄int main()&#123; //...省略N行代码 Key_Queue = xQueueCreate(1,sizeof(u8)); //创建消息Key_Queue,长度为1 //创建两个任务:key_task()、print_task() //...省略N行代码&#125;key_task() //获取按键值&#123; while(1) &#123; key=KEY_Scan(0); //扫描按键 if((Key_Queue!=NULL)&amp;&amp;(key)) //消息队列Key_Queue创建成功,并且按键被按下 &#123; err=xQueueSend(Key_Queue,&amp;key,10); if(err==errQUEUE_FULL) //发送按键值 &#123; printf("队列Key_Queue已满，数据发送失败!\r\n"); &#125; &#125; vTaskDelay(10); //延时10个时钟节拍 &#125;&#125;print_task() //打印按键值&#123; u8 key; while(1) &#123; if(Key_Queue!=NULL) &#123; if(xQueueReceive(Key_Queue,&amp;key,portMAX_DELAY))//请求消息Key_Queue &#123; printf("key=%d\r\n",key); &#125; &#125; vTaskDelay(10); //延时10个时钟节拍 &#125;&#125; 7. RTOS软件定时器7.1简介在之前的任务创建的时候有讲到过,RTOS会自动创建一个优先级configMAX_PRIORITIES-1的软件定时器服务任务(管理定时器的). 所以我们写一个定时器回调函数时,则会被该定时器服务任务调用,所以在我们软件定时器函数中不能使用** vTaskDelay() **阻塞之类的API函数,否则会将系统中的定时器服务函数给阻塞掉. 7.2 FreeRTOSConfig.h相关的定时器配置1234#define configUSE_TIMERS 1 //为1时启用软件定时器#define configTIMER_TASK_PRIORITY 31 //设置软件定时器优先级可设置的值范围为0~31#define configTIMER_QUEUE_LENGTH 5 //软件定时器队列长度#define configTIMER_TASK_STACK_DEPTH 200 //设置每个软件定时器任务堆栈大小 7.3定时创建相关API1234567TimerHandle_t xTimerCreateStatic( const char * const pcTimerName, //定时器字符串别名 const TickType_t xTimerPeriodInTicks, //需要定时的周期值,比如通过200/ portTICK_RATE_MS来转换实现定时200毫秒 const UBaseType_t uxAutoReload, //是否重载(周期性/单次性),若为pdTRUE(1)表示为周期性,为pdFALSE(0)表示为单次 void * const pvTimerID, //定时器ID号,一般用于多个定时器共用一个定时器回调函数,否则填0即可 TimerCallbackFunction_t pxCallbackFunction //定时器回调函数 ); 12xTimerDelete( xTimer, xTicksToWait ); //删除定时器//xTicksToWait:指定该定时器在多少时钟节拍数之前删除掉,为0则立即删除,一般设为100(如果设为0,则如果在该操作之前还有其它设置定时器操作的话,则不会进行阻塞等待,从而返回false) 7.4 定时器其它常用API12345678910111213xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ); //修改定时器周期,在中断中则使用xTimerChangePeriodFromISR() // xNewPeriod:要修改的周期值 //xTicksToWait:指定该定时器在多少时钟节拍数之前修改好,为0则立即删除 //xTimerReset( xTimer, xTicksToWait ); //复位定时器,让定时器重新计数,在中断中则使用xTimerResetFromISR() // xTicksToWait:和上面内容类似xTimerStart( xTimer, xTicksToWait ); //启动定时器,如果定时器正在运行的话调用该函数的结果和xTimerReset()一样, 在中断中则使用xTimerResetFromISR ()xTimerStop( xTimer, xTicksToWait ); //停止定时器, 在中断中则使用xTimerStopFromISR () PS:在中断中使用定时器API时,同样和队列一样,也需要在函数末尾通过portYIELD_FROM_ISR()进行一次任务切换判断 8. 信号量在项目中我们一般用二值信号量,用来同步数据的. 比如任务A要向任务B发送一个很大的数据buf,而用队列的话会进行复制拷贝,从而占用大量时间. 此时我们不妨定义一个全局数据buf,任务A修改这个buf,发送一个信号量给任务B,任务B就去读取这个全局数据buf即可.从而省去了队列复制拷贝的时间. 8.1定义信号量举例12SemaphoreHandle_t BinarySemaphore; //二值信号量句柄BinarySemaphore=xSemaphoreCreateBinary(); //创建二值信号量 8.2在中断中发送信号量过程123BaseType_t xHigherPriorityTaskWoken;xSemaphoreGiveFromISR(BinarySemaphore,&amp;xHigherPriorityTaskWoken);//发送二值信号量portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //如果需要的话进行一次任务切换 8.3在任务中发送信号量过程1xSemaphoreGive(BinarySemaphore); //返回值: pdPASS(0, 表示发送成功,如果信号量一直未处理,则会返回值失败FULL) 8.4 在任务中接收信号量过程123err = xSemaphoreTake(BinarySemaphore,portMAX_DELAY); //获取信号量// portMAX_DELAY:进入阻塞态一直等待获取//返回值为pdTRUE(OK) pdFALSE(err)]]></content>
      <categories>
        <category>STM32</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32F105RC新建工程，移植FreeRTOS]]></title>
    <url>%2F2019%2F05%2F31%2FSTM32F105RC%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%EF%BC%8C%E7%A7%BB%E6%A4%8DFreeRTOS%2F</url>
    <content type="text"><![CDATA[1. STM32工程创建 注：工程创建方法参照正点原子 1.1 准备 开发环境，Keil MDK 5.26，下载地址 STM32F1 PACK包，下载地址 ST官方标准外设库，目前版本3.5.0，下载地址 开发板 1.2 开始1.2.1 Keil环境安装Keil环境，破解，安装STM32 F1 PACK包 1.2.2 创建工程 创建文件夹为 STM32_F105RC-FreeRTOS 在Template内创建文件夹USER、CORE、OBJ、STM32F10x_FWLib USER 用来存放自己添加的代码 CORE 用来存放核心文件和启动文件 OBJ 是用来存放编译过程文件以及 hex 文件 STM32F10x_FWLib 文件夹顾名思义用来存放 ST 官方提供的库函数源码文件 运行Keil，点击 MDK 的菜单： Project –&gt;New Uvision Project，然后将目录定位到刚才建立的文件夹 STM32_F105RC-FreeRTOS。工程命名为 STM32_F105RC-FreeRTOS，点击保存。 接下来会出现一个选择 CPU 的界面，就是选择我们的芯片型号。STMicroelectronics-&gt;STM32F1 Series-&gt;STM32F105-&gt;STM32F105RCT6 特别注意： 一定要安装对应的器件 pack 才会显示这些内容哦！！ 点击 OK， MDK 会弹出 Manage Run-Time Environment 对话框，直接点击 Cancel。 此时一个框架工程建立完毕，还需要添加启动代码，以及.c 文件等。 修改默认调试工具：魔术棒图标-&gt;Debug-&gt;下拉ST-Link Debugger 修改下载后自动复位运行：魔术棒图标-&gt;Debug-&gt;右侧Setting-&gt;Flash Download-&gt;勾选Reset and Run 调整工程输出文件目录 魔术棒图标-&gt;Output-&gt;Select Folder for Objects…-&gt;选择OBJ目录。同时勾选Create HEX File 魔术棒图标-&gt;Listing-&gt;Select Folder for Objects…-&gt;选择OBJ目录 删除工程目录下的Objects、Listings文件夹 1.2.3 移植固件库包 打开官方固件库包，进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver，将将目录下面的 src，inc 文件夹 copy 到我们刚才建立的 STM32F10x_FWLib 文件夹下面 src 存放的是固件库的.c 文件 inc 存放的是对应的.h 文件 打开官方固件库包，进入目录STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\CoreSupport 下面，将文件 core_cm3.c 和 文件 core_cm3.h 复制到 CORE 内 打开官方固件库包，进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm 下面，将里面 startup_stm32f10x_cl.s 文件复制到 CORE 内 STM32固件库Libraries\CMSIS\Core\CM3\startup\arm中启动文件的文件名英文缩写意义： cl：互联型产品， stm32f105/107 系列 vl：超值型产品， stm32f100 系列 xl：超高密度（容量） 产品， stm32f101/103 系列 ld：低密度产品， FLASH 小于 64K md：中等密度产品， FLASH=64 or 128 hd：高密度产品， FLASH 大于 128 进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x，将文件 stm32f10x.h， system_stm32f10x.c， system_stm32f10x.h，复制到 USER 内 进入目录 STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template，将文件 main.c， stm32f10x_conf.h， stm32f10x_it.c， stm32f10x_it.h 复制到 USER 内 1.2.4 将固件库文件添加到工程 右键点击 Target1，选择 Manage Project Items。 Project Targets 一栏，我们将 Target 名字修改为 STM32_F105RC-FreeRTOS。然后在 Groups 一栏删掉一个 Source Group1，建立三个 Groups： USER,CORE,FWLIB。然后点击 OK。 右键点击点击 STM32_F105RC-FreeRTOS， 选择 Manage Project Itmes， 然后选择需要添加文件的 Group，这里第一步我们选择 FWLIB，然后点击右边的 Add Files,定位到我们刚才建立的目录 STM32F10x_FWLib/src 下面，将里面所有的文件选中(Ctrl+A)，然后点击 Add，然后 Close.可以看到 Files 列表下面包含我们添加的文件。 如果只用到了其中的某个外设，可以不用添加没有用到的外设的库文件。例如只用 GPIO，可以只用添加 stm32f10x_gpio.c 而其他的可以不用添加。这里全部添加进来是为了后面方便，不用每次添加，当然4这样的坏处是工程太大，编译起来速度慢，可以自行选择。 用同样的方法，将 Groups 定位到 CORE 下面，添加需要的文件：core_cm3.c， startup_stm32f10x_hd.s 注意，默认添加的时候文件类型为.c,也就是添加 startup_stm32f10x_hd.s 启动文件的时候，你需要选择文件类型为 All files 才能看得到这个文件 将 Groups 定位到 USER 下面，添加需要的文件：main.c， stm32f10x_it.c，system_stm32f10x.c 点击OK，返回主界面 1.2.5 添加头文件 点击魔术棒-&gt;C/C++-&gt;Include Pash-&gt;点击… 添加目录 ./COER ./USER ./STM32F10x_FWLib/inc 1.2.6 添加宏定义 点击魔术棒-&gt;C/C++-&gt;Define 填入“STM32F10X_CL,USE_STDPERIPH_DRIVER” 不同芯片，STM32F10X_CL后缀不同，具体参见 章节1.3.3 3. 1.2.7 修改main.c将内容改为以下 1234567891011121314151617181920212223242526272829#include "stm32f10x.h"// 简单延时函数void Delay(u32 count)&#123; u32 i=0; for(;i&lt;count;i++);&#125;// 主函数int main(void)&#123; // GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED0--&gt;PD.2 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 口速度为 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); //根据设定参数初始化 GPIOD.2 GPIO_SetBits(GPIOD,GPIO_Pin_2); //PD.2 输出高 // 循环控制D2高低电平 while(1) &#123; GPIO_SetBits(GPIOD,GPIO_Pin_2); Delay(3000000); GPIO_ResetBits(GPIOD,GPIO_Pin_2); Delay(3000000); &#125;&#125; 1.2.8 下载运行LED灯闪烁 1.3 串口打印1.3.1 串口初始化代码 在main.c增加串口初始化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125; 增加Printf映射代码 12345678910111213141516#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125; 包含头文件 1#include &lt;stdio.h&gt; // FILE main()中调用串口初始化，添加printf打印，发现串口打印乱码。找资料说是始终问题。打开stm32f10x.h，找到以下代码，手动定义时钟值 12345678910111213141516/** * @brief In the following line adjust the value of External High Speed oscillator (HSE) used in your application Tip: To avoid modifying this file each time you need to use different HSE, you can define the HSE value in your toolchain compiler preprocessor. */ // 根据板子实际情况手动设置时钟值#define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */#if !defined HSE_VALUE #ifdef STM32F10X_CL #define HSE_VALUE ((uint32_t)25000000) /*!&lt; Value of the External oscillator in Hz */ #else #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* STM32F10X_CL */#endif /* HSE_VALUE */ 修改时钟后，串口正常工作 2. FreeRTOS移植2.1 准备 上一步中建立好的工程 STM32_F105RC-FreeRTOS FreeRTOS源码，运行freertos.exe自解压 2.2 开始2.2.1 移植文件 在 STM32_F105RC-FreeRTOS工程文件夹 中新建文件夹FreeRTOS 进入OS源码路径FreeRTOSv10.2.1\FreeRTOS\Source，将目录内include文件夹，及所有*.c文件复制到刚创建的FreeRTOS文件夹内 这些是平台无关的代码，所有平台都需要使用的 进入OS源码路径FreeRTOSv10.2.1\FreeRTOS\Source\protable\MemMang目录。复制heep_2.c到刚创建的FreeRTOS文件夹内 该目录下是内存管理的相关代码 heep_1.c只能分配内存而不能释放内存。 heep_2.c可以分配和释放内存但不能合并空闲内存块。 heep_3.c简单的封装了线程安全版的标准C语言malloc和free函数。 heep_4.c可以合并相邻的空闲内存块。 heep_5.c可以合并相邻的空闲内存块，且可以管理多个内存。 目标平台是Keil，打开FreeRTOSv10.2.1\FreeRTOS\Source\protable\Keil文件夹看到如下文件“See-also-the-RVDS-directory.txt”。因此打开FreeRTOSv10.2.1\FreeRTOS\Source\portable\RVDS\，根据型号进入目录 \ARM_CM3\，复制文件port.c到刚创建的FreeRTOS文件夹内，复制文件portmacro.h到刚创建的FreeRTOS\include文件夹内 FreeRTOSv10.2.1\FreeRTOS\Source\portable\RVDS路径下有不同的型号，根据实际情况选择 ARM_CA9 ARM_CM0 ARM_CM3 ARM_CM4_MPU ARM_CM4F ARM_CM7 ARM7_LPC21xx 进入路径FreeRTOSv10.2.1\FreeRTOS\Demo，由于使用Keil+STM32F105RC，所以进入CORTEX_STM32F103_Keil，复制FreeRTOSConfig.h到刚创建的FreeRTOS\include文件夹内 2.2.2 将OS文件添加到工程 打开Keil工程，Project Target上右键STM32_F105RC-FreeRTOS，选择 Manage Project Items。 在 Groups 一栏增加 FreeRTOS 分组。然后点击 Add File，将FreeRTOS文件夹内所有*.c添加。 点击OK。 2.2.3 添加头文件 点击魔术棒-&gt;C/C++-&gt;Include Pash-&gt;点击… 添加目录 .\FreeRTOS\include 2.2.4 修改 打开FreeRTOSConfig.h文件，在最后(#endif前)添加宏定义，这些宏将Freertos的这三个回调跟stm32官方的对应起来，这样就不用修改启动文件。 123#define vPortSVCHandler SVC_Handler#define xPortPendSVHandler PendSV_Handler#define xPortSysTickHandler SysTick_Handler 同时需要将stm32f10x_it.c里边对应的三个函数注释掉或者加上weak关键字。 123__weak void SVC_Handler(void)__weak void PendSV_Handler(void)__weak void SysTick_Handler(void) 打开FreeRTOSConfig.h文件，在最后(#endif前)添加宏定义 此宏定义作用未知，不加编译会报错 1#define configUSE_MUTEXES 1 2.2.5 包含头文件在使用FreeRTOS的文件内包含头文件 12345// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量 2.3 测试修改main.c如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include "stm32f10x.h"#include &lt;stdio.h&gt;// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量// 几个打印任务中计数值u32 g_printf1_conter = 0;u32 g_printf2_conter = 0;u32 g_printf3_conter = 0;// 映射Printf相关#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //?úê1ó?printfê±?μí3×??ˉì?ó?′?oˉêy&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125;// 简单延时函数void Delay(u32 count)&#123; static u32 i=0; for(i = 0; i &lt; count; i++);&#125;// 延时1ms（不准确的延时）void Delay_ms(u32 ms)&#123; static u32 i = 0; for(i = 0; i &lt; ms; i++) &#123; Delay(4000); &#125;&#125;// Led IO初始化void Led_Init(void)&#123; // LED GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED2--&gt;PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 速度 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); // IO初始化 GPIO_SetBits(GPIOD, GPIO_Pin_2); // 设置电平PD.2&#125;// Led打开void Led_Open(void)&#123; GPIO_ResetBits(GPIOD,GPIO_Pin_2);&#125;// Led关闭void Led_Close(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_2);&#125;void Led_Test(void *pvParameters)&#123; while(1) &#123; Led_Open(); vTaskDelay( 100/portTICK_RATE_MS ); Led_Close(); vTaskDelay( 100/portTICK_RATE_MS ); &#125;&#125;//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125;void USART_Test1(void *pvParameters)&#123; while(1) &#123; printf("USART 1 hello world %04d\r\n", g_printf1_conter++); vTaskDelay( 500/portTICK_RATE_MS ); &#125;&#125;void USART_Test2(void *pvParameters)&#123; while(1) &#123; printf("USART 2 hello world %04d\r\n", g_printf2_conter++); vTaskDelay( 800/portTICK_RATE_MS ); &#125;&#125;void USART_Test3(void *pvParameters)&#123; while(1) &#123; printf("USART 3 hello world %04d\r\n", g_printf3_conter++); vTaskDelay( 1100/portTICK_RATE_MS ); &#125;&#125;/*-----------------------------------------------------------*/static void prvSetupHardware( void )&#123; SystemInit(); Led_Init(); USART1_init(115200);&#125;/************************************************************/// 主函数/************************************************************/int main(void)&#123; // 初始化硬件平台 prvSetupHardware(); printf("hello world\r\n"); Delay_ms(1000); /* 建立任务 */ xTaskCreate( Led_Test, "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+3, NULL ); xTaskCreate( USART_Test1, "UART1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test2, "UART2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test3, "UART3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); /* 启动OS */ vTaskStartScheduler();&#125; FreeRTOS移植完成，多任务运行基本实现 任务1：100ms设置Led闪烁 任务2：串口每隔500ms打印“USART 1 hello world xxxx” 任务3：串口每隔800ms打印“USART 2 hello world xxxx” 任务4：串口每隔1100ms打印“USART 3 hello world xxxx” 3. FreeRTOS下串口中断接收3.1 main.c代码修改3.1.1 定义变量1xQueueHandle g_xQueueRx; 3.1.2 增加宏定义1#define EN_USART1_RX 1 // 使能了接收 3.1.3 增加串口中断处理函数1234567891011121314#if EN_USART1_RX //如果使能了接收void USART1_IRQHandler(void)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 cChar; if(USART_GetITStatus (USART1,USART_IT_RXNE)!=RESET) &#123; cChar=USART_ReceiveData(USART1); xQueueSendToBackFromISR (g_xQueueRx, &amp;cChar, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); &#125;&#125;#endif 3.1.2 中断向量表配置12345678910111213void NVIC_Configuration(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_4); #if EN_USART1_RX //如果使能了接收 // 配置串口1中断向量 NVIC_InitStructure .NVIC_IRQChannel =USART1_IRQn ; NVIC_InitStructure .NVIC_IRQChannelPreemptionPriority =6; NVIC_InitStructure .NVIC_IRQChannelCmd =ENABLE ; NVIC_Init(&amp;NVIC_InitStructure );#endif&#125; 3.1.3 串口接收任务创建12345678910111213141516void vPC_Communication_Task(void *pvParameters)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 rx=0; g_xQueueRx = xQueueCreate(20,sizeof(u8)); while(1) &#123; if(xQueueReceiveFromISR(g_xQueueRx, &amp;rx, &amp;xHigherPriorityTaskWoken)) &#123; printf("%c\r\n", rx); &#125; vTaskDelay(10/portTICK_RATE_MS ); &#125;&#125; 3.1.4 增加NVIC初始化在函数static void prvSetupHardware( void )中，增加 1NVIC_Configuration(); 3.1.5 增加创建任务1xTaskCreate( vPC_Communication_Task, "UART_RECV", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); 3.2 最终main.c如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include "stm32f10x.h"#include &lt;stdio.h&gt;// FreeRTOS相关头文件#include "FreeRTOS.h"#include "task.h" // 创建任务#include "queue.h" // 队列操作#include "semphr.h" // 信号量#define EN_USART1_RX 1// 几个打印任务中计数值u32 g_printf1_conter = 0;u32 g_printf2_conter = 0;u32 g_printf3_conter = 0;xQueueHandle g_xQueueRx;#define EN_USART1_RX 1 // 使能了接收// 映射Printf相关#pragma import(__use_no_semihosting)struct __FILE&#123; int handle;&#125;;FILE __stdout;void _sys_exit(int x)&#123; x = x;&#125;int fputc(int ch,FILE *p) //?úê1ó?printfê±?μí3×??ˉì?ó?′?oˉêy&#123; USART_SendData(USART1,(u8)ch); while(USART_GetFlagStatus(USART1, USART_FLAG_TXE)==RESET); return ch;&#125;// 简单延时函数void Delay(u32 count)&#123; static u32 i=0; for(i = 0; i &lt; count; i++);&#125;// 延时1ms（不准确的延时）void Delay_ms(u32 ms)&#123; static u32 i = 0; for(i = 0; i &lt; ms; i++) &#123; Delay(4000); &#125;&#125;// Led IO初始化void Led_Init(void)&#123; // LED GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //LED2--&gt;PD.2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO 速度 50MHz GPIO_Init(GPIOD, &amp;GPIO_InitStructure); // IO初始化 GPIO_SetBits(GPIOD, GPIO_Pin_2); // 设置电平PD.2&#125;// Led打开void Led_Open(void)&#123; GPIO_ResetBits(GPIOD,GPIO_Pin_2);&#125;// Led关闭void Led_Close(void)&#123; GPIO_SetBits(GPIOD,GPIO_Pin_2);&#125;void Led_Test(void *pvParameters)&#123; while(1) &#123; Led_Open(); vTaskDelay( 100/portTICK_RATE_MS ); Led_Close(); vTaskDelay( 100/portTICK_RATE_MS ); &#125;&#125;//初始化 IO 串口1//bound: 波特率void USART1_init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure;#if EN_USART1_RX //如果使能了接收 NVIC_InitTypeDef NVIC_InitStructure;#endif //①串口时钟使能， GPIO 时钟使能，复用时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //②串口复位 //USART_DeInit(USART1); //复位串口 1 //③GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.10 //④串口参数初始化 USART_InitStructure.USART_BaudRate = bound; //波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位 USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口#if EN_USART1_RX //如果使能了接收 //⑤初始化 NVIC NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能 NVIC_Init(&amp;NVIC_InitStructure); //中断优先级初始化 //⑤开启中断 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断#endif //⑥使能串口 USART_Cmd(USART1, ENABLE); //使能串口&#125;void USART_Test1(void *pvParameters)&#123; while(1) &#123; printf("USART 1 hello world %04d\r\n", g_printf1_conter++); vTaskDelay( 500/portTICK_RATE_MS ); &#125;&#125;void USART_Test2(void *pvParameters)&#123; while(1) &#123; printf("USART 2 hello world %04d\r\n", g_printf2_conter++); vTaskDelay( 800/portTICK_RATE_MS ); &#125;&#125;void USART_Test3(void *pvParameters)&#123; while(1) &#123; printf("USART 3 hello world %04d\r\n", g_printf3_conter++); vTaskDelay( 1100/portTICK_RATE_MS ); &#125;&#125;#if EN_USART1_RX //如果使能了接收void USART1_IRQHandler(void)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 cChar; if(USART_GetITStatus (USART1,USART_IT_RXNE)!=RESET) &#123; cChar=USART_ReceiveData(USART1); xQueueSendToBackFromISR (g_xQueueRx, &amp;cChar, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); &#125;&#125;#endifvoid NVIC_Configuration(void)&#123; NVIC_InitTypeDef NVIC_InitStructure; NVIC_PriorityGroupConfig (NVIC_PriorityGroup_4); #if EN_USART1_RX //如果使能了接收 // 配置串口1中断向量 NVIC_InitStructure .NVIC_IRQChannel =USART1_IRQn ; NVIC_InitStructure .NVIC_IRQChannelPreemptionPriority =6; NVIC_InitStructure .NVIC_IRQChannelCmd =ENABLE ; NVIC_Init(&amp;NVIC_InitStructure );#endif&#125;void vPC_Communication_Task(void *pvParameters)&#123; BaseType_t xHigherPriorityTaskWoken; xHigherPriorityTaskWoken = pdFALSE; u8 rx=0; g_xQueueRx = xQueueCreate(20,sizeof(u8)); while(1) &#123; if(xQueueReceiveFromISR(g_xQueueRx, &amp;rx, &amp;xHigherPriorityTaskWoken)) &#123; printf("%c\r\n", rx); &#125; vTaskDelay(10/portTICK_RATE_MS ); &#125;&#125;/*-----------------------------------------------------------*/static void prvSetupHardware( void )&#123; SystemInit(); NVIC_Configuration(); Led_Init(); USART1_init(115200);&#125;/************************************************************/// 主函数/************************************************************/int main(void)&#123; // 初始化硬件平台 prvSetupHardware(); printf("hello world\r\n"); Delay_ms(1000); /* 建立任务 */ xTaskCreate( Led_Test, "LED", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+3, NULL ); xTaskCreate( USART_Test1, "UART1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test2, "UART2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( USART_Test3, "UART3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); xTaskCreate( vPC_Communication_Task, "UART_RECV", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL ); /* 启动OS */ vTaskStartScheduler();&#125;]]></content>
      <categories>
        <category>STM32</category>
        <category>FreeRTOS</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo新建文章]]></title>
    <url>%2F2019%2F05%2F31%2FHexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo server 本地测试，访问http://localhost:4000 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 将文章收缩显示1&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装及关联账户]]></title>
    <url>%2F2019%2F05%2F31%2FGit%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%B3%E8%81%94%E8%B4%A6%E6%88%B7%2F</url>
    <content type="text"><![CDATA[安装git 下载git，地址 安装git，默认安装 创建公钥，关联git 安装git后，右键会多出“Git GUI Here”“Git Bash Here”，选择“Git Bash Here”，弹出窗口 执行： cd ~/.ssh 如果返回“… No such file or directory”，说明没有生成过SSH Key，直接进入第4步。否则进入第3步备份! 备份： mkdir key_backup mv id_isa* key_backup 生成新的Key：（引号内的内容替换为你自己的邮箱） ssh-keygen -t rsa -C “your_email@youremail.com“ 输出显示： Generating public/private rsa key pair. Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa): 直接回车，不要修改默认路劲。 Enter passphrase (empty for no passphrase):Enter same passphrase again: 设置一个密码短语，在每次远程操作之前会要求输入密码短语！闲麻烦可以直接回车，不设置。 成功： Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.The key fingerprint is:… … 提交公钥： 6.1 找到.ssh文件夹，用文本编辑器打开“id_rsa.pub”文件，复制内容到剪贴板。 6.2 打开 https://github.com/settings/ssh ，点击 Add SSH Key 按钮，粘贴进去保存即可。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2019%2F05%2F06%2Farticle-title%2F</url>
    <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <tags>
        <tag>Cmd Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[STM32 Can id过滤]]></title>
    <url>%2F2019%2F04%2F08%2FSTM32%20Can%20id%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728CAN_FilterInitTypeDef CAN_FilterInitStructure; u32 slave_id = 0x1C1F1700; // 0b ‭0001 1100 0001 1111 0001 0111 0000 0000‬// 0b 0001 1111 1111 1111 1111 1111 0000 0000// slave_id &amp;lt;&amp;lt; 3 0b ‭1110 0000 1111 1000 1011 1000 0000 0‬000// 0b 1111 1111 1111 1111 1111 1000 0000 0*** /* CAN 过滤器组初始化 */CAN_FilterInit(&amp;amp;CAN_FilterInitStructure); //初始化CAN_FilterInitStructrue结构体变量CAN_FilterInitStructure.CAN_FilterNumber = 0; //设置过滤器组0，范围为0~13CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask; //设置过滤器组0为屏蔽模式CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;//设置过滤器组0位宽为32位#if 0 // 不设置过滤CAN_FilterInitStructure.CAN_FilterIdHigh = 0x0000; //设置标识符寄存器高字节CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000; //设置标识符寄存器低字节CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x0000; //设置屏蔽寄存器高字节CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000; //设置屏蔽寄存器低字节#else//寄存器的设置CAN_FilterInitStructure.CAN_FilterIdHigh = ((slave_id &amp;lt;&amp;lt; 3) &amp;gt;&amp;gt; 16) &amp;amp;0xffff; // 设置标识符寄存器高字节CAN_FilterInitStructure.CAN_FilterIdLow = (u16)(slave_id &amp;lt;&amp;lt; 3) | CAN_ID_EXT;// 设置标识符寄存器低字节CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0xffff; //设置屏蔽寄存器高字节CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x8003; //设置屏蔽寄存器低字节#endifCAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;//过滤器关联邮箱0CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;//激活过滤器CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE); //使能CAN接收中断CAN_FilterInit(&amp;amp;CAN_FilterInitStructure); // 设置过滤器]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keil设置]]></title>
    <url>%2F2019%2F03%2F04%2FKeil%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Keil设置下载程序后自动运行 设置字体颜色设置字体颜色主题参照https://blog.csdn.net/qq_20553613/article/details/79615293 设置Tab键设置Tab键参照https://blog.csdn.net/dianzilaoshu/article/details/72457276 中Keil部分]]></content>
      <categories>
        <category>Keil</category>
      </categories>
      <tags>
        <tag>Keil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“魔术师地毯”类问题]]></title>
    <url>%2F2019%2F02%2F27%2F%E2%80%9C%E9%AD%94%E6%9C%AF%E5%B8%88%E5%9C%B0%E6%AF%AF%E2%80%9D%E7%B1%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[魔术师地毯里，蓝色三角形和红色三角形根本就不是相似三角形，蓝色直角边2:5，红色3:8，他们组成的大图形不是三角形，是四边形，上面长边往里凹，下面的往外凸]]></content>
  </entry>
  <entry>
    <title><![CDATA[STM32 APB1 APB2]]></title>
    <url>%2F2019%2F02%2F26%2FSTM32-APB1-APB2%2F</url>
    <content type="text"><![CDATA[STM32F103系列运行主频为72MHz 据参考手册有：APB1操作速度限于36MHz， APB2操作于全速(最高72MHz)。 APB2负责AD，I/O，高级TIM，串口1； APB1负责DA，USB，SPI，I2C，CAN，串口2345，普通TIM；]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vivado 2016.4 固化]]></title>
    <url>%2F2019%2F02%2F15%2FVivado-2016-4-%E5%9B%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. bit文件生成mcs文件在vivado2016版本之后，可以直接通过操作来生成mcs文件 2. 固化mcs文件]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 异或和校验]]></title>
    <url>%2F2019%2F02%2F14%2FC%20%E5%BC%82%E6%88%96%E5%92%8C%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617//异或校验运算/** const unsigned char *buf 需要运算的buf数组* int id_end 需要运算的buf结尾位置* int id_start = 0 需要预算的buf开始位置，默认为0*/int xor16(const unsigned char *buf, int id_end, int id_start = 0)&#123; int check_buf = 0; int i; for (i = id_start; i &amp;lt; id_end; i++) &#123; check_buf ^= (int)buf[i]; &#125; return check_buf;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SN]]></title>
    <url>%2F2018%2F12%2F12%2FSN%2F</url>
    <content type="text"><![CDATA[DDSM3617 6.1.7 DEZTW73LF1S9D DDSM918+ 6.2.1 DXVTDO4IGF8S5]]></content>
  </entry>
  <entry>
    <title><![CDATA[U盘芯片信息]]></title>
    <url>%2F2018%2F12%2F08%2FU%E7%9B%98%E8%8A%AF%E7%89%87%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[闪迪 酷豆 8G 芯片信息 逻辑盘符 : H:\ 此分区容量: 7.4G设备ID : VID = 0781 PID = 5571设备序列号: 4C530001060105112245设备版本 : 1.00 设备制造商: SanDisk设备型号 : Cruzer Fit当前协议 : USB2.0(连接到USB3端口可以获得更高性能)输入电流 : 224mA 分区系统 : FAT32 是否激活 : 否是否对齐 : 1024 KB 已扇区对齐 网络异常,查询主控信息失败! 系统版本 : Windows 8 Personal 金士顿16G逻辑盘符 : H:\ 此分区容量: 14.4G设备ID : VID = 0930 PID = 6545设备序列号: C86000BDB93EB0907A20EBA6设备版本 : PMAP 设备制造商: Kingston设备型号 : DataTraveler 2.0当前协议 : USB2.0输入电流 : 300mA 分区系统 : FAT32 是否激活 : 是是否对齐 : 128 KB 已扇区对齐 芯片制造商: 群联(Phison)芯片型号 : PS2251-68闪存颗粒 : 东芝(Toshiba) (打开网络可以获取详细信息)固件版本 : 02.02.55 固件日期: 2015.06.12 工具下载 : http://www.upan.cc/tools/mass/Phison/系统版本 : Windows 8 Personal]]></content>
  </entry>
  <entry>
    <title><![CDATA[外网SMB端口映射]]></title>
    <url>%2F2018%2F11%2F28%2F%E5%A4%96%E7%BD%91SMB%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[开启端口映射，从外网访问内网的文件共享：SMB 已经在路由器里开了远端WEB管理设了端口，另外端口映射局域网里的一台电脑，比如WEB端口设的是8080，映射192.168.1.100到4877端口，现在我想访问局域网的共享文件，怎么弄？以前我的做法是远程控制软件比如teamviewer或者radmin控制内网一台电脑后再通过其访问内网，缺点是要装软件，有办法直接通过网关访问内网共享文件夹吗？ Samba服务所使用的端口和协议： Port 137 (UDP) – NetBIOS 名字服务 ； nmbd Port 138 (UDP) – NetBIOS 数据报服务 Port 139 (TCP) – 文件和打印共享 ； smbd （基于SMB(Server Message Block)协议，主要在局域网中使用，文件共享协议） Port 389 (TCP) – 用于 LDAP (Active Directory Mode) Port 445 (TCP) – NetBIOS服务在windos 2000及以后版本使用此端口, (Common Internet File System，CIFS，它是SMB协议扩展到Internet后，实现Internet文件共享) Port 901 (TCP) – 用于 SWAT，用于网页管理Samba 以下为原理：WinXP共享需要137、138、139，445 137端口这个端口是用来请求NetBios名到IP地址达。比如有人喊“123计算机您共享C盘下的ABC.doc这个文件的IP地址是多少”。于是这个呐喊被广播，只有IP地址是123的回答了。 138端口这个端口是您浏览[网络邻居]用达。您网络里有台计算机叫主浏览器计算机维护着共享列表。所以这个端口封了也就不能通过[网络邻居]来查看其他计算机喽。当然并不防碍彼此通信。 139、445端口通信计算机得到了对方的IP地址以后，就用139或者445端口开始通讯了。如果不是域环境，就是SMB调用139端口通讯。如果是域环境，就是CIFS调用445端口通讯。如果您不想别人访问您的文件呢，就把这两个关闭掉。 这样做只能从外网访问内网中的一台机器共享，因为路由器的对外IP是唯一的。若要访问更多内网共享，只能建FTP，或者VPN之类的，但这种方法是最简单的，不需要在共享机器上有额外的软件设置，只需要路由器设置好即可！！！]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有道云笔记：登陆错误]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%99%BB%E9%99%86%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[错误提醒：请检查IE浏览器是否设置了“阻断所有Cookie”？…… 打开“Internet属性”-&gt;“安全”-&gt;“Internet”-&gt;“该区域的安全级别”：由高改为中高]]></content>
      <tags>
        <tag>有道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 开启多用户远程登陆（远程桌面）]]></title>
    <url>%2F2018%2F11%2F21%2FWin10-%E5%BC%80%E5%90%AF%E5%A4%9A%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%88%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Win10 开启多用户远程登陆（远程桌面）系统Win10专业版，已激活 1. 添加用户桌面“此电脑”-&gt;右键“管理” 计算器管理-&gt;本地用户和组-&gt;用户 “用户”-&gt;右键“新用户”填写用户名，密码。去除“用户下次登陆更改密码”，勾选“密码永不过期” 2. 添加远程桌面用户桌面“此电脑”-&gt;右键“属性”-&gt;“远程设置” “系统属性”-&gt;“远程”“远程桌面”-&gt;选择“允许远程连接到此计算机”-&gt;点击“选择用户” “远程桌面用户” 3. 编辑本地组策略win10 左下角搜索栏中 输入 gpedit 打开本地组策略编辑器 选择【计算器配置】-&gt;【管理模板】-&gt;【Windows组件】-&gt;【远程桌面服务】-&gt;【远程桌面会话主机】-&gt;【连接】 限制连接的数量配置 【限制连接的数量】，允许的RD最大连接数 即为最大的连接数量 将远程桌面服务用户限制到单独的远程桌面服务会话配置【将远程桌面服务用户限制到单独的远程桌面服务会话】，改成 “已禁用”/“已启用”“已禁用”：代表一个用户可以多次同时登陆桌面“已启用”：代表一个用户同时只能登陆一个桌面 4. 解除Win10对连接数量限制使用工具 rdpwrap，项目地址，下载页面下载后运行“install.bat”，然后运行“RDPConf.exe”。如果全绿则破解成功；如果出现“Listening [not supported]”则还需运行update.bat]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库下载]]></title>
    <url>%2F2018%2F11%2F15%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[请输入密码. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>文库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++列出当前路径下所有文件名及子文件夹内文件名]]></title>
    <url>%2F2018%2F11%2F14%2FC-C-%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D%E5%8F%8A%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E6%96%87%E4%BB%B6%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在Win10下，使用VS2015测试可用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;io.h&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt; #include &lt;direct.h&gt; // getcwd();#include &lt;conio.h&gt; // getch(); using namespace std; //获取所有的文件名void GetAllFiles(string path, vector&lt;string&gt;&amp; files)&#123; //printf("\033[1A"); //先回到上一行 //printf("\033[K"); //清除该行 cout &lt;&lt; path &lt;&lt; endl; // 打印当前检索路径 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string p; if ((hFile = _findfirst(p.assign(path).append("\\*").c_str(), &amp;fileinfo)) != -1) &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); GetAllFiles(p.assign(path).append("\\").append(fileinfo.name), files); &#125; &#125; else &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125; &#125; //获取特定格式的文件名void GetAllFormatFiles(string path, vector&lt;string&gt;&amp; files, string format)&#123; //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; // string p; if ((hFile = _findfirst(p.assign(path).append("\\*" + format).c_str(), &amp;fileinfo)) != -1) &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) &#123; //files.push_back(p.assign(path).append("\\").append(fileinfo.name) ); GetAllFormatFiles(p.assign(path).append("\\").append(fileinfo.name), files, format); &#125; &#125; else &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125;&#125; // 该函数有两个参数，第一个为路径字符串(string类型，最好为绝对路径)；// 第二个参数为文件夹与文件名称存储变量(vector类型,引用传递)。// 在主函数中调用格式(并将结果保存在文件"AllFiles.txt"中，第一行为总数)： int main()&#123; /****************************** 获取当前工作路径 *******************************/ char *cCurrentWorkingPath; cCurrentWorkingPath = _getcwd(NULL, 0); if (cCurrentWorkingPath == NULL) &#123; cout &lt;&lt; "getcwd error" &lt;&lt; endl; return 1; &#125; cout &lt;&lt; "Current Working Path:(\"" &lt;&lt; cCurrentWorkingPath &lt;&lt; "\")" &lt;&lt; endl; cout &lt;&lt; "Press any key to start searching" &lt;&lt; endl &lt;&lt; endl; int flag = _getch(); //_getch(); /****************************** 检索文件 *******************************/ string sCurrentWorkingPath = cCurrentWorkingPath; vector&lt;string&gt; fileName; // string容器，用于存放文件名（绝对路径） char * distAll = "outAllFileName.txt"; cout &lt;&lt; "Retrieving folder:" &lt;&lt; endl; //读取所有的文件，包括子文件夹的文件 GetAllFiles(sCurrentWorkingPath, fileName); //读取所有格式为jpg的文件 //string format = ".jpg"; //GetAllFormatFiles(sCurrentWorkingPath, fileName, format); int size = fileName.size(); cout &lt;&lt; "A total of "&lt;&lt; size &lt;&lt;" files/folders were retrieved"&lt;&lt; endl; /****************************** 输出文件名 *******************************/ cout &lt;&lt; "1. Print all file names to the screen and save to file" &lt;&lt; endl; cout &lt;&lt; "2. Print all file names to the screen" &lt;&lt; endl; cout &lt;&lt; "3. Save all file names to the file" &lt;&lt; endl; cout &lt;&lt; "Please enter the serial number:" &lt;&lt; endl; flag = _getch(); //_getch(); ofstream ofn(distAll); switch (flag) &#123; case '1': ofn &lt;&lt; size &lt;&lt; endl; for (int i = 0; i&lt;size; i++) &#123; ofn &lt;&lt; fileName[i] &lt;&lt; endl; cout &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; case '2': for (int i = 0; i&lt;size; i++) &#123; cout &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; case '3': cout &lt;&lt; "Writting......" &lt;&lt; endl; ofn &lt;&lt; size &lt;&lt; endl; for (int i = 0; i&lt;size; i++) &#123; ofn &lt;&lt; fileName[i] &lt;&lt; endl; &#125; break; default: break; &#125; ofn.close(); free(cCurrentWorkingPath); /****************************** 结束 *******************************/ cout &lt;&lt; "Press any key to end" &lt;&lt; endl; //getchar(); _getch(); return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS设置静态编译]]></title>
    <url>%2F2018%2F11%2F02%2FVS%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[代码有时依赖一些特殊的库，为保证运行，设置为“静态编译”，直接将所需要的系统动态库包含到exe文件中，这样在新电脑上就不会存在缺少动态库问题。设置方法：“项目-&gt;属性-&gt;配置属性-&gt;常规-&gt;MFC的使用：在静态库中使用MFC”]]></content>
      <categories>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宝塔环境下，设置OneIndex伪静态]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%AE%9D%E5%A1%94%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E8%AE%BE%E7%BD%AEOneIndex%E4%BC%AA%E9%9D%99%E6%80%81%2F</url>
    <content type="text"><![CDATA[123456789if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break;&#125;if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php;&#125;if (!-f $request_filename)&#123; rewrite (.*) /index.php;&#125;]]></content>
      <categories>
        <category>宝塔</category>
      </categories>
      <tags>
        <tag>宝塔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OneDrive]]></title>
    <url>%2F2018%2F10%2F26%2FOneDrive%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX19COAGIvvyg41ojvcjabt4OeAHP2RvghQeJYFR9tfD8SUJEjb3dM1csBCeYdwRQZ7Wfomx1OGRSkoS1NDY6y6BSItYKeUsauAXtP74f8ngl8jemP3/yyN9WNTPmV+WhiHHBDHmLFNb8M+1zMTJJqlvIkSC5dP4YFO6RmuamFev+CAn4ptrAVD1yjT88E7oN0LiVVyQTk9OiUlQBCMhadF/oljBY02lWfmc71SBkEwEQ2hJuPotKTUgDikRCMZi5LikVr8pQR91LkT2DF6EoSepmi2s0McZ4YQdru2JvAk5Xmnlz2pXrLZhWuLniyACsRn2G4kTiouv+21p14Y1LkojsCqgWGiUyKzQ+/APjaUnh0ghU8HZKwbxaJwyfD0h9vjHPuNqJ0euZTcWmOy+GZQy1YmmYxOT3C+42atGhn768LrLSxdmaKAzfsR5rHOF7c2vjXh+pcOGur/MgMA8c9IaWQmzvSNLUrlToO0aurk43ufB54WCxiFleSTDIKMAYwbwA2HEAN1kEMvipqyCdLTdSkuOQ+hV9Oh0P9tOobkLg1jO3ARBfnWVgzf/LfENhKV0D4zr0BcVwFV+TGfUhs7bRZpf0jOYKLoI+DlsnVEBhvj8VTKH9J/kfCHm1nvh+Ftt67WoSNf5s+g==]]></content>
      <categories>
        <category>OneDrive</category>
      </categories>
      <tags>
        <tag>OneDrive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录站点运行时间html]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%AE%B0%E5%BD%95%E7%AB%99%E7%82%B9%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4html%2F</url>
    <content type="text"><![CDATA[记录站点运行时间html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;显示XX年XX天XX时XX秒，秒数显示为一秒一秒的走动&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!----&gt; &lt;br /&gt; 网站稳定运行： &lt;span id="htmer_time" style="color: crimson;"&gt;&lt;/span&gt; &lt;!--JavaScript部分--&gt; &lt;script&gt; function secondToDate(second)&#123; if(!second) &#123;return 0;&#125; var time = new Array(0, 0, 0, 0, 0); if(second &gt;= 365 * 24 * 3600) &#123; time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; &#125; if(second &gt;= 24 * 3600) &#123; time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; &#125; if(second &gt;= 3600) &#123; time[2] = parseInt(second / 3600); second %= 3600; &#125; if(second &gt;= 60) &#123; time[3] = parseInt(second / 60); second %= 60; &#125; if(second &gt; 0) &#123; time[4] = second; &#125; return time; &#125; &lt;/script&gt; &lt;script type="text/javascript" language="javascript"&gt; function setTime() &#123; var create_time = Math.round(new Date(Date.UTC(2018, 4, 10, 00, 00, 00)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = currentTime[0] + '年' + currentTime[1] + '天' + currentTime[2] + '时' + currentTime[3] + '分' + currentTime[4] + '秒'; document.getElementById("htmer_time").innerHTML = currentTimeHtml; &#125; setInterval(setTime, 1000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>站点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1024]]></title>
    <url>%2F2018%2F10%2F24%2F1024%2F</url>
    <content type="text"><![CDATA[1024]]></content>
  </entry>
  <entry>
    <title><![CDATA[Qt关闭按钮事件closeEvent]]></title>
    <url>%2F2018%2F09%2F26%2FQt%E5%85%B3%E9%97%AD%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6closeEvent%2F</url>
    <content type="text"><![CDATA[在对应头文件中包含QCloseEvent12#include &lt;QMessageBox&gt;#include &lt;QCloseEvent&gt; 在对应头文件对应类中添加 123protected: //这是一个虚函数，继承自QEvent.只要重写了这个虚函数，当你按下窗口右上角的"×"时，就会调用你所重写的此函数. void closeEvent(QCloseEvent*event); 在对应.cpp文件中添加 123456789101112131415161718void Widget::closeEvent(QCloseEvent* event)&#123; //跳出信息框，你是否要关闭. auto temp = QMessageBox::information(this, "Warning", tr("你是否要关闭?"), QMessageBox::Yes | QMessageBox::No); if (temp == QMessageBox::Yes) &#123; // 接受了 要关闭这个窗口的事件. accept和ignore只是作为一个标志. event-&gt;accept(); &#125; else &#123; //忽略了 要关闭这个窗口的事件.当前窗口就不会被关闭. event-&gt;ignore(); &#125;&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt QSettings 配置文件]]></title>
    <url>%2F2018%2F09%2F21%2FQt-QSettings-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637QSettings *m_config; // 配置文件名，若文件不存在则会自动创建; 文件格式：*.ini格式的配置文件m_config = new QSettings("Config.ini",QSettings::IniFormat); // 进入节点：若节点存在则进入；若不存在则创建后进入 （与endGroup配套使用）m_config-&gt;beginGroup("com1"); //可以理解为进入到 节 com1 m_config-&gt;setValue("baud1","115200"); // 设置键值，若键已存在则修改值；若键不存在则创建键后设置值 if(!m_config-&gt;childKeys().contains("baud"))//判断节com1中是否存在键 baud&#123; m_config-&gt;setValue("baud","9600"); //若不存在则创建并赋值为9600&#125;else&#123; QString baud = m_config-&gt;value("baud").toString(); //存在则取出键baud的值 qDebug()&lt;&lt; "---com1 baud = " &lt;&lt; baud;&#125;m_config-&gt;endGroup(); //beginGroup后必须endGroup ，可以理解为退出com1 m_config-&gt;setValue("com2/baud",38400); //直接设置节com2下键baud的值：如果不存在节com2或键baud则创建qDebug()&lt;&lt;"***com2 baud = "+m_config-&gt;value("com2/baud").toString(); if(!m_config-&gt;contains("com5/baud")) // 判断是否存在&#123; m_config-&gt;setValue("com5/baud",19200); //不存在则创建则赋初值&#125;else&#123; int baud = m_config-&gt;value("com5/baud").toInt();&#125; if(!m_config-&gt;contains("com8")) //判断节com8是否存在 但不会创**************&#123; &#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ GPIO（EMIO）中断]]></title>
    <url>%2F2018%2F09%2F20%2FZYNQ-GPIO%EF%BC%88EMIO%EF%BC%89%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[PL侧PL侧GPIO设置 EMIO0设置为输入（PS侧读EMIO0状态高/低） EMIO1设置为输出（PS侧写EMIO1为高/低） 连接EMIO0、EMIO1 EMIO[63:32]中存放中断响应时间，供PS侧读取 流程 PS侧写EMIO1值为1，使EMIO0值更新为1 EMIO0由0à1，触发PS侧中断（PS侧在进入中断后，会将EMIO1重新写为0，EMIO0也随之变为0） EMIO[63:32]中存放EMIO0高电平持续时间（拍数，时钟100MHz），及从中断产生到中断响应的时间 PS侧PS侧GPIO设置 EMIO0（GPIO54）设置为输入 EMIO1（GPIO55）设置为输出 EMIO[63:32]设置为输入 配置EMIO0相关中断设置 主函数中，每隔5s将EMIO1值写1（在PL侧，EMIO1变为1后，会关联EMIO0也变为1） EMIO0变为1，触发中断，进入中断服务函数 在中断服务函数中，将EMIO1写为0（PL侧，EMIO0也随之变为0，并统计中断响应时间，将时间存放在EMIO[63:32]中） 读取EMIO[63:32]，获取中断响应时间 PS侧C代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371/******************************************************************************** Copyright (C) 2009 - 2014 Xilinx, Inc. All rights reserved.** Permission is hereby granted, free of charge, to any person obtaining a copy* of this software and associated documentation files (the "Software"), to deal* in the Software without restriction, including without limitation the rights* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the Software is* furnished to do so, subject to the following conditions:** The above copyright notice and this permission notice shall be included in* all copies or substantial portions of the Software.** Use of the Software is limited solely to applications:* (a) running on a Xilinx device, or* (b) that interact with a Xilinx device through a bus or interconnect.** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL* XILINX BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE* SOFTWARE.** Except as contained in this notice, the name of the Xilinx shall not be used* in advertising or otherwise to promote the sale, use or other dealings in* this Software without prior written authorization from Xilinx.*******************************************************************************/ /* * helloworld.c: simple test application * * This application configures UART 16550 to baud rate 9600. * PS7 UART (Zynq) is not initialized by this application, since * bootrom/bsp configures it to baud rate 115200 * * ------------------------------------------------ * | UART TYPE BAUD RATE | * ------------------------------------------------ * uartns550 9600 * uartlite Configurable only in HW design * ps7_uart 115200 (configured by bootrom/bsp) */ #include &lt;stdio.h&gt;#include "platform.h"#include "xil_printf.h"#include "xparameters.h"#include "xgpiops.h"#include "xscugic.h"#include "xil_exception.h"#include "xplatform_info.h"#include &lt;xil_printf.h&gt;#include "sleep.h" /************************** Constant Definitions *****************************//* * The following constants map to the names of the hardware instances that * were created in the EDK XPS system. They are defined here such that * the user can easily change all the needed device IDs in one place. */#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID // 0#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID // 0U#define GPIO_INTERRUPT_ID XPAR_XGPIOPS_0_INTR // 52U /************************** Function Prototypes ******************************/ static int GpioIntrExample(XScuGic *Intc, XGpioPs *Gpio, u16 DeviceId,u16 GpioIntrId);static void IntrHandler(void *CallBackRef, u32 Bank, u32 Status);static int SetupInterruptSystem(XScuGic *Intc, XGpioPs *Gpio, u16 GpioIntrId); /************************** Variable Definitions *****************************/ /* * The following are declared globally so they are zeroed and so they are * easily accessible from a debugger. */static XGpioPs g_Gpio; /* The Instance of the GPIO Driver */ static XScuGic g_Intc; /* The Instance of the Interrupt Controller Driver */ static u32 g_Input_Pin; /* Switch button */static u32 g_Output_Pin; /* LED button */ int main()&#123; int Status; u32 WriteValue = 0; u32 ReadValue = 0; init_platform(); print("******** Hello World ********\n\r"); /* * Run the GPIO interrupt example, specify the parameters that * are generated in xparameters.h. */ Status = GpioIntrExample(&amp;g_Intc, &amp;g_Gpio, GPIO_DEVICE_ID, GPIO_INTERRUPT_ID); if (Status != XST_SUCCESS) &#123; xil_printf("GPIO Interrupt Example Test Failed\r\n"); return XST_FAILURE; &#125; xil_printf("Successfully ran GPIO Interrupt Example Test\r\n"); while(1) &#123;#if 0 WriteValue = 0; XGpioPs_WritePin(&amp;g_Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(&amp;g_Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5); WriteValue = 1; XGpioPs_WritePin(&amp;g_Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(&amp;g_Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5);#else WriteValue = 1; XGpioPs_WritePin(&amp;g_Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(&amp;g_Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5);#endif &#125; cleanup_platform(); return 0;&#125; /****************************************************************************//*** This function shows the usage of interrupt fucntionality of the GPIO device.* It is responsible for initializing the GPIO device, setting up interrupts and* providing a foreground loop such that interrupts can occur in the background.** @param Intc is a pointer to the XScuGic driver Instance.* @param Gpio is a pointer to the XGpioPs driver Instance.* @param DeviceId is the XPAR_&lt;Gpio_Instance&gt;_PS_DEVICE_ID value* from xparameters.h.* @param GpioIntrId is XPAR_&lt;GIC&gt;_&lt;GPIO_Instance&gt;_VEC_ID value* from xparameters.h** @return* - XST_SUCCESS if the example has completed successfully.* - XST_FAILURE if the example has failed.** @note None******************************************************************************/int GpioIntrExample(XScuGic *Intc, XGpioPs *Gpio, u16 DeviceId, u16 GpioIntrId)&#123; XGpioPs_Config *ConfigPtr; int Status; //u32 WriteValue = 0; //u32 ReadValue = 0; g_Input_Pin = 0 + 54; g_Output_Pin = 1 + 54; /* Initialize the Gpio driver. */ ConfigPtr = XGpioPs_LookupConfig(DeviceId); if (ConfigPtr == NULL) &#123; return XST_FAILURE; &#125; XGpioPs_CfgInitialize(Gpio, ConfigPtr, ConfigPtr-&gt;BaseAddr); print("GPIO initial complete\n\r"); /* Run a self-test on the GPIO device. */ Status = XGpioPs_SelfTest(Gpio); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* Set the direction for the specified pin to be input */ XGpioPs_SetDirectionPin(Gpio, g_Input_Pin, 0x0); /* Set the direction for the specified pin to be output. */ XGpioPs_SetDirectionPin(Gpio, g_Output_Pin, 1); XGpioPs_SetOutputEnablePin(Gpio, g_Output_Pin, 1); XGpioPs_WritePin(Gpio, g_Output_Pin, 0x0); XGpioPs_SetDirection(Gpio, 3, 0x00000000); /* * Setup the interrupts such that interrupt processing can occur. If * an error occurs then exit. */ Status = SetupInterruptSystem(Intc, Gpio, GPIO_INTERRUPT_ID); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* * Loop forever while the button changes are handled by the interrupt * level processing. */ /*while(1) &#123; WriteValue = 0; XGpioPs_WritePin(Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5); WriteValue = 1; XGpioPs_WritePin(Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(Gpio, g_Input_Pin); printf("WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); sleep(5); &#125;*/ return XST_SUCCESS;&#125; /*****************************************************************************//**** This function sets up the interrupt system for the example. It enables falling* edge interrupts for all the pins of bank 0 in the GPIO device.** @param GicInstancePtr is a pointer to the XScuGic driver Instance.* @param GpioInstancePtr contains a pointer to the instance of the GPIO* component which is going to be connected to the interrupt* controller.* @param GpioIntrId is the interrupt Id and is typically* XPAR_&lt;GICPS&gt;_&lt;GPIOPS_instance&gt;_VEC_ID value from* xparameters.h.** @return XST_SUCCESS if successful, otherwise XST_FAILURE.** @note None.*****************************************************************************/static int SetupInterruptSystem(XScuGic *GicInstancePtr, XGpioPs *Gpio, u16 GpioIntrId)&#123; int Status; XScuGic_Config *IntcConfig; /* Instance of the interrupt controller */ Xil_ExceptionInit(); /* * Initialize the interrupt controller driver so that it is ready to * use. */ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); if (NULL == IntcConfig) &#123; return XST_FAILURE; &#125; Status = XScuGic_CfgInitialize(GicInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* * Connect the interrupt controller interrupt handler to the hardware * interrupt handling logic in the processor. */ Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, GicInstancePtr); #if 0 // 关联中断服务函数 ：一次跳变沿，会造成2次进中断服务函数，原因未知 /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ Status = XScuGic_Connect(GicInstancePtr, GpioIntrId, (Xil_ExceptionHandler)XGpioPs_IntrHandler, (void *)Gpio); if (Status != XST_SUCCESS) &#123; return Status; &#125; /* Set the handler for gpio interrupts. 设置gpio中断的处理程序 */ XGpioPs_SetCallbackHandler(Gpio, (void *)Gpio, IntrHandler);#else // 关联中断服务函数 ：一次跳变沿，进1次中断服务函数 /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ Status = XScuGic_Connect(GicInstancePtr, GpioIntrId, (Xil_ExceptionHandler)IntrHandler, (void *)Gpio); if (Status != XST_SUCCESS) &#123; return Status; &#125;#endif /* Enable falling edge interrupts for all the pins in bank 2. 设置中断类型，沿/电平、上升下降、高低*/ XGpioPs_SetIntrType(Gpio, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000); //XGpioPs_SetIntrType(Gpio, 2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); //XGpioPs_SetIntrType(Gpio, 2, 0xFFFFFFFF, 0x00000000, 0x00000000); /* Enable the GPIO interrupts of Bank 2. 启用Bank2的GPIO中断 */ //XGpioPs_IntrEnable(Gpio, 2, 1); XGpioPs_IntrEnable(Gpio, 2, 0xFFFFFFFF); /* Enable the interrupt for the GPIO device. 为GPIO设备启用中断 */ XScuGic_Enable(GicInstancePtr, GpioIntrId); /* Enable interrupts in the Processor. 在处理器中启用中断 */ Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ); return XST_SUCCESS;&#125; /****************************************************************************//*** This function is the user layer callback function for the bank 0 interrupts of* the GPIO device. It checks if all the switches have been pressed to stop the* interrupt processing and exit from the example.** @param CallBackRef is a pointer to the upper layer callback reference.* @param Status is the Interrupt status of the GPIO bank.** @return None.** @note None.*******************************************************************************/static void IntrHandler(void *CallBackRef, u32 Bank, u32 Status)&#123; XGpioPs *Gpio = (XGpioPs *)CallBackRef; u32 WriteValue = 0; u32 ReadValue = 0; // Disable GPIO interrupts XGpioPs_IntrDisablePin(Gpio, g_Input_Pin); usleep(1); XGpioPs_WritePin(Gpio, g_Output_Pin, WriteValue); ReadValue = XGpioPs_ReadPin(Gpio, g_Input_Pin); printf("IntrHandler ____ WriteValue : %ld, ReadValue : %ld \r\n", WriteValue, ReadValue); ReadValue = XGpioPs_Read(Gpio, 3); printf("IntrHandler ____ Read Bank3 Value : %ld \r\n", ReadValue); // Acknowledge GPIO interrupts XGpioPs_IntrClearPin(Gpio, g_Input_Pin); // Enable GPIO interrupts XGpioPs_IntrEnablePin(Gpio, g_Input_Pin);&#125;]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad++设置]]></title>
    <url>%2F2018%2F09%2F07%2Fnotepad-%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[将tab键设置为4个空格 设置–&gt;首选项–&gt;语言–&gt;制表符设置–&gt;(勾选上)替换为空格注：这样使用Tab键时，等同于使用了4个空格（不再是制表符） 显示空格及制表符视图–&gt;显示符号–&gt;(勾选上)显示空格及制表符制表符(tab)显示为：“—&gt;”空格显示为：“.” 显示缩进参考线视图–&gt;显示符号–&gt;(勾选上)显示缩进参考线 显示边界线（80字符标志）设置—首选项—编辑—勾选“显示列边界”]]></content>
      <categories>
        <category>Notepad++</category>
      </categories>
      <tags>
        <tag>Notepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fmt,… 格式化I/O输出]]></title>
    <url>%2F2018%2F09%2F05%2Ffmt-%E2%80%A6-%E6%A0%BC%E5%BC%8F%E5%8C%96I-O%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718#ifndef __MAIN_H__#define __MAIN_H__ #include "drivers/mss_uart/mss_uart.h"#include &lt;stdio.h&gt; char g_buf[64];int g_buf_len;#define uart0_printf(fmt,...) &#123; \sprintf(g_buf, fmt, ##__VA_ARGS__);\for(g_buf_len = 0; g_buf_len &lt; 64; g_buf_len++)\&#123;\ if(g_buf[g_buf_len] == '#')\ break;\&#125;\MSS_UART_polled_tx(gp_my_uart, (const uint8_t*)g_buf, g_buf_len-1);&#125; #endif /* __MAIN_H__ */]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows driver kits 7600]]></title>
    <url>%2F2018%2F09%2F05%2Fwindows-driver-kits-7600%2F</url>
    <content type="text"><![CDATA[下载地址:https://download.microsoft.com/download/4/A/2/4A25C7D5-EFBE-4182-B6A9-AE6850409A78/GRMWDK_EN_7600_1.ISO 1. 安装默认安装 2. 使用工具WDK（windows driver kits）编译（仅仅编译已经写好的驱动工程文件）2.1 在开始菜单中找到WDK 2.2 要编译不同的系统的驱动，选择对应的文件夹打开（比如说win server 2008就选择“Windows Vista and Windows Server 2008”），然后打开“x64 Checked Build Environment” 2.3 打开“x64 Checked Build Environment”后，会弹出如下窗口 2.4 使用命令跳转到驱动工程所在的文件夹内 2.5 使用命令build 编译工程。 2.6 编译成功后，到工程文件夹下，会出现一个新的文件夹。（编译不同系统的驱动，文件夹名称不同） 2.7 objchk_wlh_amd64文件夹内的amd64文件夹内，就有我们新编译的驱动文件PcieDrvX64.sys]]></content>
      <categories>
        <category>windows driver</category>
      </categories>
      <tags>
        <tag>windows driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xilinx Jtag 驱动问题]]></title>
    <url>%2F2018%2F08%2F30%2FXilinx-Jtag-%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Win10 64位系统，原先由Vivado 2016.4，又安装Vivado18.1后，Jtag识别异常 第一次连接USB-JTAG下载器时，在设备管理器指定驱动程序位置：C:\Xilinx\Vivado\2017.4\data\xicom\cable_drivers\nt64后，显示驱动安装成功，出现如下现象； 现象：下载器上的连接指示灯不亮，但系统设备列表里显示USB连接设备正常，名称为：xilinx embedded platform. usb firmware loader，vivado识别不到JTAG设备 解决方法： 安装Jungo驱动：找到低版本vivado安装后文件夹，如C:\Xilinx_16.4\Vivado\2016.4\data\xicom\cable_drivers\nt64\：管理员运行install_drivers_wrapper.bat，安装完成后设备管理器中出现Jungo–WinDriver设备； 插入Cable插入Cable后，在设备管理器中选中xilinx embedded platform. usb firmware loader设备，右击“卸载设备”，勾选“删除此设备的驱动程序软件”，删除之前驱动；某些机器会提示重启 重新拔插Usb Cable重新拔插Usb Cable，系统将自动识别设备并自动安装正确驱动，此时设备列表显示：Xilinx USB CableVivado可识别到JTAG设备。 参照：Xilinx Platform Cable USB下载器识别]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ设置程序运行位置]]></title>
    <url>%2F2018%2F08%2F21%2FZYNQ%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ZYNQ PS侧程序可选运行ddr,flash,及片内ram上 设置方法选中对应的SDK工程]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境Qt打包-linuxdeployqt]]></title>
    <url>%2F2018%2F08%2F21%2FLinux%E7%8E%AF%E5%A2%83Qt%E6%89%93%E5%8C%85-linuxdeployqt%2F</url>
    <content type="text"><![CDATA[使用linuxdeployqt工具，git项目地址：https://github.com/probonopd/linuxdeployqt 1. Qt环境确保设备已经安装了Qt环境 2. 设置qmake环境变量PATH1root@ubuntu:~# export PATH=/opt/Qt5.11.1/5.11.1/gcc_64/bin:$PATH 检查qmake环境变量设置情况 123root@ubuntu:~# qmake -vQMake version 3.1Using Qt version 5.11.1 in /opt/Qt5.11.1/5.11.1/gcc_64/lib 3. 下载linuxdeployqtlinuxdeployqt release版：https://github.com/probonopd/linuxdeployqt/releases 1wget https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage 将linuxdeployqt-continuous-x86_64.AppImage移动到/opt/linuxdeployqt-continuous-x86_64目录下 12mkdir /opt/linuxdeployqt-continuous-x86_64cp linuxdeployqt-continuous-x86_64.AppImage /opt/linuxdeployqt-continuous-x86_64/ 4.设置linuxdeployqt环境变量1root@ubuntu:~# export PATH=/opt/linuxdeployqt-continuous-x86_64/:$PATH 准备工作完成。 5. Qt工程生成Release版程序Qt工程生成Release版程序，将生成的二进制文件单独复制到一个路径，shell切换到二进制文件所在路径,执行如下命令（其中K7_PCIe2-DMA为生成的二进制文件） 1root@ubuntu:~/Desktop/K7_PCIe2-DMA# linuxdeployqt-continuous-x86_64.AppImage K7_PCIe2-DMA -appimage 参考：https://blog.csdn.net/enaldick12/article/details/63255934https://blog.csdn.net/zjx18915341085/article/details/79715075]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32 设置 A13、A14、B15、B3、B4为普通IO使用]]></title>
    <url>%2F2018%2F08%2F18%2FSTM32-%E8%AE%BE%E7%BD%AE-A13%E3%80%81A14%E3%80%81B15%E3%80%81B3%E3%80%81B4%E4%B8%BA%E6%99%AE%E9%80%9AIO%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[STM32 的PA13、PA14、PA15、PB3、PB4主要是用来JTAG调试用的，于是在默认下是启动后为JTAG模式，但是对于不需要JTAG而需要充分利用GPIO口时，就需要将JTAG关闭，设置为GPIO模式。 与JTAG有关的为PA13、PA14、PA15、PB3、PB4 与SWD有关的为PA13、PA14 1234567891011// 使能对应管脚的时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //打开PA时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //打开PB时钟 // 这几个管脚的复位后功能不是IO口，而是JTAG口，需要复用为IORCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //打开复用时钟----重要 // 关掉JTAG功能，保留SW 即PB3、PB4、PA15设置为普通IO，PA13、PA14仍为调试管脚GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);//关掉JTAG，不关SW// 关掉SW 即PA13、PA14、PA15、PB3、PB4全部设置为普通IOGPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);//关掉SW 注： 关掉JTAG功能，保留SW后，将不再可以使用JTAG调试下载程序，只能通过SW进行下载调试 关掉SW功能后，将不再可以使用JTAG、SW功能调试下载程序 参考文章：STM32 关闭JTAG 使用相应GPIO口 简单记录stm32不小心把SWD和JTAG都给关了，程序下载不进去，解决办法]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构详解]]></title>
    <url>%2F2018%2F08%2F13%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[详解 /根目录。Linux文件系统的入口.也是最高一级的目录.包含了几乎所的文件目录。相当于中央系统。进入的最简单方法是： 1cd / /boot引导程序，内核等存放的目录。这个目录，包括了在引导过程中所必需的文件，引导程序的相关文件（例如grub，lilo以及相应的配置文件以及Linux操作系统内核相关文件（例如vmlinuz等一般都存放在这里。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候，虚拟文件系统还不存在，加载的内核虽然是从硬盘读取的，但是没经过Linux的虚拟文件系统，这是比较底层的东西来实现的。然后内核自己创建好虚拟文件系统，并且从虚拟文件系统的其他子目录中（例如/sbin 和 /etc加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如grub.conf来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数。 /sbin超级用户可以使用的命令的存放目录。存放大多涉及系统管理的命令（例如引导系统的init程序，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是时普通用户也可能会用到。这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin等目录是相似的，我们要记住，凡是目录sbin中包含的都是root权限才能执行的，这样就行了。后面会具体区分。 /bin普通用户可以使用的命令的存放目录。系统所需要的那些命令位于此目录，比如ls、cp、mkdir等命令；类似的目录还/usr/bin，/usr/local/bin等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。 /lib根目录下的所有程序的共享库目录。此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于Windows上面的system32目录。按理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还有/usr/lib，/usr/local/lib等等。 /dev设备文件目录。在Linux中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用mknod命令来创建，具体参见相应的命令；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个*.ko类型的二进制文件，在内核启动之后，再通过insmod等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要Linux系统支持某个设备，只要个东西：相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。 /home普通用户的家目录（$HOME目录）。在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都有自己的家目录，目录以用户名作为名字存放在/home下面（例如quietheart用户，其家目录的名字为/home/quietheart。该目录中保存了绝大多数的用户文件(用户自己的配置文件，定制文件，文档，数据等)，root用户除外（参见后面的/root目录。由于这个目录包含了用户实际的数据，通常系统管理员为这个目录单独挂载一个独立的磁盘分区，这样这个目录的文件系统格式就可能和其他目录不一样了（尽管表面上看，这个目录还是属于根目录的一棵子树上），有利于数据的维护。 /root用户root的$HOME目录系统管理员(就是root用户或超级用户)的主目录比较特殊，不存放在/home中，而是直接放在/root目录下了。 /etc全局的配置文件存放目录。系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在/etc目录中，所以想要配置什么东西的话，可以在/etc下面寻找我们可能需要修改的文件。一些大型套件，如X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所有程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc。另外，还有一个需要注意的常见现象就是，当某个程序在某个用户下运行的时候，可能会在该用户的家目录中生成一个配置文件（一般这个文件最开始就是/etc下相应配置文件的拷贝，存放相应于“当前用户”的配置，这样当前用户可以通过配置这个家目录的配置文件，来改变程序的行为，并且这个行为只是该用户特有的。原因就是：一般来说一个程序启动，如果需要读取一些配置文件的话，它会首先读取当前用户家目录的配置文件，如果存在就使用；如果不存在它就到/etc下读取全局的配置文件进而启动程序。就是这个配置文件不自动生成，我们手动在自己的家目录中创建一个文件的话，也有许多程序会首先读取到这个家目录的文件并且以它的配置作为启动的选项（例如我们可以在家目录中创建vim程序的配置文件.vimrc，来配置自己的vim程序。 /usr这个目录中包含了命令库文件和在通常操作中不会修改的文件。这个目录对于系统来说也是一个非常重要的目录，其地位类似Windows上面的”Program Files”目录（请原谅我可能这样做比较不太恰当^_^。安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行/usr/bin下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。 /usr/lib目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。这个目录功能类似/lib目录，理说，这里存放的文件应该是/bin目录下程序所需要的库文件的存放地，也不排除一些例外的情况。 /usr/bin一般使用者使用并且不是系统自检等所必需可执行文件的目录。此目录相当于根文件系统下的对应目录（/bin），非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。 /usr/sbin管理员使用的非系统必须的可执行文件存放目录。此目录相当于根文件系统下的对应目录（/sbin），保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。 /usr/share存放共享文件的目录。在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据(例如程序文档信息)。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些类似数据。 /usr/includeC程序语言编译使用的头文件。linux下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。 /usr/local安装本地程序的一般默认路径。当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。例如，安装的程序可执行文件被安装（安装实质就是复制到了/usr/local/bin下面，此程序（可执行文件所需要依赖的库文件被安装到了/usr/local/lib目录下，被安装的软件如果是某个开发库（例如Qt，Gtk等那么相应的头文件可能就被安装到了/usr/local/include中等等。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。 /proc特殊文件目录。这个目录采用一种特殊的文件系统格式（proc格式，内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间(尽管命令ls -c会显示它们的大小)。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如： ├ 1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。├ cpuinfo 处理器信息，如类型、制造商、型号和性能。├ devices 当前运行的核心配置的设备驱动的列表。├ dma 显示当前使用的DMA通道。├ filesystems 核心配置的文件系统。├ interrupts 显示使用的中断，and how many of each there have been.├ ioports 当前使用的I/O端口。├ kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存；├ kmsg 核心输出的消息。也被送到syslog 。├ ksyms 核心符号表。├ loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。├ meminfo 存储器使用信息，包括物理内存和swap。├ modules 当前加载了哪些核心模块。├ net 网络协议状态信息。├ self 到查看/proc 的程序的进程目录的符号连接。├ stat 系统的不同状态├ uptime 系统启动的时间长度。└ version 核心版本。 /opt可选择的文件目录。这个目录表示的是可选择的意思，有些自定义软件包或者第三方工具，就可以安装在这里。比如在Fedora Core 5.0中，OpenOffice就是安装在这里。些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以把它们的安装路径设置成/opt这样来安装。这个目录的作用一点类似/usr/local。 /mnt临时挂载目录。 这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在/mnt目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧? /media挂载的媒体设备目录。挂载的媒体设备目录，一般外部设备挂载到这里，例如cdrom等。比如我们插入一个U盘，我们一般会发现，Linux自动在这个目录下建立一个disk目录，然后把U盘挂载到这个disk目录上，通过访问这个disk来访问U盘。 /var内容经常变化的目录。此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。 /tmp临时文件目录。该目录存放系统中的一些临时文件，文件可能会被系统自动清空。有的系统直接把tmpfs类型的文件系统挂载到这个目录上，tmpfs文件系统由Linux内核支持，在这个文件系统中的数据，实际上是内存中的，由于内存的数据断电易失，当系统重新启动的时候我们就会发现这个目录被清空了。 /lost+found恢复文件存放的位置。当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。 容易混淆的目录以上目录，是最常见的重要目录。其中，有些目录初学者容易混淆，这里简单区分一下： /bin,/sbin与/usr/bin,/usr/sbin:/bin一般存放 对于用户和系统来说“必须”的程序（二进制文件）。/sbin一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。/usr/bin一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。/usr/sbin一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。 /lib与/usr/lib:/lib和/usr/lib的区别类似/bin,/sbin与/usr/bin,/usr/sbin。/lib一般存放对于用户和系统来说“必须”的库（二进制文件。/usr/lib一般存放的只是对用户和系统来说“不是必需的”库（二进制文件。 其他其他还一些目录例如/home/user/bin，/home/user/opt，/home/user/etc，/usr/local/etc等等，其作用都是类似于/etc，/bin等目录的，可能只是层次概念不同了，使用Linux时间长了，会逐渐体会到其中的含义。 当然，我们可以无视这些目录，像使用Windows那样自由的，不管啥文件，想往哪存就往哪存，还是那句话，使用Linux时间长了，会逐渐体会到其中的含义，到时候也许我们想要乱来都不行了呢。^_^ man帮助在大多数Linux系统上面，我们可以使用一个命令：“man hier”，通过这个命令的输出，就知道“根目录”中所子目录的作用了。这个命令含义我不多说了，总之这里的hier就是对Linux文件系统中各级目录的标准功能，是一个大家都约定俗成了的东西。想要了解每个目录更详细的信息，需要仔细参考”man hier”的输出。下面就是一个比较简短的中文描述的对文件系统目录分类的FHS标准，也就是对”man hier”的简单翻译。 NAME 名称 hier – 文件系统描述 DESCRIPTION 描述 一个典型的Linux系统具以下几个目录结构：/ 根目录，是所目录树开始的地方。/bin 此目录下包括了单用户方式及系统启动或修复所用到的所执行程序。/boot 包括了引导程序的静态文件。此目录下包括了在引导过程中所必需的文件。系统装载程序及配制文件在 /sbin 和 /etc 目录中找到。/dev 对应物理设备的指定文件或驱动程序。参见mknod(1)。/dos 如果MS-DOS和Linux共存于一台计算机时，这里通常用于存放DOS 文件系统。/etc 用于存放本地机的配置文件。一些大型套件，如X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc./etc/skel 当建立一个新用户账号时，此目录下的文件通常被复制到用户的主目录下。/etc/X11X11 window system所需的配置文件。/home 在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。/lib 此目录下包含系统引导和在根用户执行命令所必需用到的共享库。/mnt 挂载临时文件系统的挂载点。/proc 这是提供运行过程和核心文件系统 proc 挂载点。这一”伪”文件系统在以下章节中详细叙述 proc(5)。/sbin 类似于 /bin 此目录保存了系统引导所需的命令，但这些命令一般使用者不能执行。/tmp 此目录用于保存临时文件，临时文件在日常维护或在系统启动时无需通知便可删除/usr 此目录通常用于从一个独立的分区上挂载文件。它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。/usr/X11R6 X-Window系统 Version 11 release 6./usr/X11R6/bin X-Windows系统使用的二进制文件；通常是在对更传统的 /usr/bin/X11 中文件的符号连接。/usr/X11R6/lib 保存与X-Windows系统关数据文件。/usr/X11R6/lib/X11 此目录保存与运行X-Windows系统关其他文件。通常是对来自 /usr/lib/X11 中文件的符号连接。/usr/X11R6/include/X11 此目录保存包括使用X11窗口系统进行编译程序所需的文件。通常是对来自 /usr/lib/X11 中文件的符号连接。/usr/bin 这是执行程序的主要目录，其中的绝大多数为一般使用者使用，除了那些启动系统或修复系统或不是本地安装的程序一般都放在此目录下。/usr/bin/X11X11执行文件放置的地方；在Linux系统中，它通常是对 /usr/X11R6/bin. 符号连接表 /usr/dict此目录保存拼写检查器所使用的词汇表文件。 /usr/doc此目录下应可以找到那些已安装的软件文件。 /usr/etc此目录可用来那些存放整个网共享的配置文件。然而那可执行命令指向总是使用参照使用 /etc 目录下的文件。 /etc 目录下连接文件应指向 /usr/etc. 目录下适当的文件。 /usr/includeC程序语言编译使用的Include”包括”文件。 /usr/include/X11C程序语言编译和X-Windows系统使用的 Include”包括”文件。它通常中指向 /usr/X11R6/include/X11. 符号连接表。 /usr/include/asm申明汇编函数的Include”包括”文件，它通常是指向 /usr/src/linux/include/asm 目录的符号连接 /usr/include/linux包含系统变更的信息通常是指向 /usr/src/linux/include/linux 目录的符号连接表，来获得操作系统特定信息。 (注：使用者应在此自行包含那些保证自己开发的程序正常运行所需的libc 函数库。不管怎样，Linux核心系统不是设计用来执行直接运行用户程序的，它并不知道用户程序需要使用哪个版本的libc库 。如果你随意将 /usr/include/asm 和 /usr/include/linux 指向一个系统核心，系统很可能崩溃。Debian系统不这么做。它使用 libc*-dev运行包中提供的核心系统标识，以保证启动所正确的文件。) /usr/include/g++GNU C++编译程序所使用的Include”包括”文件。 /usr/lib目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件案。一些复杂的程序可能在此占用整个子目录。 /usr/lib/X11存放X系统数据文件及系统配置文件的地方。 Linux中通常是指向 /usr/X11R6/lib/X11 目录的符号连接表。 /usr/lib/gcc-libGNU C 编译程序所使用的可执行文件案和”包括”文件。 gcc(1). /usr/lib/groffGNU groff 文件格式系统所使用的文件。 /usr/lib/uucpuucp(1) 所使用的文件。 /usr/lib/zoneinfo关时区信息文件文件。 /usr/local安装在本地执行程序的地方。 /usr/local/bin在此地放置本地执行程序的二进制文件。 /usr/local/doc放置本地文件。 /usr/local/etc安装在本地程序的配置文件。 /usr/local/lib安装在本地程序的库文件。 /usr/local/info安装在本地程序关信息文件。 /usr/local/man安装在本地程序使用手册。 /usr/local/sbin 安装在本地的系统管理程序。 /usr/local/src安装在本地程序的原始码。 /usr/man手册页通常放在此目录，或相关子目录下。 /usr/man//man[1-9]此目录在指定的地方以原始码形式存放手册页。系统在所的手册页中使用自己独特的语言及代码集，可能会省略 substring 子字符串。 /usr/sbin此目录保存系统管理程序的二进制码，这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。 /usr/share在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些数据。 /usr/src系统不同组成部份的源文件包括参考数据报。不要将你自己与项目关的文件放这里，因为在安装软件外，/usr下的文件属性除通常设为只读。 /usr/src/linux系统核心资源通常拆包安装于此。这是系统中重要的一环，因为 /usr/include/linux 符号连接表指向此目录。你应当使用其他目录来来编译建立新核心。 /usr/tmp此目录不再使用了。它应指向目录 /var/tmp。 这个链接只是出于系统兼容的目的，一般不再使用。 /var此目录下文件的大小可能会改变，如缓冲文件可日志文件。 /var/adm此目录为 /var/log 甩替代，通常是指向 /var/log 的符号连接表。 /var/backups此目录用来存放重要系统文件的后备文件 /var/catman/cat[1-9] or /var/cache/man/cat[1-9]此目录存储根据手册分类预先格式化的参考手册页。(这些参考手册页是相互独立的) /var/lock此目录存储锁定文件。依据命名习惯，设备锁定文件是 LCKxxxxx xxxxx与在文件系统中该设备名相同，使用的格式是HDU UUCP锁定文件，例如包含进程标识PID的锁定文件是一个10字节的ASCII格式的数字，后面跟一个换行符。 /var/log各种日志文件。 /var/preserve这是 vi(1) 存放正在编辑中的文件，以便以后可以恢复。 /var/run运行时的变量文件，如存放进程标识和登入使用者信息的文件。 (utmp) 此目录下文件在系统启动时被自动清除。 /var/spool各种程序产生的缓冲或排除等待的文件 /var/spool/atat(1) 的作业存缓区 /var/spool/croncron(1) 的作业存缓区 /var/spool/lpd打印缓存文件。 /var/spool/mail使用者邮箱。 /var/spool/smail存放 smail(1) 邮件发送程序的缓冲文件。 /var/spool/news新闻子系统的缓冲目录 /var/spool/uucpuucp(1) 的缓冲文件 /var/tmp类似 /tmp, 此目录保存未指定持续时间的临时文件。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu-18.04 以root登录桌面]]></title>
    <url>%2F2018%2F08%2F09%2FUbuntu-18-04-%E4%BB%A5root%E7%99%BB%E5%BD%95%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Ubuntu 18.04默认是不允许以root用户进行登录的，想要以root用户进行登录需要进行一些操作，主要是以下几个步骤： 第一步：以普通用户登录系统，创建root用户的密码在终端输入命令：sudo passwd root然后输入你要设置的密码，这样就完成了设置root用户密码的步骤 第二步：修改文件50-unity-greeter.conf文件：123cd /usr/share/lightdm/lightdm.conf.d/cp 50-unity-greeter.conf 50-unity-greeter.conf_bakvi 50-unity-greeter.conf 将文件修改为 123456789[SeatDefaults]#启动后以root身份自动登录autologin-user=rootgreeter-session=unity-greeteruser-session=ubuntu#手工输入登陆系统的用户名和密码greeter-show-manual-login=true#禁用guest用户allow-guest=false 保存 第三步：修改gdm-autologin和gdm-password文件：1234567cd /etc/pam.d cp gdm-autologin gdm-autologin_bakvi gdm-autologin 注释掉auth required pam_succeed_if.so user != root quiet_success这一行，保存 cp gdm-password gdm-password_bakvi gdm-password 注释掉 auth required pam_succeed_if.so user != root quiet_success这一行，保存 第四步：修改/root/.profile文件123cd /root/vi .profile 将文件末尾的mesg n || true这一行修改成tty -s&amp;&amp;mesg n || true， 保存 第五步：重启系统，输入root用户名和密码，登录系统。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Linux 安装 .7z 解压和压缩文件]]></title>
    <url>%2F2018%2F08%2F09%2FUbuntu-Linux-%E5%AE%89%E8%A3%85-7z-%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[安装方法： 1sudo apt-get install p7zip 解压文件： 17z x manager.7z -r -o /home/xx 解释如下：x 代表解压缩文件，并且是按原始目录解压（还有个参数 e 也是解压缩文件，但其会将所有文件都解压到根下，而不是自己原有的文件夹下）manager.7z 是压缩文件，这里大家要换成自己的。如果不在当前目录下要带上完整的目录-r 表示递归所有的子文件夹-o 是指定解压到的目录，这里大家要注意-o后是没有空格的直接接目录 压缩文件： 17z a -t7z -r manager.7z /home/manager/* 解释如下：a 代表添加文件／文件夹到压缩包-t 是指定压缩类型 一般我们定为7z-r 表示递归所有的子文件夹，manager.7z 是压缩好后的压缩包名，/home/manager/* 是要压缩的目录，*是表示该目录下所有的文件。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synergy—一套键鼠同时控制多台电脑的神器（Ubuntu16.04+Win10）]]></title>
    <url>%2F2018%2F08%2F06%2FSynergy%E2%80%94%E4%B8%80%E5%A5%97%E9%94%AE%E9%BC%A0%E5%90%8C%E6%97%B6%E6%8E%A7%E5%88%B6%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E7%A5%9E%E5%99%A8%EF%BC%88Ubuntu16-04-Win10%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/qq_35451572/article/details/79284549 很多人自己有两台电脑，但是桌面空间有限不想使用两套鼠标键盘，这时就需要一个神器来将两台机器连接起来。天下之大无奇不有，你们期待的神器已经诞生————Synergy. Synergy 可以让你的多台电脑共享一套键鼠，甚至还可以共享剪贴板，而你只需动动鼠标，指针就可以轻松地在各台电脑屏幕之间来回穿梭，就像一台电脑使用多个显示器一样。而且 Synergy 完全免费开源，并跨平台支持 Win/Mac/Linux，相当给力！ 就是注册码暂时是没有的，需要到某宝上去购买一个（你们懂得）. 在Ubuntu中Synergy安装在网上有些博客说在Ubuntu Software中可以直接下载Synergy安装包，但是并没有看到～～ 直接将终端切换到安装包存放的目录中，直接dpkg安装 1sudo dpkg -i synergy-v1.8.8-stable-25a8cb2-Linux-x86_64.deb 如果出现以下界面就是说明你没有安装相应的库文件； 这时就需要安装两个必须的库 12sudo apt-get install libavahi-compat-libdnssd1sudo apt-get install libavahi-compat-libdnssd-dev 安装成两个上述所示的两个库以后，重新执行安装命令，如果没有别的意外就可以安装好程序。 1sudo dpkg -i synergy-v1.8.8-stable-25a8cb2-Linux-x86_64.deb 安装成功以后的图片如下图所示 在Win中Synergy安装这个就相对来说简单多了，不需要太多的库支持直接选择下一步就是可以的。 两台电脑Synergy设置 首先在客户端设置自己的电脑的位置信息，Synergy电脑初始名称是根据系统名称设定的。我自己的两台电脑如上图所示名字分别设定为Gao与gao,主机不能够重名是知道的，但是没有想到Synergy是不区分英文字母大小写的，这样就需要修改一台机器的名称不发生冲突。Synergy ERROR: ipc connection error INFO: watchdog status: error这个问题有些时候重启服务也是不可以的，这个时候可以尝试进行重新的激活，我测试过重新激活一下是可以的。]]></content>
      <categories>
        <category>Synergy</category>
      </categories>
      <tags>
        <tag>Synergy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统查看内存占用和CPU使用率的方法]]></title>
    <url>%2F2018%2F08%2F06%2FUbuntu%E7%B3%BB%E7%BB%9F%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%92%8CCPU%E4%BD%BF%E7%94%A8%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单独查看内存使用情况的命令： 1free -m 查看内存及cpu使用情况的命令： 1top 可以安装htop工具，这样更直观，安装命令如下： 1sudo apt-get install htop 安装完后，直接输入命令： 1htop 就可以看到内存或cpu的使用情况了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt .Pro]]></title>
    <url>%2F2018%2F08%2F06%2FQt-Pro%2F</url>
    <content type="text"><![CDATA[123456CONFIG += releaseMOC_DIR = temp/mocRCC_DIR = temp/rccUI_DIR = temp/uiOBJECTS_DIR = temp/objDESTDIR = bin]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本中echo显示内容带颜色]]></title>
    <url>%2F2018%2F08%2F02%2Fshell%E8%84%9A%E6%9C%AC%E4%B8%ADecho%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9%E5%B8%A6%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[shell脚本中echo显示内容带颜色显示,echo显示带颜色，需要使用参数-e格式如下： 1 echo -e “\033[字背景颜色；文字颜色m字符串\033[0m” 例如： 1echo -e &quot;\033[41;36m something here \033[0m&quot; 其中41的位置代表底色， 36的位置是代表字的颜色注： 1、字背景颜色和文字颜色之间是英文的”” 2、文字颜色后面有个m 3、字符串前后可以没有空格，如果有的话，输出也是同样有空格 字颜色：30—–37 12345678echo -e &quot;\033[30m 黑色字 \033[0m&quot;echo -e &quot;\033[31m 红色字 \033[0m&quot;echo -e &quot;\033[32m 绿色字 \033[0m&quot;echo -e &quot;\033[33m 黄色字 \033[0m&quot;echo -e &quot;\033[34m 蓝色字 \033[0m&quot;echo -e &quot;\033[35m 紫色字 \033[0m&quot;echo -e &quot;\033[36m 天蓝字 \033[0m&quot;echo -e &quot;\033[37m 白色字 \033[0m&quot; 字背景颜色范围：40—–47 12345678echo -e &quot;\033[40;37m 黑底白字 \033[0m&quot;echo -e &quot;\033[41;37m 红底白字 \033[0m&quot;echo -e &quot;\033[42;37m 绿底白字 \033[0m&quot;echo -e &quot;\033[43;37m 黄底白字 \033[0m&quot;echo -e &quot;\033[44;37m 蓝底白字 \033[0m&quot;echo -e &quot;\033[45;37m 紫底白字 \033[0m&quot;echo -e &quot;\033[46;37m 天蓝底白字 \033[0m&quot;echo -e &quot;\033[47;30m 白底黑字 \033[0m&quot; 最后面控制选项说明 12345678910111213141516171819\33[0m 关闭所有属性 \33[1m 设置高亮度 \33[4m 下划线 \33[5m 闪烁 \33[7m 反显 \33[8m 消隐 \33[30m — \33[37m 设置前景色 \33[40m — \33[47m 设置背景色 \33[nA 光标上移n行 \33[nB 光标下移n行 \33[nC 光标右移n行 \33[nD 光标左移n行 \33[y;xH设置光标位置 \33[2J 清屏 \33[K 清除从光标到行尾的内容 \33[s 保存光标位置 \33[u 恢复光标位置 \33[?25l 隐藏光标 \33[?25h 显示光标]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[截图工具]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[免安Snipaste 需要安装Lightshot]]></content>
  </entry>
  <entry>
    <title><![CDATA[KMS]]></title>
    <url>%2F2018%2F07%2F24%2FKMS%2F</url>
    <content type="text"><![CDATA[Kms激活工具没有官网，搜索工具搜出来的都是第三方网站或者一些假官网。Kms作者只将其发布在了MDL论坛。MDL论坛 Kms工具所在页面https://forums.mydigitallife.net/threads/kmspico-official-thread.65739/，需要登陆 账号是谷歌邮箱注册的 自己下载的目前最新版本10.2.0：https://file.xbao.org/?dir=KMSpico]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联通hg8347r光猫破解改桥接]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%81%94%E9%80%9Ahg8347r%E5%85%89%E7%8C%AB%E7%A0%B4%E8%A7%A3%E6%94%B9%E6%A1%A5%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[破解华为HG8346R/HG8347R光猫 启用有线桥接_Cherrot`s北京联通华为光猫HG8346R破解改桥接_什么值得买北京联通华为HG8347R破解_宽带技术网HG8347R破解_雲月冠上-简书 工具下载“https://file.xbao.org/?dir=HG8347R%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7”]]></content>
      <categories>
        <category>路由</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10安装hp m1216打印机驱动]]></title>
    <url>%2F2018%2F07%2F23%2FWin10%E5%AE%89%E8%A3%85hp-m1216%E6%89%93%E5%8D%B0%E6%9C%BA%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[下载LJM1130_M1210_MFP_Full_Solution.exe 双击，程序会自解压。但是到100%后，就没有反应了。。。。。。。 找到路径“C:\Users\10700\AppData\Local\Temp\7zS713F”，双击“HpSetup.exe”进行安装。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Beyond Compare 4 破解]]></title>
    <url>%2F2018%2F07%2F21%2FBeyond-Compare-4-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[2018年11月24日更新原方法已失效，需要更改注册表 在搜索栏中输入 regedit，打开注册表 找到“计算机\HKEY_CURRENT_USER\Software\Scooter Software\Beyond Compare 4\CacheId”，将“CacheId”重命名或删除 Beyond Compare 4这个软件安装完成后在C:\Users\用户名\AppData\Roaming\BCompare 下会生成一个文件BCompare.ini，记录安装的时间，最近一次打开软件的时间。如下图这样Beyond Compare 4 调用 time_t time(time_t *t) 生成的一个时间戳而已，那么试用时间就显而易见了，两个时间戳一减，超过30天就不让你用了。将BCompare.ini文件中LastLoading值改为与InstallTime值相同，保存关闭。将BCompare.ini文件修改为只读。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vs_Qt工程，无Pro文件，添加模块]]></title>
    <url>%2F2018%2F07%2F21%2FVs-Qt%E5%B7%A5%E7%A8%8B%EF%BC%8C%E6%97%A0Pro%E6%96%87%E4%BB%B6%EF%BC%8C%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[项目名右键，选择“Qt Project Settings” 选择“Qt Modules”，添加相应的模块]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++注释规范]]></title>
    <url>%2F2018%2F07%2F16%2FC-C-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[整理自互联网，整合了许多大佬及公司的规范，谨记 文件头 123456789/***************************************************************************** * Copyright: zhou * File name: 文件名 * Description: 用于详细说明此程序文件完成的主要功能，与其他模块或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系 * Author: 作者 * Version: 版本 * Date: 完成日期 * History: 修改历史记录列表， 每条修改记录应包括修改日期、修改者及修改内容简述。 *****************************************************************************/ 函数注释 123456789/***************************************************************************** * Function: // 函数名称 * Description: // 函数功能、性能等的描述 * Input: // 输入参数说明，包括每个参数的作 * // 用、取值说明及参数间关系。 * Output: // 对输出参数的说明。 * Return: // 函数返回值的说明 * Others: // 其它说明 *****************************************************************************/]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt_打开|保存文件对话框]]></title>
    <url>%2F2018%2F06%2F29%2FQt-%E6%89%93%E5%BC%80-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[Qt_打开|保存文件对话框 12345678910111213// 打开文件对话框QString fileName = QFileDialog::getOpenFileName( this, tr("open file"), " ", tr("Allfile(*.*);;mp3file(*.mp3)"));/* * 说明：这样就会产生一个对话框，和系统的资源管理器差不多的。返回的是你选择文件的 绝对路径。 * 参数1：父窗口 * 参数2：对话框的标题 * 参数3：默认的打开的位置，如”我的文档“等 * 参数4：文件的过滤器，注意文件类型之间用 ;; 分开 * */ 12345678910111213// 保存文件对话框QString fileName = QFileDialog::getSaveFileName( this, tr("save file"), " ", tr("file(*.bin);;Allfile(*.*)"));/* * 说明：这样就会产生一个对话框，和系统的资源管理器差不多的。返回的是你要保存文件的 绝对路径。 * 参数1：父窗口 * 参数2：对话框的标题 * 参数3：默认的保存的位置，如”我的文档“等 * 参数4：文件的过滤器，注意文件类型之间用 ;; 分开 * */]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体里的冒号“:”]]></title>
    <url>%2F2018%2F06%2F28%2F%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E7%9A%84%E5%86%92%E5%8F%B7%E2%80%9C-%E2%80%9D%2F</url>
    <content type="text"><![CDATA[结构体里的冒号“:” 位结构是一种特殊的结构, 在需按位访问一个字节或字的多个位时, 位结构比按位运算符更加方便。 位结构定义的一般形式为: 12345struct 位结构名&#123; 数据类型 变量名: 整型常数; 数据类型 变量名: 整型常数; &#125; 位结构变量; 数据类型必须是int(unsigned或signed)。 整型常数必须是非负的整数, 范围是0~15, 表示二进制位的个数, 即表示有多少位。变量名是选择项, 可以不命名, 这样规定是为了排列需要。 123456struct id_flag&#123; unsigned is_keyword:1; unsigned is_external:1 unsigned is_static:1;&#125;flag; 本例定义了is_keyword、is_external、is_static三个位字段，它们各占1位（1bit）存储空间。同时，也定义了一个名为flag的struct id_flag类型的结构体变量。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++中单冒号: 和双冒号:: 的用法]]></title>
    <url>%2F2018%2F06%2F28%2FC-C-%E4%B8%AD%E5%8D%95%E5%86%92%E5%8F%B7-%E5%92%8C%E5%8F%8C%E5%86%92%E5%8F%B7-%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一.单冒号（:）1. 位域结构 有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： struct 位域结构名{ 位域列表 };其中位域列表的形式为： 类型说明符 位域名：位域长度例如： 123456struct bs &#123; int a:8; int b:2; int c:6; &#125;; 位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如： 123456struct bs &#123; int a:8; int b:2; int c:6; &#125;data; 说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：a) 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： 1234567struct bs &#123; unsigned a:4 unsigned :0 /*空域*/ unsigned b:4 /*从下一单元开始存放*/ unsigned c:4 &#125; 在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。 b) 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如： 1234567struct k &#123; int a:1 int :2 /*该2位不能使用*/ int b:3 int c:2 &#125;; 从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。 2. 条件语句( ? : )与?构成条件语句，作用相当于if else，如下； 1234int a,b,c;a=3;b=2;c=a&gt;b?a:b;// 如果a&gt;b成立，则反a赋给c，否则把b赋给c 条件语句的结构为：条件表达式?表达式1:表达式2当条件表达式为true时，表达式的值为表达式1的值，否则为表达式2的值。几点说明：1）?:可以嵌套，但不推荐使用（难懂），下面的表达式你能看懂啥意思不 1int max = i&gt;j ? i&gt;k ? i : k : j&gt;k ? j : k; 脑袋大了吧，呵呵。2）?:具有很低的优先级，这个要注意哦，下面的程序执行结果是啥呢？ 12345int i = 3;int j = 2;cout &lt;&lt; i&gt;j?i:j;// 出错，&lt;&lt;比&gt;具有更高的优先级，执行顺序为 ((cout&lt;&lt;i)&gt;j)?i:j,相当于是比较cout&lt;&lt;i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout&lt;&lt;i的值是cout，不能跟整型数j进行比较。cout &lt;&lt; (i&gt;j)?i:j;//输出1或0，相当于(cout&lt;&lt;(i&gt;j))作为判决条件，来决定表达式的值为i或j，而cout&lt;&lt;(i&gt;j)，i&gt;j则输出1否则0，然后再将(cout&lt;&lt;(i&gt;j))作为？：的条件，如果cout正确执行则为1（true），否则为0（false），以此决定表达式值为i或jcout &lt;&lt;(i&gt;j?i:j);//i&gt;j则输出i，否则输出j，表达式值为true如果cout正确执行，否则为false 更多的关于优先级的问题就不说了。 3. 语句标签通常跟goto配合使用，如： 123step1: a = f1(); .... goto step1; 这种作法也不是很推荐，原因在于它破坏了语句的顺序执行，这样的代价大家应该清楚吧。不过存在即为合理嘛，既然它还存在，肯定还是有它的用处有它的好处的，比如说，多层嵌套的退出（会比break continue直观一点吧），也可以避免重复代码之类之类的 4. switch语句中case后这个不说了，要是不会的话，我也没话可说了。 5. 汇编指令模板具体参考：http://developer.e800.com.cn/articles/2006/43/1144846933898_1.html 6. 类构造函数(Constructor）的初始化列表在构造函数后面紧跟着冒号加初始化列表，各初始化变量之间以逗号(,)隔开。下面举个例子。 123456789101112class myClass&#123;public : myClass();// 构造函数，无返回类型，可以有参数列表，这里省去 ~myClass();// 析构函数 int a; const int b;&#125; myClass::myClass():a(1),b(1)// 初始化列表&#123;&#125; 上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明：a)初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错： 12345myClass::myClass（）&#123; a = 1;// 没错，效果相当于在初始化列表中进行初始化 b = 1;// 出错，const变量不能进行赋值操作；&#125; b）初始化的顺序与成员变量声名的顺序相同。先看一下下面的程序： 123myClass::myClass():b(1),a(b)&#123;&#125; 这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。c）对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。 7. 声明基类假设我们重新定义一个类，继承自myClass类。定义方式如下： 1234class derivedClass : public myClass&#123;// 略去&#125; 这里的冒号起到的就是声名基类的作用，在基类类名前面可以加public\private\protected等标签，用于标识继承的类型，也可以省略，省略的话，用class定义的类默认为private，用struct定义的类默认为public，至于具体各个标签有什么区别这里就不说了。与初始化列表一样的，这里也可以声名多个基类，各基类之间用逗号(,)隔开。 二．双冒号（::）用法1. 表示“域操作符”例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成void A::f()，表示这个f()函数是类A的成员函数。 2. 直接用在全局函数前，表示是全局函数例：在VC里，你可以在调用API 函数里，在API函数名前加：： 3. 表示引用成员函数及变量，作用域成员运算符例：System::Math::Sqrt() 相当于System.Math.Sqrt() 4. 命名空间作用域符，即2直接用在全局函数前，表示是全局函数在运算符等级中属于最高级的！using namespace 命名空间名（如，abc）；表示在以下程序代码中所使用的标示符（如果此标示符在abc中定义）是abc中的，包括类型名（类），变量名，函数名，对象名。。。using abc::标示符(i)；只表示在以下代码中使用的标示符i是abc中的。如果你要使用abc中的多个标示符的话，你就只能用 1234using abc::a;using abc::b;using abc::c;... 等一个一个列举出来！当然用using 语句是比较方便的但是不安全（1）using namespace；万一不同的两个命名空间中使用了同名的标示符，系统则不能判断，这个标示符是属于哪个命名空间的；（2）using abc::；万一你的程序中也用到了一个函数（函数名与abc中的这个函数同名），那么系统也不能判断你使用的是abc中的那个函数，还是本程序中的那个函数；最安全的办法（当然也是最繁琐的）就是，每当你用到一个变量（函数…)时，你都要明确他的来历（即属于哪个命名空间）除非它没有命名空间例如： 123456#include &lt;iostream&gt; int main ()&#123; std::cout &lt;&lt; "hello, world!" &lt;&lt; std::endl;&#125; 这里就用到了iostream文件中的两个对象（cout，endl）因为C++标准库中绝大部分的函数，对象…都放在了命名空间std中所以上面的代码就等同于 1234567#include &lt;iostream&gt;using std::cout；using std::endl;int main ()&#123; cout &lt;&lt; "hello, world!" &lt;&lt; endl;&#125; 1234567#include &lt;iostream&gt;using namespace std; int main ()&#123; cout &lt;&lt; "hello, world!" &lt;&lt; endl;&#125; 重新举个例子，再加以说明： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt; int main ()&#123; int a; std::string b; std::cin &gt;&gt; a; std::cin &gt;&gt; b; std::cout &lt;&lt; "hello, world!" &lt;&lt; std::endl; return 0;&#125; 1) using std::； 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using std::cin;using std::endl;using std::string; int main ()&#123; int a; string b; cin &gt;&gt; a; cin &gt;&gt; b; std::cout &lt;&lt; "hello, world!" &lt;&lt; endl; //注意cout没用用using return 0;&#125; 2) using namespace ； 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int main ()&#123; int a; string b; cin &gt;&gt; a; cin &gt;&gt; b; cout &lt;&lt; "hello, world!" &lt;&lt; endl; return 0;&#125; 其中cout endl cin string都是std中的！]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt Timer]]></title>
    <url>%2F2018%2F06%2F27%2FQt-Timer%2F</url>
    <content type="text"><![CDATA[*.h 12public slots: void Timeout_Slots(); *.cpp 1234567891011121314#include &lt;QTimer&gt;#include &lt;QDebug&gt; // 创建定时器QTimer *timer = new QTimer(this);timer-&gt;start(1000);connect(timer, SIGNAL(timeout()), this, SLOT(Timeout_Slots())); // 关联定时器槽函数 // 定时器槽函数void Widget::Timeout_Slots()&#123; qDebug() &lt;&lt; "[FILE:" &lt;&lt; __FILE__ &lt;&lt; ",LINE" &lt;&lt; __LINE__ &lt;&lt; ",FUNC" &lt;&lt; __FUNCTION__ &lt;&lt; "]"; ......&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ_MIO_C代码]]></title>
    <url>%2F2018%2F06%2F27%2FZYNQ-MIO-C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[全局变量 12#define MIO_PinNumber 34 // 宏定义对应MIO引脚static XGpioPs g_psGpioInstancePtr;//定义结构体 初始化函数 1234567891011121314151617181920212223int MIO_Init()&#123; //MIO struct initial int xStatus; XGpioPs_Config* GpioConfigPtr; //--MIO的初始化 GpioConfigPtr = XGpioPs_LookupConfig(XPAR_PS7_GPIO_0_DEVICE_ID);//获取GPIO_0配置 if(GpioConfigPtr == NULL) &#123; return XST_FAILURE; &#125; xStatus = XGpioPs_CfgInitialize(&amp;g_psGpioInstancePtr, GpioConfigPtr, GpioConfigPtr-&gt;BaseAddr); if (Status != XST_SUCCESS) &#123; print("gpio_mio config error!\n"); return XST_FAILURE; &#125; //--MIO的输入输出操作 XGpioPs_SetDirectionPin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 1); //配置MIO34 direct is out；第二个参数为引脚号；第三个参数为控制输入输出：0为输入、1为输出 XGpioPs_SetOutputEnablePin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 1); //配置MIO引脚的输出使能；第二个参数为引脚号；第三个参数为控制使能：1代表使能、0代表失能&#125; 控制IO 1234567891011121314151617181920// 控制IO，方法一XGpioPs_WritePin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 0); // 设置对应引脚为低电平XGpioPs_WritePin(&amp;g_psGpioInstancePtr, MIO_PinNumber, 1); // 设置对应引脚为高电平 // 控制IO，方法二/** 参数一：MIO基地址：固定为0xE000A000* 参数二：MIO偏移地址： 0x00000000，MIO 0~15* 0x00000004，MIO 16~31* 0x00000008，MIO 32~47* 0x0000000b，MIO 48~54* 参数三：32位的参数，分成2个16位： 低16位为设置管脚高低电平* 高16位为控制低16为的设置是否有效，只有当高16位的对应bit为0时，低16位对应bit设置高低电平才有效*/// 34引脚XGpioPs_WriteReg(0xE000A000, 0x00000008, 0xFFFBFFFF &amp; 0xFFFF0004); // 设置对应引脚为高电平XGpioPs_WriteReg(0xE000A000, 0x00000008, 0xFFFBFFFF &amp; 0xFFFF0000); // 设置对应引脚为低电平// 0引脚XGpioPs_WriteReg(0xE000A000, 0x00000000, 0xFFFFFFFE &amp; 0xFFFF0001); // 设置对应引脚为高电平XGpioPs_WriteReg(0xE000A000, 0x00000000, 0xFFFFFFFE &amp; 0xFFFF0000); // 设置对应引脚为低电平]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制补码转原码_C实现]]></title>
    <url>%2F2018%2F06%2F26%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81%E8%BD%AC%E5%8E%9F%E7%A0%81-C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920typedef struct _Point&#123; int nx; int ny;&#125;Point; Point originalPoint; //原始坐标 // 数据有效位为12位originalPoint.nx = (constell &amp; 0xfff); // x轴数值，为2进制补码；originalPoint.ny = ((constell &gt;&gt; 12) &amp; 0xfff); // y轴数值，为2进制补码；// 得到补码，将其转换为原码if(originalPoint.nx &gt;&gt; 11) //最高位是1，代表是负数的反码，计算原码&#123; originalPoint.nx -= 4096; // &#125;if(originalPoint.ny &gt;&gt; 11) //最高位是1，代表是负数的反码，计算原码&#123; originalPoint.ny -= 4096; // &#125; 1234567891011121314// 指定位数的二进制补码转原码int ComplementToSource(int Complement, int bits)&#123; int Source = Complement; int flag = (1 &lt;&lt; bits) - 1; if ((Complement &amp; flag) &gt;&gt; (bits - 1)) &#123; Source = Complement - (1 &lt;&lt; bits); &#125; return Source;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种DLL（Win32DLL，MFC常规DLL和MFC拓展DLL）的简单学习总结]]></title>
    <url>%2F2018%2F06%2F23%2F%E4%B8%89%E7%A7%8DDLL%EF%BC%88Win32DLL%EF%BC%8CMFC%E5%B8%B8%E8%A7%84DLL%E5%92%8CMFC%E6%8B%93%E5%B1%95DLL%EF%BC%89%E7%9A%84%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习了三种动态链接库的基本知识，分别是Win32DLL，MFC常规DLL和MFC拓展DLL。 Win32DLL使用的是Win32的API实现的，只能导出函数，能被各种应用程序调用，适用范围最广。 MFC常规DLL是适用MFC创建的，就像MFC程序跟Win32程序的关系一样，MFC常规DLL和Win32DLL的关系也是如此。它使用MFC的机制，只能导出标准C函数。如此，它便可以被大部分Win32程序调用。 MFC拓展DLL也也使用的是MFC机制创建的，相比于MFC常规DLL，拓展DLL可以导出C++类和MFC派生类，如此扩大了DLL的接口范围。此长彼消，MFC拓展DLL的适用范围较小，只能被MFC程序调用。因为它导出的不只是函数，还有C++类和MFC派生类。 另外，所有的动态链接库都有两种链接方式：隐式调用和显示调用。隐式链接使用起来比较方便，不过不够灵活；显示链接可以在真正要用DLL的时候才装入，并在适当的时候释放，操作相对复杂一些。]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt打包（Qt自带Windep打包工具）]]></title>
    <url>%2F2018%2F06%2F23%2FQt%E6%89%93%E5%8C%85%EF%BC%88Qt%E8%87%AA%E5%B8%A6Windep%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Qt工程生成Release版 找到Release版exe，将其复制到一个单独的文件夹内（也可在默认路径内） 打开工具，与Qt工程版本一致 使用cd命令，切换至exe文件所在的路径 输入命令 1windeployqt ***.exe]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt打印文件名、函数名、行号]]></title>
    <url>%2F2018%2F06%2F23%2FQt%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D%E3%80%81%E8%A1%8C%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[1qDebug() &lt;&lt; "[FILE:" &lt;&lt; __FILE__ &lt;&lt; ",LINE" &lt;&lt; __LINE__ &lt;&lt; ",FUNC" &lt;&lt; __FUNCTION__ &lt;&lt; "]";]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建并调用Win32 DLL]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%B0%83%E7%94%A8Win32-DLL%2F</url>
    <content type="text"><![CDATA[1. 生成Win32 DLL1.1 创建Win32 DLL工程File-&gt;New-&gt;Projects-&gt;Win32 Dynamic Link Library,在”Project name” 中输入MyDll-&gt;OK-&gt;An empty DLL project-&gt;Finish-&gt;OK 1.2 添加头文件mydll.hFile-&gt;new-&gt;Files-&gt;C/C++ Header File,输入文件名为:mydll.h-&gt;OK添加对应函数名mydll.h: 1extern "C" _declspec(dllexport) int Add(int x,int y); 1.3 添加源文件mydll.cpp File-&gt;new-&gt;Files-&gt;C/C++ Source File,输入文件名为:mydll-&gt;OK mydll.cpp: 123456#include&lt;stdio.h&gt;#include "mydll.h"int Add(int x,int y)&#123; return x+y;&#125; 1.4 编译,连接后,在Debug目录生成MyDll.dll,MyDll.lib 2. 调用Win32 DLL隐式调用 (1)File-&gt;New-&gt;Projects-&gt;Win32 Console Application,在”Project name” 中输入TestMyDll,OK,An empty project-&gt;Finish-&gt;OK将MyDll.dll,MyDll.lib拷贝到TestMyDll目录下。 (2)File-&gt;new-&gt;Files-&gt;C/C++ Source File,输入文件名为:testmydll-&gt;OKtestmydll.cpp: 12345678#include&lt;stdio.h&gt;#pragma comment(lib,"MyDll.lib")extern "C" _declspec(dllimport) int Add(int x,int y);void main()&#123; int i=Add(1,2); printf("1+2=%d/n",i);&#125; 注：也可将#pragma comment(lib,”MyDll.lib”)注释掉，并在Project-&gt;Settings-&gt;Link&gt;Object/library modules 中加入MyDll.lib 显式调用只须将MyDll.dll拷贝到TestMyDll目录下。 1234567891011121314#include&lt;stdio.h&gt;#include&lt;windows.h&gt; typedef int (*lpAdd)(int x,int y); void main()&#123; int i=0; HINSTANCE hinstance=LoadLibrary("MyDll.dll"); lpAdd add=(lpAdd)GetProcAddress(hinstance,"Add"); i=add(1,2); FreeLibrary(hinstance); printf("1+2=%d/n",i);&#125; 注：1.LoadLibrary:加载可执行模块 1234&gt; HINSTANCE LoadLibrary(&gt; LPCTSTR lpLibFileName // address of filename of executable module&gt; );&gt; 如果应用程序使用LoadLibrary显式链接，那么在这个函数的参数中可以指定DLL文件的完整路径。如果不指定路径，或是进行隐式链接，Windows将遵循下面的搜索顺序来定位DLL： 1． 包含EXE文件的目录， 2． 进程的当前工作目录， 3． Windows系统目录， 4． Windows目录， 5． 列在Path环境变量中的一系列目录。 2.GetProcAddress:返回指定导出Dll函数的地址 12345&gt; FARPROC GetProcAddress(&gt; HMODULE hModule, // handle to DLL module&gt; LPCSTR lpProcName // name of function&gt; );&gt;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WP文章页面警告解决方法]]></title>
    <url>%2F2018%2F06%2F22%2FWP%E6%96%87%E7%AB%A0%E9%A1%B5%E9%9D%A2%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在文章页内容最下方会有如下警告 1Warning: Missing argument 1 for cwppos_show_review(), called in /www/wwwroot/xbao.org/wp-content/themes/flat/content-single.php on line 29 and defined in /www/wwwroot/xbao.org/wp-content/plugins/wp-product-review/includes/legacy.php on line 18 找到cwppos_show_review();函数调用的地方，将其改为cwppos_show_review(void);]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt4->Qt5 error]]></title>
    <url>%2F2018%2F06%2F22%2FQt4-Qt5-error%2F</url>
    <content type="text"><![CDATA[“error: C1083: 无法打开包括文件: “QWidget”: No such file or directory”在.pro文件中添加 1greaterThan(QT_MAJOR_VERSION, 4): QT += widgets “error: C1083: 无法打开包括文件: “QSound”: No such file or directory”在.pro文件中添加 1greaterThan(QT_MAJOR_VERSION, 4): QT += multimedia]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ PL IRQ PS]]></title>
    <url>%2F2018%2F06%2F11%2FZYNQ-PL-IRQ-PS%2F</url>
    <content type="text"><![CDATA[ZYNQ中断 PS侧C代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222/* * Copyright (c) 2009 Xilinx, Inc. All rights reserved. * * Xilinx, Inc. * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A * COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS * ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY * AND FITNESS FOR A PARTICULAR PURPOSE. * */ /* * helloworld.c: simple test application */ /***************************** Include Files ********************************/#include &lt;stdio.h&gt;#include "platform.h"#include "xil_io.h"#include "xil_mmu.h"#include "xil_exception.h"#include "xpseudo_asm.h"#include "xil_types.h"#include "xparameters.h"#include "xparameters_ps.h"#include "xplatform_info.h"#include "xil_printf.h"#include "math.h"#include "xscutimer.h"#include "xil_cache.h"#include "xscugic.h"#include "sleep.h"#include "xreg_cortexa9.h"#include "xil_assert.h"#include "xdebug.h"#include "xtime_l.h" /************************** Constant Definitions ****************************/#define INTC XScuGic#define INTC_DEVICE_ID XPAR_PS7_SCUGIC_0_DEVICE_ID#define INTC_HANDLER XScuGic_InterruptHandler#define PL_IRQ_ID XPS_IRQ_INT_ID#define IRQ_PCORE_GEN_BASE XPAR_IRQ_GEN_0_BASEADDR#define XPAR_IRQ_GEN_0_BASEADDR 0x10000000 /**************************** Type Definitions ******************************/typedef struct &#123; u16 DeviceId; /**&lt; Unique ID of device */ u32 BaseAddress; /**&lt; Base address of the device */&#125; Pl_Config; typedef struct &#123; Pl_Config Config; /**&lt; Hardware Configuration */ u32 IsReady; /**&lt; Device is initialized and ready */ u32 IsStarted; /**&lt; Device is running */&#125; XPlIrq; /***************** Macros (Inline Functions) Definitions ********************/ /************************** Variable Definitions ****************************//* Assign the driver structures for the interrupt controller *//* 为中断控制器分配驱动程序结构 */INTC IntcInstancePtr;XPlIrq PlIrqInstancePtr; static unsigned long g_read_period;int g_intr0count; /************************** Function Prototypes *****************************/static int SetupIntrSystem(INTC *IntcInstancePtr, XPlIrq *PeriphInstancePtr, u16 IntrId);static void PlIntrHandler(void *CallBackRef); #define sev() __asm__("sev")#define CPU1STARTADR 0xFFFFFFF0#define CPU1STARTMEM 0x20000000void StartCpu1(void)&#123; Xil_Out32(CPU1STARTADR, CPU1STARTMEM); dmb(); //waits until write has finished sev(); printf("CPU0 启动 CPU1\r\n");&#125; /*****************************************************************************//* * main() *//******************************************************************************/int main()&#123; int Status; init_platform(); printf("CPU0 : start\r\n"); //StartCpu1(); g_intr0count = 0; PlIrqInstancePtr.Config.DeviceId = PL_IRQ_ID; PlIrqInstancePtr.Config.BaseAddress = IRQ_PCORE_GEN_BASE; PlIrqInstancePtr.IsReady = XIL_COMPONENT_IS_READY; PlIrqInstancePtr.IsStarted = 0; printf("PL_IRQ_ID : %d\r\n", PL_IRQ_ID); /* Connect the PL IRQ to the interrupt subsystem so that interrupts can occur*/ /* 将PL IRQ连接到中断子系统，以便可能发生中断 */ Status = SetupIntrSystem(&amp;IntcInstancePtr,&amp;PlIrqInstancePtr,PL_IRQ_ID); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; //Xil_Out32(0x40000300, 0xffffffff); while(1) &#123; print("CPU0 main() while(1): Hello World\n\r"); sleep(1); &#125; printf("CPU0 : end\r\n"); cleanup_platform(); return 0;&#125; static int SetupIntrSystem(INTC *IntcInstancePtr, XPlIrq *PeriphInstancePtr, u16 IntrId)&#123; int Status; XScuGic_Config *IntcConfig; /* Initialize the interrupt controller driver so that it is ready to use. */ /* 初始化中断控制器驱动程序，以使其可以使用。 */ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); if (NULL == IntcConfig) &#123; return XST_FAILURE; &#125; Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) &#123; return XST_FAILURE; &#125; /* Connect the interrupt handler that will be called when an interrupt occurs for the device. */ /* 连接将在设备发生中断时调用的中断处理程序。 */ Status = XScuGic_Connect(IntcInstancePtr, IntrId, (Xil_ExceptionHandler)PlIntrHandler, PeriphInstancePtr); if (Status != XST_SUCCESS) &#123; return Status; &#125; /* Enable the interrupt for the PL device. 启用PL设备的中断。 */ XScuGic_Enable(IntcInstancePtr, IntrId); /* Initialize the exception table 初始化异常表 */ Xil_ExceptionInit(); /* Register the interrupt controller handler with the exception table */ /* 用异常表注册中断控制器处理程序 */ Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)INTC_HANDLER, IntcInstancePtr); /* Enable non-critical exceptions 启用非关键性例外 */ Xil_ExceptionEnable(); return XST_SUCCESS;&#125; static void PlIntrHandler(void *CallBackRef)&#123; XPlIrq *InstancePtr = (XPlIrq *)CallBackRef; //XTime time_start=0; //XTime time_end=0;//#define IRTCOUNT (*(volatile unsigned long*)(0x4000012c))//#define IRTCOUNT1 (*(volatile unsigned long*)(0x40000130)) /* * Clear the interrupt source */ //Xil_Out32(InstancePtr-&gt;Config.BaseAddress, 10); //Xil_Out32(0xf8f01280, 0xFFFFFFFF); g_intr0count++; //XTime_GetTime(&amp;time_start); //IRTCOUNT = 0x0DF; //IRTCOUNT1 = g_intr0count; //XTime_GetTime(&amp;time_end); //g_read_period = (time_end)-(time_start); printf("CPU0 PlIntrHandler() :%d \r\n", g_intr0count);&#125;]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 LTS如何设置SSH服务]]></title>
    <url>%2F2018%2F06%2F08%2FUbuntu-16-04-LTS%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AESSH%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[首先,确定是否有安装SSH服务 1root@ubuntu:/# ps -e | grep ssh* 如果没有任何显示,则没有安装该服务 安装SSH-server 1root@ubuntu:/# apt-get install openssh-server 接着安装SSH-client 1root@ubuntu:/# apt-get install openssh-client 确认安装SSH服务成功与否 12root@ubuntu:/# ps -e|grep sshd15362 ? 00:00:00 sshd 此时就可以使用普通账户来远程登陆设备了，但是若使用root账户登陆，会出现“SSH服务器拒绝了密码”。这是由于SSH服务默认配置不允许使用root用户登录这里需要修改配置文件，打开配置文件 1root@ubuntu:/# vi /etc/ssh/sshd_config 找到如下一行 1PermitRootLogin prohibit-password 修改为 1PermitRootLogin yes 保存退出。重启SSH服务 1root@ubuntu:/# systemctl restart sshd 再次连接，既可以使用root账户登陆]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FRP基础应用之ssh]]></title>
    <url>%2F2018%2F06%2F08%2FFRP%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E4%B9%8Bssh%2F</url>
    <content type="text"><![CDATA[Server端 下载FRP，到https://github.com/fatedier/frp获取最新版本连接，目前最新版本0.20.0 1wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_386.tar.gz 解压文件 1tar -zxvf frp_0.13.0_linux_amd64.tar.gz 进入文件夹 12345root@ubuntu-HelloWorld:~# lsfrp_0.20.0_linux_386 frp_0.20.0_linux_386.tar.gz startFrpc.shroot@ubuntu-HelloWorld:~# cd frp_0.20.0_linux_386/root@ubuntu-HelloWorld:~/frp_0.20.0_linux_386# lsfrpc frpc_full.ini frpc.ini frps frps_full.ini frps.ini LICENSE frpc为与客户端相关的；frps为与服务端相关的 打开frps.ini,改为 123456[common]bind_port = 17000 # 绑定端口，与client端一致dashboard_port = 17500 # 网页管理地址端口，直接在网页输入IP:dashboard_port# dashboard 用户名密码，默认都为 admindashboard_user = admindashboard_pwd = admin 运行 1./frps -c ./frps.ini 但是这样，在关闭ssh窗口后，程序也随之关闭。程序保持后台运行。 1nohup ./frps -c ./frps.ini &amp;amp; Client 下载FRP，到https://github.com/fatedier/frp获取最新版本连接，目前最新版本0.20.0 1wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_386.tar.gz 解压文件 1tar -zxvf frp_0.13.0_linux_amd64.tar.gz 进入文件夹 12345root@ubuntu-HelloWorld:~# lsfrp_0.20.0_linux_386 frp_0.20.0_linux_386.tar.gz startFrpc.shroot@ubuntu-HelloWorld:~# cd frp_0.20.0_linux_386/root@ubuntu-HelloWorld:~/frp_0.20.0_linux_386# lsfrpc frpc_full.ini frpc.ini frps frps_full.ini frps.ini LICENSE frpc为与客户端相关的；frps为与服务端相关的 打开frpc.ini,修改为 123456789[common]server_addr = 1**.1*2.1*0.*3 # Server端IPserver_port = 17000 # 绑定端口，与Server端一致 [ssh]type = tcplocal_ip = 127.0.0.1 # 需要访问的本地设备IP，1270.0.1代表本机，即运行frpc的电脑local_port = 22 # 需要访问本地的端口remote_port = 6000 # 通过远程端访问的端口 编写脚本startFrpc.sh运行frpc 12# 与实际文件路径保持一致/root/frp_0.20.0_linux_386/frpc -c /root/frp_0.20.0_linux_386/frpc.ini 执行./startFrpc.sh, 运行Client端。此时即可以实现远程SSH 将startFrpc.sh添加至开机启动，修改系统自带开机脚本/etc/rc.local首先备份1cp /etc/rc.local /etc/rc.local.bak 打开/etc/rc.local 12345678910111213141516vi /etc/rc.local #!/bin/sh -e## rc.local## This script is executed at the end of each multiuser runlevel.# Make sure that the script will "exit 0" on success or any other# value on error.## In order to enable or disable this script just change the execution# bits.## By default this script does nothing. exit 0 在exit 0前，添加 1/root/startFrpc.sh # 与实际文件路径匹配 注： 使用腾讯云时，需要在安全组中开放相关的端口 控制面板-&gt;安全-&gt;安全组 使用宝塔面板时，需要在系统安全中放行相关端口 首页-&gt;安全-&gt;端口控制-&gt;放行]]></content>
      <categories>
        <category>FRP</category>
      </categories>
      <tags>
        <tag>FRP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux各种压缩解压命令]]></title>
    <url>%2F2018%2F06%2F06%2FLinux%E5%90%84%E7%A7%8D%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）——————————————— .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName——————————————— .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName——————————————— .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知——————————————— .Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName——————————————— .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName———————————————.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName rar请到：http://www.rarsoft.com/download.htm 下载！解压后请将rar_static拷贝到/usr/bin目录（其他由$PATH环境变量指定的目录也可以）：[root@www2 tmp]# cp rar_static /usr/bin/rar——————————————— .lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName lha请到：http://www.infor.kanazawa-it.ac.jp/~ishii/lhaunix/下载！&gt;解压后请将lha拷贝到/usr/bin目录（其他由$PATH环境变量指定的目录也可以）：[root@www2 tmp]# cp lha /usr/bin/——————————————— .rpm解包：rpm2cpio FileName.rpm | cpio -div——————————————— .deb解包：ar p FileName.deb data.tar.gz | tar zxf –——————————————— .tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea解压：sEx x FileName.* 压缩：sEx a FileName.* FileName sEx只是调用相关程序，本身并无压缩、解压功能，请注意！sEx请到： http://sourceforge.net/projects/sex下载！解压后请将sEx拷贝到/usr/bin目录（其他由$PATH环境变量指定的目录也可以）：[root@www2 tmp]# cp sEx /usr/bin/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu环境 Qt编译错误“GL/gl.h:No such file or directory”]]></title>
    <url>%2F2018%2F06%2F06%2FUbuntu%E7%8E%AF%E5%A2%83-Qt%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E2%80%9CGL-gl-h-No-such-file-or-directory%E2%80%9D%2F</url>
    <content type="text"><![CDATA[Ubuntu环境 Qt编译错误“GL/gl.h:No such file or directory”的解决方法编译时出现了如下错误：“GL/gl.h:No such file or directory”。这是因为系统中没有安装OpenGL库。安装OpenGL库及其工具即可 1sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu_Qt_error: cannot find -lGL]]></title>
    <url>%2F2018%2F06%2F06%2FUbuntu-Qt-error-cannot-find-lGL%2F</url>
    <content type="text"><![CDATA[Ubuntu Qt 12:-1: error: cannot find -lGL:-1: error: collect2: error: ld returned 1 exit status https://blog.csdn.net/Hhrock/article/details/61621044 1sudo apt-get install libgl1-mesa-dev 安装 libgl1-mesa-dev。]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04换源]]></title>
    <url>%2F2018%2F06%2F05%2FUbuntu-18-04%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[国内有很多Ubuntu的镜像源，包括阿里、网易，还有很多教育网的源，比如：清华源、中科大源。何修改Ubuntu 18.04里面默认的源。 首先备份，sources.list文件用于恢复 1cp /etc/apt/sources.list /etc/apt/sources.list.bak 打开/etc/apt/sources.list文件, 在文件最前面添加以下条目，添加其中一个就好 123456789101112##中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 123456789101112## 阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 123456789101112## 163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse 123456789101112## 清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 添加后保存文件，执行如下命令12sudo apt-get updatesudo apt-get upgrade]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE激活]]></title>
    <url>%2F2018%2F05%2F25%2FUE%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[本方法来源与互联网，如有侵权请联系删除 注册机下载：点击下载UltraEdit_keygen.exe 1. 断网请拔掉网线、关闭Wifi，或者禁用网卡。 2. 打开UltraEdit后，弹出对话框，点击“输入许可证密钥” 许可证ID和密码随便填写，建议全部输入数字 点击激活，稍等一会，会弹出“脱机激活”的窗口 3. 点击“脱机激活”，会出现如下界面输入刚刚输入的许可证ID和密码 4. 打开下载好的注册机将“脱机激活”窗口上的用户名1和用户名2填写到注册机 点击生成 5. 激活UltraEdit将注册机生成的验证码1和验证码2填写到“脱机激活”窗口，点击“激活”]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug Assertion Failed!]]></title>
    <url>%2F2018%2F05%2F16%2FDebug-Assertion-Failed%2F</url>
    <content type="text"><![CDATA[Debug Assertion Failed 是Debug模式下生成的应用运行时触发了断言，aseert是调试追踪错误的一种手段，错误提示中应该有提到引发错误处的文件及行号和错误原因，查下调用堆栈看看是什么函数调用了导致了断言，然后修改相应代码。 一般问题为： 野指针; 2.内存泄露 解决方法: 看一看你的程序里是不是有ASSERT（）或VERIFY（）语句。这两个宏是用来测试它的参数是否为真的。出现你说的，这说明你的指针或表达试有问题 vc++中遇到过此问题，在release下回忽略此问题,其实就是野指针的问题，在release版本下不用关心这个问题，也就是系统帮你给屏蔽了，但是问题还是存在的，真正使用的时候，偶尔会出来给你报个小错。创建窗体等的时候没有new，但是在析构的时候delete了，就会在debug环境下，报这样的错误。打开”编译”-&gt;”配置”-&gt;”把里面除了release其他的选项全部删除,再构件就OK了 首先如果你用的是vc6的话：a.按F5运行你的程序b.在出错时，选择“重试”c.按ALT+7调出“调用栈”窗口d.双击从上往下的最近一个自己定义的函数，系统会自动把该函数所在的文件显示出来，此时程序就暂停在光标处。一般来说错误就出在这附近。你可以通过查看变量的值来确认 可以先声明一个临时的CString变量然后作为暂存,然后把你取得的值放入其中,之后再赋给另一个你要使用的变量,即可解决问题 可能是在编写函数调用指针变量时没有分配空间（如果是在类中定义的指针变量，则指针在多个函数中引用时要分别重新分配空间），检查一下。 类似的问题，可能是因为输出对象创建不成功，于是使用的时候用的就是空的对象，于是就出现问题了。 “build-&gt;clean” ”Project”-&gt;”setting”-&gt;”点击c/c++”-&gt;”Category选项中选择Preprocessor”-&gt;”在Undefined symbols:填写_DEBUG” 重新编译运行即可]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 产生伪随机数]]></title>
    <url>%2F2018%2F05%2F15%2FC-%E4%BA%A7%E7%94%9F%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[计算机的随机数都是由伪随机数，即是由小M多项式序列生成的，其中产生每个小序列都有一个初始值，即随机种子。（注意： 小M多项式序列的周期是65535，即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。） 我们知道rand()函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统。 主要用到三个函数rand()函数, srand()函数, time()函数 1. rand()功能: 随机数发生器用法: int rand(void)所在头文件: stdlib.h rand()的内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。rand()返回一随机数值的范围在0至RAND_MAX 间。RAND_MAX的范围最少是在32767之间(int)。用unsigned int 双字节是65535，四字节是4294967295的整数范围。0~RAND_MAX每个数字被选中的机率是相同的。用户未设定随机数种子时，系统默认的随机数种子为1。 rand()产生的是伪随机数字，每次执行时是相同的;若要产生不同数,用函数srand()初始化它。 2. srand()功能: 初始化随机数发生器用法: void srand(unsigned int seed)所在头文件: stdlib.h srand()用来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。 3. 使用当前时钟作为随机数种子rand()产生的随机数在每次运行的时候都是与上一次相同的。若要不同,用函数srand()初始化它。可以利用srand((unsigned int)(time(NULL))的方法，产生不同的随机数种子，因为每一次运行程序的时间是不同的。 4. 产生随机数的用法1) 给srand()提供一个种子，它是一个unsigned int类型；2) 调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；3) 根据需要多次调用rand()，从而不间断地得到新的随机数；4) 无论什么时候，都可以给srand()提供一个新的种子，从而进一步“随机化”rand()的输出结果。 0~RAND_MAX之间的随机数程序 12345678910111213141516#include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; using namespace std; int main() &#123; srand((unsigned)time(NULL)); for(int i = 0; i &lt; 10;i++ ) &#123; cout &lt;&lt; rand() &lt;&lt; '\t'; &#125; cout &lt;&lt; endl; return 0; &#125; 5. 产生一定范围随机数的通用表示公式要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MFC CString与数字之间的转换]]></title>
    <url>%2F2018%2F05%2F15%2FMFC-CString%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[CString转数字CString转int 12CString str; int i=_ttoi(str); CString转double(float) 12CString str; double d =_ttof(str); 数字转CString12345int i = 123; double d = 3.1415926;CString str; str.Format(_T(&quot;%d&quot;), i); str.Format(_T(&quot;%f&quot;), d);]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ 定时器中断]]></title>
    <url>%2F2018%2F05%2F10%2FZYNQ-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[1. 建立软硬件工程建立HelloWorld工程，具体方法参照ZYNQ Vivado环境实现Helloworld，并启用DDR，启用DDR方式见ZYNQ AMP模式 双裸核CPU同时运行 2. 验证HelloWorld工程正确3. 修改HelloWorld.c3.1 包含相关头文件1234567#include &lt;stdio.h&gt;#include "platform.h"#include "xil_types.h"#include "xscugic.h"#include "xscutimer.h"#include "xil_exception.h"#include "xil_printf.h" 3.2 添加中断系统建立函数123456789101112131415161718192021222324252627282930313233343536// 中断系统建立函数 SetupTimerInterruptSystem，完成中断控制模块 GIC 的初始化，中断处理函数的 Register， Enable 等功能static void SetupTimerInterruptSystem(XScuGic * GicInstPtr, XScuTimer * TimerInstPtr, u32 TimerInterruptId)&#123; //--------------------------------------------------------------------------- // Interrupt Controller initialization 中断控制器初始化 //--------------------------------------------------------------------------- // Looks up the GIC device configuration based on the unique device ID 根据唯一的设备ID查找GIC设备配置 XScuGic_Config * XScuGic_Config_ptr; XScuGic_Config_ptr = XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID); // CfgInitialize a specific interrupt controller instance/driver CfgInitialize特定的中断控制器实例/驱动程序 XScuGic_CfgInitialize(GicInstPtr, XScuGic_Config_ptr, XScuGic_Config_ptr-&gt;CpuBaseAddress); //--------------------------------------------------------------------------- // Interrupt system setup 中断系统设置 //--------------------------------------------------------------------------- // Makes the connection between the Id of the exception source and the associated Handler // 在异常源的Id和相关的Handler之间建立连接 Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, GicInstPtr); // Enable Exceptions 启用例外 Xil_ExceptionEnableMask(XIL_EXCEPTION_IRQ); //--------------------------------------------------------------------------- // Register Interrupt Handler 寄存器中断处理程序 //--------------------------------------------------------------------------- // Makes the connection between the Int_Id of the interrupt source and the associated handler // 在中断源的Int_Id和关联的处理程序之间建立连接 XScuGic_Connect(GicInstPtr, TimerInterruptId, (Xil_ExceptionHandler)TimerInterruptHandler, (void*)TimerInstPtr); //--------------------------------------------------------------------------- // Enable Timer interrupt in the controller 在控制器中启用定时器中断 //--------------------------------------------------------------------------- // Enable the Timer interrupt 启用定时器中断 XScuTimer_EnableInterrupt(TimerInstPtr); // Enables the interrupt source provided as the argument Int_Id 启用作为参数Int_Id提供的中断源 XScuGic_Enable(GicInstPtr, TimerInterruptId);&#125; 3.3 添加中断服务函数12345678910// 中断服务程序 TimerInterruptHandler，当中断发生时进行信息打印并 Clear 中断状态static void TimerInterruptHandler(void * CallBackRef)&#123; static int sec = 0; printf("Seconds Count: %d\r\n", sec++); // Clears the interrupt status XScuTimer * TimerInstPtr = (XScuTimer *) CallBackRef; XScuTimer_ClearInterruptStatus(TimerInstPtr);&#125; 3.4 在main函数前添加函数声明12345// 函数声明// 中断系统建立函数 SetupTimerInterruptSystem，完成中断控制模块 GIC 的初始化，中断处理函数的 Register， Enable 等功能static void SetupTimerInterruptSystem(XScuGic * GicInstPtr, XScuTimer * TimerInstPtr, u32 TimerInterruptId);// 中断服务程序 TimerInterruptHandler，当中断发生时进行信息打印并 Clear 中断状态static void TimerInterruptHandler(void * CallBackRef); 3.5 修改main函数为123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; init_platform(); //--------------------------------------------------------------------------- // Timer initialization 定时器初始化 // Zynq 中每一个模块都要查找硬件信息表，之后配置相应的软件驱动后才可以使用。 //--------------------------------------------------------------------------- // Lookup the Timer configuration based on the unique device ID // 基于唯一设备ID查找定时器配置 XScuTimer_Config * TimerConfigPtr; TimerConfigPtr = XScuTimer_LookupConfig(XPAR_XSCUTIMER_0_DEVICE_ID); // Initialize a specific timer instance/driver // 初始化一个特定的定时器实例/驱动程序 XScuTimer XScuTimerInst; XScuTimer_CfgInitialize(&amp;XScuTimerInst, TimerConfigPtr, TimerConfigPtr-&gt;BaseAddr); // Run a self-test on the timer 在定时器上运行自检 XScuTimer_SelfTest(&amp;XScuTimerInst); //--------------------------------------------------------------------------- // Timer configure 定时器配置 //--------------------------------------------------------------------------- // Write to the timer load register 写入定时器加载寄存器 // From ARM DDI0407I_cortex_a9_mpcore_r4p1_trm.pdf reference, timers are always // clocked at 1/2 of the CPU frequency (CPU_3x2x), now CPU frequency now is 666MHz, so the timer is 333MHz // 333_000_000 * 1(s) - 1 = 332_999_999 = 0x13D92D3F XScuTimer_LoadTimer(&amp;XScuTimerInst, 0x13D92D3F); // Enable auto-reload mode 启用自动重新加载模式 XScuTimer_EnableAutoReload(&amp;XScuTimerInst); // Start timer 启动计时器 XScuTimer_Start(&amp;XScuTimerInst); //--------------------------------------------------------------------------- // Interrupt System setup 中断系统设置 //--------------------------------------------------------------------------- XScuGic XScuGicInst; SetupTimerInterruptSystem(&amp;XScuGicInst, &amp;XScuTimerInst, XPAR_SCUTIMER_INTR); printf("&gt;&gt;&gt; START...\n"); while(1) &#123;;&#125; cleanup_platform(); return 0;&#125; 3.6 保存编译下载验证。]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xilinx SDK 16.4显示行号]]></title>
    <url>%2F2018%2F05%2F09%2FXilinx-SDK-16-4%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[菜单栏Window → preferences preferences页面 → General → Editors → Test Editors → Show line numbers]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ AMP模式 双裸核CPU同时运行]]></title>
    <url>%2F2018%2F05%2F09%2FZYNQ-AMP%E6%A8%A1%E5%BC%8F-%E5%8F%8C%E8%A3%B8%E6%A0%B8CPU%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[从软件的角度来看，多核处理器的运行模式有三种：AMP（非对称多进程）：多个核心相对独立的运行不同的任务，每个核心可能运行不同的操作系统或裸机程序，但是有一个主要核心，用来控制整个系统以及其它从核心SMP（对称多进程）：一个操作系统同等的管理各个内核，例如PC机BMP（受约束多进程）：与SMP类似，但开发者可以指定将某个任务仅在某个指定内核上执行默认情况下，ZYNQ仅运行一个CPU，这里主要研究AMP模式下，两个CPU同时运行 1. 硬件平台搭建参照“ZYNQ Vivado环境实现Helloworld”的Vivado部分,但有部分不同。“ZYNQ Vivado环境实现Helloworld”中ZYNQ系统的配置部分“未启用DDR”，本次需要“启用DDR” 导出至SDK 2. SDK2.1 创建CPU0工程创建普通的helloworld工程 修改helloworld.c主函数 123456789101112131415161718// 包含头文件#include "sleep.h" int main()&#123; init_platform(); print("CPU0 : Hello World\n\r"); for(int i = 0; i &lt; 10; i++) &#123; printf("CPU0 : Hello World: %d\r\n", i); sleep(2); &#125; printf("CPU0 : end\r\n"); cleanup_platform(); return 0;&#125; 2.2 创建CPU1工程创建普通的helloworld工程,选择CPU1 修改helloworld.c主函数 12345678910111213141516171819// 包含头文件#include "sleep.h" int main()&#123; //init_platform(); sleep(3); print("CPU1 : Hello World\r\n"); for(int i = 0; i &lt; 10; i++) &#123; printf("CPU1 : Hello World: %d\r\n", i); sleep(3); &#125; printf("CPU1 : end\r\n"); cleanup_platform(); return 0;&#125; 2.3 CPU1的BSP SETTING中添加” -DUSE_AMP=1 “在CPU1的bsp目录上，右键，选择“Board Support Package Settings” 2.4 DDR空间分配每个CPU的APP项目的src目录中按照自己预想的存储器分配方案修改lscript.ld文件中的内容，千万注意不要让两个CPU的DDR地址重合，因为你APP的ELF文件是加载到DDR中执行的。由于没有OS，ELF肯定是加载到每个CPU的DDR起始地址。如果有重合那么一个CPU的ELF会覆盖另一个的。 CPU0 CPU1 2.5 CPU0启动CPU1一般情况下程序运行只会启动CPU0，需要使用CPU0启动CPU1在CPU0的helloworld.c文件中添加函数 1234567891011#define sev() __asm__("sev")#define CPU1STARTADR 0xFFFFFFF0#define CPU1STARTMEM 0x20000000void StartCpu1(void)&#123; Xil_Out32(CPU1STARTADR, CPU1STARTMEM); dmb(); //waits until write has finished sev(); printf("CPU0 启动 CPU1\r\n");&#125; 并在主函数中调用StartCpu1(); 2.6 运行调试保存CPU0、CPU1工程，编译，运行 2.7 串口打印结果]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C字符串与数字之间的转换]]></title>
    <url>%2F2018%2F05%2F05%2FC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[字符串转“数”atoi()头文件：#include &lt;stdlib.h&gt; atoi() 函数用来将字符串转换成整数(int)，其原型为：int atoi (const char * str); 【函数说明】atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。 【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。范例：将字符串a 与字符串b 转换成数字后相加。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; int i; char buffer[256]; printf ("Enter a number: "); fgets (buffer, 256, stdin); i = atoi (buffer); printf ("The value entered is %d.", i); system("pause"); return 0;&#125; atof()头文件：#include &lt;stdlib.h&gt; 函数 atof() 用于将字符串转换为双精度浮点数(double)，其原型为：double atof (const char* str); atof() 的名字来源于 ascii to floating point numbers 的缩写，它会扫描参数str字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。参数str 字符串可包含正负号、小数点或E(e)来表示指数部分，如123. 456 或123e-2。 【返回值】返回转换后的浮点数；如果字符串 str 不能被转换为 double，那么返回 0.0。范例： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *a = "-100.23", *b = "200e-2", *c = "341", *d = "100.34cyuyan", *e = "cyuyan"; printf("a = %.2f\n", atof(a)); printf("b = %.2f\n", atof(b)); printf("c = %.2f\n", atof(c)); printf("d = %.2f\n", atof(d)); printf("e = %.2f\n", atof(e)); system("pause"); return 0;&#125; atol()头文件：#include &lt;stdlib.h&gt; atol() 函数的名字源于“ascii to long”，用来将字符串转换成长整型数(long)，其原型为：long atol(const char * str); 【函数说明】atol() 会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。 【返回值】返回转换后的长整型数(long)；如果 str 不能转换成 long 或者 str 为空字符串，那么将返回 0。示例：将输入的字符串转换成long。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; long int li; char buffer[256]; printf ("Enter a long number: "); fgets(buffer, 256, stdin); li = atol(buffer); printf ("The value entered is %ld.\n", li); system("pause"); return 0;&#125; strtol()头文件：#include &lt;stdlib.h&gt; strtol() 函数用来将字符串转换为长整型数(long)，其原型为：long int strtol (const char* str, char** endptr, int base); 【参数说明】str 为要转换的字符串，endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制。 【函数说明】strtol() 会将参数 str 字符串根据参数 base 来转换成长整型数(long)。参数 base 范围从2 至36，或0。参数base 代表 str 采用的进制方式，如base 值为10 则采用10 进制，若base 值为16 则采用16 进制等。 strtol() 会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(‘\0’)结束转换，并将结果返回。 两点注意：当 base 的值为 0 时，默认采用 10 进制转换，但如果遇到 ‘0x’ / ‘0X’ 前置字符则会使用 16 进制转换，遇到 ‘0’ 前置字符则会使用 8 进制转换。若endptr 不为NULL，则会将遇到的不符合条件而终止的字符指针由 endptr 传回；若 endptr 为 NULL，则表示该参数无效，或不使用该参数。 【返回值】返回转换后的长整型数；如果不能转换或者 str 为空字符串，那么返回 0(0L)；如果转换得到的值超出 long int 所能表示的范围，函数将返回 LONG_MAX 或 LONG_MIN（在 limits.h 头文件中定义），并将 errno 的值设置为 ERANGE。【示例】将字符串转换成10进制。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; char szNumbers[] = "2001 60c0c0 -1101110100110100100000 0x6fffff"; char * pEnd; long int li1, li2, li3, li4; li1 = strtol (szNumbers,&amp;amp;amp;amp;pEnd,10); li2 = strtol (pEnd,&amp;amp;amp;amp;pEnd,16); li3 = strtol (pEnd,&amp;amp;amp;amp;pEnd,2); li4 = strtol (pEnd,NULL,0); printf ("转换成10进制: %ld、%ld、%ld、%ld\n", li1, li2, li3, li4); system("pause"); return 0;&#125; strtoul()头文件：#include &lt;stdlib.h&gt; strtoul() 函数源自于“string to unsigned long”，用来将字符串转换成无符号长整型数(unsigned long)，其原型为：unsigned long strtoul (const char* str, char** endptr, int base); 【参数说明】str 为要转换的字符串，endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制。 【函数说明】strtoul() 会将参数 str 字符串根据参数 base 来转换成无符号的长整型数(unsigned long)。参数 base 范围从2 至36，或0。参数 base 代表 str 采用的进制方式，如 base 值为10 则采用10 进制，若 base 值为16 则采用16 进制数等。 strtoul() 会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(‘\0’)结束转换，并将结果返回。 两点注意：当 base 的值为 0 时，默认采用 10 进制转换，但如果遇到 ‘0x’ / ‘0X’ 前置字符则会使用 16 进制转换，遇到 ‘0’ 前置字符则会使用 8 进制转换。若 endptr 不为NULL，则会将遇到的不符合条件而终止的字符指针由 endptr 传回；若 endptr 为 NULL，则表示该参数无效，或不使用该参数。本文最后的范例没有展示 endptr 参数的使用，你可以参考 strtol() 函数的范例来更加直观地了解 endptr 参数。 【返回值】返回转换后的无符号长整型数；如果不能转换或者 str 为空字符串，那么返回 0；如果转换得到的值超出unsigned long int 所能表示的范围，函数将返回 ULONG_MAX（在 limits.h 头文件中定义），并将 errno 的值设置为 ERANGE。范例：将输入的字符串转换为无符号长整型。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main ()&#123; char buffer [256]; unsigned long ul; printf ("Enter an unsigned number: "); fgets (buffer, 256, stdin); ul = strtoul (buffer, NULL, 0); printf ("Value entered: %lu.\n", ul); system("pause"); return 0;&#125; strtod()头文件：#include &lt;stdlib.h&gt; 函数 strtod() 用来将字符串转换成双精度浮点数(double)，其原型为：double strtod (const char* str, char** endptr); 【参数说明】str 为要转换的字符串，endstr 为第一个不能转换的字符的指针。 【函数说明】strtod() 函数会扫描参数str字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，到出现非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。参数 str 字符串可包含正负号、小数点或E(e)来表示指数部分。如123. 456 或123e-2。 若endptr 不为NULL，则会将遇到的不符合条件而终止的字符指针由 endptr 传回；若 endptr 为 NULL，则表示该参数无效，或不使用该参数。 【返回值】返回转换后的浮点型数；若不能转换或字符串为空，则返回 0.0。【示例】计算月球每年绕地球运行多少圈。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char szOrbits[] = "365.24 29.53"; char* pEnd; double d1, d2; d1 = strtod (szOrbits, &amp;amp;amp;amp;pEnd); d2 = strtod (pEnd, NULL); printf ("月球每年绕地球运行 %.2f 周。\n", d1/d2); system("pause"); return 0;&#125; “数”转字符串itoa()、sprintf() itoa()通常在头文件&lt;stdlib.h&gt;/头文件中包含这个函数itoa()函数的原型为： char *itoa( int value, char *string,int radix); itoa()函数有3个参数：第一个参数是要转换的数字，第二个参数是要写入转换结果的目标字符串，第三个参数是转换数字时所用的基数。在例中，转换基数为10。10：十进制；2：二进制… itoa是广泛应用的非标准C语言和C++语言扩展函数，但它不是标准C/C++语言函数，所以不能在所有的编译器中使用。itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。 sprintf()sprintf()是字符串格式化命令，主要功能是把格式化的数据写入某个字符串中。它是个变参函数，是C标准库中的函数，包含在&lt;stdio.h&gt;中。原型int sprintf( char buffer, const char *format, [ argument] … );*参数列表** buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。[argument]…：可选参数，可以是任何类型的数据。返回值返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL。sprintf 返回被写入buffer 的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的buffer后，函数sprintf 返回5。 注意：使用sprintf 对于写入buffer的字符数是没有限制的，这就存在了可能buffer溢出。解决这个问题，可以考虑使用 snprintf函数，该函数可对写入字符数做出限制。 sprintf()示例源码 1234567891011121314// 程序使用sprintf 将各种数据格式化后置于字符数组buffer中#include &lt;stdio.h&gt;int main( void )&#123; char buffer[200], s[] = "computer", c = 'l'; int i = 35, j=0; float fp = 1.7320534f; // 格式化并打印各种数据到buffer j = sprintf( buffer, " String: %s\n", s ); j += sprintf( buffer + j, " Character: %c\n", c ); j += sprintf( buffer + j, " Integer: %d\n", i ); j += sprintf( buffer + j, " Real: %f\n", fp ); printf( "Output:\n%s\ncharacter count = %d\n", buffer, j );&#125; 使用格式格式 sprintf格式的规格如下所示，[]中的部分是可选的。%[指定参数][标识符][宽度][.精度]指示符若想输出’%’本身时, 请使用’%%’处理。 处理字符方向。负号时表示从后向前处理。 填空字元。 0 的话表示空格填 0；空格是内定值，表示空格就放着。 字符总宽度。为最小宽度。 精确度。指在小数点后的浮点数位数。 转换字符 %% 印出百分比符号，不转换。%c 整数转成对应的 ASCII 字元。%d 整数转成十进位。%f 倍精确度数字转成浮点数。%o 整数转成八进位。%s 整数转成字符串。%x 整数转成小写十六进位。%X 整数转成大写十六进位。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C字符串拼接与分割]]></title>
    <url>%2F2018%2F05%2F05%2FC%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E4%B8%8E%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[strcat()、strtok() strcat()头文件：#include &lt;string.h&gt; strcat() 函数用来连接字符串，其原型为：char *strcat(char *dest, const char *src); 【参数】dest 为目的字符串指针，src 为源字符串指针。 strcat() 会将参数 src 字符串复制到参数 dest 所指的字符串尾部；dest 最后的结束字符 NULL 会被覆盖掉，并在连接后的字符串的尾部再增加一个 NULL。 注意：dest 与 src 所指的内存空间不能重叠，且 dest 要有足够的空间来容纳要复制的字符串。 【返回值】返回dest 字符串起始地址。 【实例】连接字符串并输出。 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[80]; strcpy (str,"these "); strcat (str,"strings "); strcat (str,"are "); strcat (str,"concatenated."); puts (str); return 0;&#125; strtok()头文件：#include &lt;string.h&gt; 定义函数：char * strtok(char *s, const char *delim); 函数说明：strtok()用来将字符串分割成一个个片段。参数s 指向欲分割的字符串，参数delim 则为分割字符串，当strtok()在参数s 的字符串中发现到参数delim 的分割字符时则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s 字符串，往后的调用则将参数s 设置成NULL。每次调用成功则返回下一个分割后的字符串指针。 返回值：返回下一个分割后的字符串指针，如果已无从分割则返回NULL。 范例 1234567891011121314#include &lt;string.h&gt;#include &lt;stdio.h&gt;main()&#123; char s[] = "ab-cd : ef;gh :i-jkl;mnop;qrs-tu: vwx-y;z"; char *delim = "-: "; char *p; printf("%s ", strtok(s, delim)); while((p = strtok(NULL, delim))) &#123; printf("%s ", p); &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32使用cJSON]]></title>
    <url>%2F2018%2F05%2F03%2FSTM32%E4%BD%BF%E7%94%A8cJSON%2F</url>
    <content type="text"><![CDATA[在PC中cJSON使用十分简单，只需要2个文件，一个cJSON.c 一个cJSON.h文件。(文件获取github) 在STM32中，因为牵扯到内存管理的问题，还需要malloc.c、malloc.h，（再次直接使用正点原子STM32例程中的文件）。 将cJSON、malloc文件添加到STM32工程中。 打开malloc.h文件，找到“内存参数设定”部分，更具STM32对应的资源大小修改一般只需要修改“最大管理内存”的值就行，最大管理内存不要超过实际内存 1234// 内存参数设定#define MEM_BLOCK_SIZE 16 //内存块大小#define MEM_MAX_SIZE 12*1024 //最大管理内存#define MEM_ALLOC_TABLE_SIZE MEM_MAX_SIZE/MEM_BLOCK_SIZE //内存表大小 打开cJSON.c文件，将内存管理部分进行替换 123456789// 约在文件的50行#if 0 // 原版本的内存分配static void *(*cJSON_malloc)(size_t sz) = malloc;static void (*cJSON_free)(void *ptr) = free;#else // 修改后的的内存分配//----------------------------------- modify ------------------------------------- static void *(*cJSON_malloc)(size_t sz)= mymalloc; // modify static void (*cJSON_free)(void *ptr) = myfree; // modify #endif 123456789101112131415161718192021222324252627// 约在文件的70行#if 0 // 原版本的内存分配void cJSON_InitHooks(cJSON_Hooks* hooks)&#123; if (!hooks) &#123; /* Reset hooks */ cJSON_malloc = malloc; cJSON_free = free; return; &#125; cJSON_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:malloc; cJSON_free = (hooks-&gt;free_fn)?hooks-&gt;free_fn:free;&#125;#else // 修改后的的内存分配//----------------------------------- modify ------------------------------------- void cJSON_InitHooks(cJSON_Hooks* hooks) &#123; if (!hooks) &#123; /* Reset hooks */ cJSON_malloc = mymalloc; // modify cJSON_free = myfree; // modify return; &#125; cJSON_malloc = (hooks-&gt;malloc_fn)?hooks-&gt;malloc_fn:mymalloc; // modify cJSON_free = (hooks-&gt;free_fn)?hooks-&gt;free_fn:myfree; // modify &#125; #endif 通过上面这样修改就可以运行例子了。注意 若芯片内存充足，启动文件（startup_XXX.s） 1Stack_Size EQU 0x00000400 内存释放问题 12cJSON_Delete(root);myfree(out);]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C实现CRC32校验]]></title>
    <url>%2F2018%2F05%2F02%2FC%E5%AE%9E%E7%8E%B0CRC32%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[CRC即循环冗余校验码（Cyclic Redundancy Check）：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。 crc就是一个数值，该数值用于检验数据的正确性，crc校验的原理就是将需要作校验的数据与一个数据模2相除，得到的余数即为校验值。 模2相除就是在除的过程中用模2加，模2加实际上就是异或运算，就是不进行进位操作，即相同为假，不相同为真。 下面是几种CRC校验的生成多项式：CRC8 = X8+X5+X4+1CRC-CCITT = X16+X12+X5+1CRC16=X16+X15+X2+1CRC12=X12+X11+X3+X2+1CRC32=X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1 一个多项式就是一个比特流，也就是由0、1组合起来的一组数我们需要获取的常数就是上面多项式所对应的反转多项式（反转多项式：在数据通讯时，信息字节先传送或接受低位字节，如重新排列则影响速度）。 下面使用查表法实现crc校验，具体步骤如下：（1）将上次计算出的CRC校验码右移一个字节；（2）将移出的这个字节与新的要校验的字节进行XOR 运算；（3）用运算出的值在预先生成码表中进行索引，获取对应的值（称为余式）；（4）用获取的值与第（1）步右移后的值进行XOR 运算；（5）如果要校验的数据已经处理完，则第（4）步的结果就是最终的CRC校验码。如果还有数据要进行处理，则再转到第（1）步运行。 C语言实现CRC32代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; uint32_t CRC32_table[256] = &#123; 0 &#125;;// 生成CRC32表void init_CRC32_table()&#123; for (int i = 0; i != 256; i++) &#123; uint32_t CRC = i; for (int j = 0; j != 8; j++) &#123; if (CRC &amp; 1) &#123; CRC = (CRC &gt;&gt; 1) ^ 0xEDB88320; &#125; else &#123; CRC &gt;&gt;= 1; &#125; &#125; CRC32_table[i] = CRC; &#125;&#125; // 计算CRC，方法一uint32_t GetCRC32(unsigned char* buf, unsigned int len)&#123; uint32_t CRC32_data = 0xFFFFFFFF; for (uint32_t i = 0; i != len; ++i) &#123; uint32_t t = (CRC32_data ^ buf[i]) &amp; 0xFF; CRC32_data = ((CRC32_data &gt;&gt; 8) &amp; 0xFFFFFF) ^ CRC32_table[t]; &#125; return ~CRC32_data;&#125; // 计算CRC，方法二static uint32_t crc32(const unsigned char *buf, unsigned int size)&#123; uint32_t i, crc; crc = 0xFFFFFFFF; for (i = 0; i &lt; size; i++) &#123; crc = CRC32_table[(crc ^ buf[i]) &amp; 0xff] ^ (crc &gt;&gt; 8); &#125; return crc ^ 0xFFFFFFFF;&#125; // main函数测试int main()&#123; unsigned char i[8] = &#123; 0x00,0x00,0x00,0x00,0x06,0x0d,0xd2,0xe3 &#125;; uint32_t x; // 初始化生成CRC32表 init_CRC32_table(); // 打印显示CRC32表 printf("CRC32 TABLE:\n"); for (int i = 0; i&lt;256; i++) &#123; printf("0x%08x ", CRC32_table[i]); if ((i + 1) % 8 == 0) printf("\n"); &#125; // 两种方式计算CRC32 printf("BUFFER i's CRC32: 0x%x\n", GetCRC32(i, 8)); printf("BUFFER i's CRC32: 0x%x\n", crc32(i, 8)); return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MFC程序使用 printf 输出调试信息]]></title>
    <url>%2F2018%2F04%2F28%2FMFC%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-printf-%E8%BE%93%E5%87%BA%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[VS2013及之前版本 包含头文件 12#include &lt;io.h&gt;#include &lt;fcntl.h&gt; 添加函数 12345678void InitConsoleWindow()&#123; AllocConsole(); HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); int hCrt = _open_osfhandle((long)handle,_O_TEXT); FILE * hf = _fdopen( hCrt, "w" ); *stdout = *hf; &#125; 在窗口初始化函数中添加调用 1234567BOOL CHelloMFCDlg::OnInitDialog() &#123; CDialog::OnInitDialog(); InitConsoleWindow(); // add printf("str = %s\n ", "Debug output goes to terminal\n"); ...... &#125; 调用此函数后会弹出一个Console，printf的信息就会出现在这上面，我们就可以查看log信息了。 VS2015及之后版本 包含头文件 123#include &lt;io.h&gt;#include &lt;fcntl.h&gt;#include &lt;conio.h &gt; 添加函数 12345678910void InitConsoleWindow()&#123; AllocConsole(); HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); int hCrt = _open_osfhandle((long)handle, _O_TEXT); FILE * hf = _fdopen(hCrt, "w"); *stdout = *hf; setvbuf(stdout, NULL, _IONBF, 0);&#125; 在窗口初始化函数中添加调用 1234567891011BOOL CCAN_DemoDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); InitConsoleWindow(); // add // 需要调用 _cprintf 进行打印 //printf("str = %s\n ", "Debug output goes to terminal\n"); _cprintf("str = %s\n ", "Debug output goes to terminal\n"); ........&#125; 疑问：VS2015后，printf()被映射到什么地方了]]></content>
      <categories>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZYNQ Vivado环境实现Helloworld]]></title>
    <url>%2F2018%2F04%2F27%2FZYNQ-Vivado%E7%8E%AF%E5%A2%83%E5%AE%9E%E7%8E%B0Helloworld%2F</url>
    <content type="text"><![CDATA[Vivado1. Vivado工程创建 1.1 在Vivado开发环境里双击Create New Project图标 1.2 弹出一个Vivado工程向导，点击Next按钮。 1.3 在弹出的对话框中输入工程名和工程存放目录，我们这里取一个ZYNQ7030_h3lloworld的工程名。点击Next按钮。 1.4 在下面的对话框中默认选择RTL Project, 勾上下面的 Do not specify source at this time 。如果不勾上，下一步会进入添加source file界面。 1.5 在接下来的对话框选择所用的FPGA器件，以及进行一些配置。FPGA芯片型号一定要跟开发板上的型号一致。 1.6 再次确认一下板子型号有没有选对,没有问题再点击“Finish”完成工程创建。 工程创建后如下图所示： 2. 原理图设计2.1 ZYNQ的嵌入式系统开发一般有原理框图的形式来设计，这样硬件的连接看起来会更加直观。点击Create Block Design按钮来添加原理图设计文件。 2.2 在弹出的对话框里输入原理图设计文件的名字，这里我们取名为”system”。 2.3 出现Diagram的空白对话框，点击图标来添加ARM处理器内核到这个空白的原理图里。 2.4 这里有很多Xilinx提供的IP，我们找到ZYNQ7 Processing System 并双击 添加。 ZYNQ的处理器系统已经添加到Block Diagram窗口上了。 3. ZYNQ系统的配置3.1 双击Diagram界面里的ZYNQ Processing System,打开ZYNQ系统的配置界面 其中Page Navigator界面下有8个子项，分别为Zynq Block Design, PS-PL Configuration,Peripheral I/O Pins, MIO Configration, Clock Configuration, DDR Configuration, SMCTiming Calculation, Interrupts。这些页面选项是针对ZYNQ的不同硬件模块的配置，其中PS_PL页面提供了PS到PL的相关接口配置信息以及PS部分一些配置信息；Peripheral I/O Pins页面主要是对一些通用外设接口的配置；MIO Configruation页面主要是对MIO已经EMIO的分配控制；Clock Configruation页面主要是对PS端时钟资源的配置和管理；DDR Configration页面主要是对DDR控制器一些参数的配置；Interrupts页面主要是对中断进行配置管理。具体页面里的每项内容这里我们不一一讲解了，很多配置我们都会在后面的应用中用到。 具体配置操作如下：（1）PS-PL Configuration-&gt;General-&gt;Enable Clock Resets-&gt;去掉FCLK_RESET0_N的使能。（2）PS-PL Configuration-&gt;GP Master AXI Interface-&gt;去掉M AXI GPO interface的使能。（3）Clock Configuration-&gt;PL Fabric Clocks-&gt;去掉FCLK_CLK0的使能。（4）DDR Congiguration-&gt;去掉Enable DDR的使能。（5）MIO Configuration-&gt;I/O Peripherals-&gt;选上UART1，UART1引脚具体配置如图所示。 3.2 配置完成点击OK，退回到Vivado的开发环境。 4. 生成外部链接IO管脚在Diagram界面里点击”Run Block Automation”完成对ZYNQ7 Processing System IP核的配置，并生成外部ZYNQ系统的外部链接IO管脚。 5. 生成 HDL 文件5.1 按Ctrl+S键保存一下Diagram，然后点击Sources选顷卡。5.2 右键选择sysetm,在弹出的菜单中选择Generate Output Products… 点击Generate按钮，这一操作将会生成Diagram Block Design的HDL源文件以及相应端口的约束文件。 5.3 创建一个顶层的HDL文件,右键选择sysetm,在弹出的框框中选择Create HDL Wrapper..。 这样一个system_wrapper.v的顶层文件就生成了，这样我们就可以对该系统进行综合、布线并生成比特流了。5.4 因为这个嵌入式系统只有PS部分的管脚，没有PL部分的管脚，而且PS部分的管脚都是固定的，所以我们不需要添加管脚约束文件。另外因为没有使用PL部分的资源，我们也不需要在Vivado下编译和生成bit文件了。 6. 硬件导入SDK6.1 选择菜单File-&gt;Export-&gt;Export Hardware…。 因为没有生成bit文件，所以不要选Include bitstream，点击OK。 6.2 硬件导出完成后，选择菜单File-&gt;Launch SDK，启动SDK开发环境 点击OK，软件会自动启动SDK开发环境 SDK编程1.选择菜单File-&gt;New-&gt;Application Project,新建一个SDK的软件工程 2.输入工程名字为ZYNQ7030_helloworld,并生成一个新的bsp文件 3.选择工程模版Hello World。 4.生成后的helloworld项目和bsp支持包如下，在helloworld.c文件里就是添加循环打印一个hello World的字符。 5.右键选择helloworld工程，选择Build Project，编译一下。 下载和调试]]></content>
      <categories>
        <category>Xilinx</category>
      </categories>
      <tags>
        <tag>Xilinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们在一起两年了]]></title>
    <url>%2F2018%2F04%2F23%2F%E6%88%91%E4%BB%AC%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%B8%A4%E5%B9%B4%E4%BA%86%2F</url>
    <content type="text"><![CDATA[不知不觉跟媳妇走过两年的时光了。 从学校走向社会，环境发生了变化，但我跟媳妇会一直走下去。前天。。。。。。前段时间把房子买了，坐标济南。之前在学校的时候就答应媳妇说18年把房子买下，虽然买的过程中有些仓促及坎坷，但最终还是定了下来，算是有了自己的小窝了（虽然20年才交房）。计划交房后结婚，但在这之前还有很多事情需要准备，要给媳妇一个温暖的家。结婚后的工作地点待定，可能在转回济南，也可能再在北京待几年。到时在跟媳妇商量。 我们会越来越幸福的。 居庸关]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux字符设备驱动_third_drv]]></title>
    <url>%2F2018%2F04%2F19%2FLinux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-third-drv%2F</url>
    <content type="text"><![CDATA[解决上一篇遗留问题第一个问题的解决方案很简单，注册驱动程序的时候，如果传入的major为0，那么系统将会自动为这个驱动程序分配主设备号，同时这个程序也会返回所分配的主设备号。第二个问题，解决起来也不是很困难，在Linux中提供了一种机制是udev，可以用于自动的创建设备，在嵌入式Linux的文件系统，比如busybox，也有一套简化版的机制，是mdev，在配置文件系统的时候会进行相应的配置，写完了关于文件系统的文章，我会将链接贴上来。我们如果在调用驱动程序的入口函数的时候，就使用mdev来创建这个设备文件其实就行了。使用mdev的时候，需要用到两个结构体，一个是class和class_device。这两个结构体，都定义在%kernel%/include/linux/device.h的头文件中 third_drv.c1`#include ``#include ``#include ``#include //class、class_device结构体的定义位置` `static` `const` `char` `*third_dev_name = ``"third_driver"``;``static` `struct` `class` `*third_class; ``//定义class结构体``//static struct class_device *third_class_dev; //定义class_device结构体``static` `struct` `device *third_device; ``//定义class_device结构体` `static` `struct` `file_operations third_fos=``&#123;`` ``.owner = THIS_MODULE, ``//file_operations结构题中只指定owner``&#125;;` `static` `int` `dev_id = 0; ``//初始化的设备号0``static` `int` `__init third_init(``void``)``&#123;`` ``dev_id = register_chrdev(dev_id, third_dev_name, &amp;third_fos); ``//指定的主设备号为0，同时把用设备号来接收函数的返回值，实际该函数会返回自动创建的主设备号`` ``third_class = class_create(THIS_MODULE, ``"third_drv"``); ``//初始化class结构体，指定设备文件名`` ``third_device = device_create(third_class, NULL, MKDEV(dev_id, 0), NULL, ``"third_drv"``);``// 根据class来初始化class_device，会创建出对应的设备文件`` ``printk(``"third_driver_init\n"``);` ` ``return` `0;``&#125;` `static` `void` `__exit third_exit(``void``)``&#123;`` ``unregister_chrdev(dev_id, third_dev_name);`` ``device_unregister(third_device); ``// 后创建的先卸载`` ``class_destroy(third_class);` ` ``printk(``"third_driver_exit\n"``);``&#125;` `module_init(third_init);``module_exit(third_exit);` `MODULE_LICENSE(``"GPL"``);``MODULE_AUTHOR(``"zhou"``);` Makefile1`ifneq ($(KERNELRELEASE),)``obj-m :=third_drv.o` `else``KDIR:= ``/lib/modules/``$(shell ``uname` `-r)``/build``all:`` ``make` `-C $(KDIR) M=$(PWD) modules``clean: `` ``rm` `-f *.ko *.o *.mod.o *.mod.c *.order *.symvers``endif` “make”编译后使用”insmod third_drv.ko”加载驱动程序，会自动创建设备文件使用”rmmod third_drv”卸载驱动程序，会自动卸载设备文件]]></content>
      <categories>
        <category>Linux驱动程序</category>
      </categories>
      <tags>
        <tag>Linux驱动程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux字符设备驱动_first_drv]]></title>
    <url>%2F2018%2F04%2F19%2FLinux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-first-drv%2F</url>
    <content type="text"><![CDATA[1. first_drv.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;linux/init.h&gt; //定义了module_init#include &lt;linux/module.h&gt; //最基本的头文件，其中定义了MODULE_LICENSE这一类宏#include &lt;linux/fs.h&gt; // file_operations结构体定义在该头文件中 static const char* dev_name = "first_drv"; // 定义设备名static unsigned int major = 55; //定义设备号static int dev_id; //定义了open函数static int first_drv_open (struct inode *inode, struct file *file)&#123; printk("first_drv_open\n"); return 0;&#125; //定义了write函数static ssize_t first_drv_write (struct file *file, const char __user *buf, size_t size, loff_t * ppos)&#123; printk("first_drv_write\n"); return 0;&#125; //在file_operations中注册open和write函数static struct file_operations first_drv_fo =&#123; .owner = THIS_MODULE, //将对应的函数关联在file_operations的结构体中 .open = first_drv_open, .write = first_drv_write,&#125;; //init驱动的入口函数static int first_drv_init(void)&#123; //注册设备，实际是将file_operations结构体放到内核的制定数组中，以便管理 //在register_chrdev中制定major作为主设备号 dev_id = register_chrdev(major, dev_name , &amp;first_drv_fo); printk("first_drv_init\n"); if(dev_id &lt; 0) printk("init_error\n"); return 0;&#125; //驱动的出口函数static void first_drv_exit(void)&#123; printk("first_drv_exit\n"); unregister_chrdev(major, dev_name); //卸载设备，实际是将file_operations结构体从内核维护的相关数组中以主设备号作为索引删除&#125; //内核将通过这个宏，来直到这个驱动的入口和出口函数module_init(first_drv_init);module_exit(first_drv_exit); MODULE_AUTHOR("zhou");MODULE_LICENSE("GPL"); //指定协议 2. Makefile12345678910ifneq ($(KERNELRELEASE),)obj-m :=first_drv.o elseKDIR:= /lib/modules/$(shell uname -r)/buildall: make -C $(KDIR) M=$(PWD) modulesclean: rm -f *.ko *.o *.mod.o *.mod.c *.order *.symversendif 3. 使用”make”编译,并加载驱动程序123456789101112root@ubuntu:~/first_drv# makemake -C /lib/modules/4.13.0-38-generic/build M=/root/first_drv modulesmake[1]: Entering directory '/usr/src/linux-headers-4.13.0-38-generic' CC [M] /root/first_drv/first_drv.o Building modules, stage 2. MODPOST 1 modules CC /root/first_drv/first_drv.mod.o LD [M] /root/first_drv/first_drv.komake[1]: Leaving directory '/usr/src/linux-headers-4.13.0-38-generic'root@ubuntu:~/first_drv# lsfirst_drv.c first_drv.ko first_drv.mod.c first_drv.mod.o first_drv.o Makefile modules.order Module.symversroot@ubuntu:~/first_drv# 12root@ubuntu:~/first_drv# insmod first_drv.koroot@ubuntu:~/first_drv# 1234root@ubuntu:/# dmesg | tail[ ........] ......[ 224.294291] first_drv_initroot@ubuntu:/# 4. test_drv.c123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; int main(int argc, char **argv)&#123; int fd; //声明设备描述符 int val = 1; //随便定义变量传入到 fd = open("/dev/first_drv", O_RDWR); //根据设备描述符打开设备 if(fd &lt; 0) //打开失败 &#123; printf("can't open\n"); return 1; &#125; write(fd, &amp;val, 4); //根据文件描述符调用write return 0;&#125; 12root@ubuntu:~/first_drv# gcc test_drv.c -o test_drvroot@ubuntu:~/first_drv# 5. 运行 ./test_drv，会打开失败123root@ubuntu:~/first_drv# ./test_drv can't openroot@ubuntu:~/first_drv# `root@ubuntu:~``/first_drv``# ./test_drv ``can't ``open``root@ubuntu:~``/first_drv``# ` 查看/proc/devices文件，有主设备号为55的字符设备 1234haracter devices:...... 55 first_drv...... 查看/dev/目录,”first_drv”设备并没有添加在其中。需要收到添加 12345678910root@ubuntu:~/first_drv# mknod /dev/first_drv c 55 0root@ubuntu:~/first_drv# ll /dev/first_drvcrw-r--r-- 1 root root 55, 0 Apr 18 22:49 /dev/first_drvroot@ubuntu:~/first_drv# mknod命令 第1个参数：设备文件的名字，这个名字要和测试程序中的打开的相一致 第2个参数：c代表的是字符设备 第3个参数：55代表的是主设备号 第4个参数：0代表的是次设备号 再次运行./test_drv测试 12345678root@ubuntu:~/first_drv# ./test_drv root@ubuntu:~/first_drv# root@ubuntu:/# dmesg | tail[ ........] ........[ 176.907024] first_drv_init[ 847.858500] first_drv_open[ 847.858504] first_drv_write 6. 卸载123456789root@ubuntu:~/first_drv# rmmod first_drvroot@ubuntu:~/first_drv# root@ubuntu:/# dmesg | tail[ ........] ........[ 176.907024] first_drv_init[ 847.858500] first_drv_open[ 847.858504] first_drv_write[ 962.499566] first_drv_exit 卸载驱动程序的时候，可以看到调用了驱动程序的出口函数，打印出来了first_drv_exit。此时在查看/proc/devices没有设备了。而在/dev/目录下的设备节点则需要手动来删除。 以上就是一个简单的字符设备驱动程序的框架，驱动程序的在insmod的时候调用了入口函数，在rmmod的时候调用了出口函数，而当我们调用write或者open的时候，会调用到驱动程序中在file_operatios结构体中注册的对应的write和open函数。如果观察刚才的执行过程，会发现几个问题问题装载了驱动程序以后，在/proc/devices中设备，分配设备号，但设备号是在驱动程序中写死的，那么如果设备号被占用，肯定会装载失败；装载完成了驱动程序以后，实际上还不能直接用测试程序打开对应的设备文件，因为设备文件并没有自动创建，需要我们手动创建设备节点，这时候才能使用测试程序来通过打开文件的方式操作驱动程序所对应的硬件。以上的问题，肯定是有办法解决的，不然我们每次设备都需要这样操作实在也不方便。那么我们就来改进一下我们的代码来实现自动分配设备号以及创建设备文件吧。Linux字符设备驱动_third_drv]]></content>
      <categories>
        <category>Linux驱动程序</category>
      </categories>
      <tags>
        <tag>Linux驱动程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux驱动_HelloWorld的解析]]></title>
    <url>%2F2018%2F04%2F18%2FLinux%E9%A9%B1%E5%8A%A8-HelloWorld%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. hello.c文件包含的头文件#include &lt;linux/module.h&gt; //这个头文件包含了许多符号与函数的定义，这些符号与函数多与加载模块有关#include &lt;linux/init.h&gt; //这个头文件包含了你的模块初始化与清除的函数//#include &lt;linux/moduleparam.h&gt; //如果你的模块需要用到参数传递，那么你可能就要声明moduleparam.h这个头文件 描述性声明MODULE_LICENSE(“GPL”); // “GPL” 是指明了 这是GNU General Public License的任意版本// “GPL v2” 是指明 这仅声明为GPL的第二版本// “GPL and addtional”// “Dual BSD/GPL”// “Dual MPL/GPL”// “Proprietary” 私有的// 除非你的模块显式地声明一个开源版本，否则内核会默认你这是一个私有的模块(Proprietary)。MODULE_AUTHOR(); // 声明作者MODULE_DESCRIPTION(); // 对这个模块作一个简单的描述，这个描述是”human-readable”的MODULE_VERSION(); // 这个模块的版本MODULE_ALIAS(); // 这个模块的别名MODULE_DEVICE_TABLE(); // 告诉用户空间这个模块支持什么样的设备 __init __exit1234567891011121314151617181920212223242526272829303132333435363738394041/* These macros are used to mark some functions or * initialized data (doesn't apply to uninitialized data) * as `initialization' functions. The kernel can take this * as hint that the function is used only during the initialization * phase and free up used memory resources after * * Usage: * For functions: * * You should add __init immediately before the function name, like: * * static void __init initme(int x, int y) * &#123; * extern int z; z = x * y; * &#125; * * If the function has a prototype somewhere, you can also add * __init between closing brace of the prototype and semicolon: * * extern int initialize_foobar_device(int, int, int) __init; * * For initialized data: * You should insert __initdata between the variable name and equal * sign followed by value, e.g.: * * static int init_variable __initdata = 0; * static const char linux_logo[] __initconst = &#123; 0x32, 0x36, ... &#125;; * * Don't forget to initialize data not at file scope, i.e. within a function, * as gcc otherwise puts the data into the bss section and not into the init * section. * * Also note, that this data cannot be "const". */ /* These are for everybody (although not all archs will actually discard it in modules) */ #define __init __section(.init.text) __cold notrace #define __initdata __section(.init.data) #define __initconst __section(.init.rodata) #define __exitdata __section(.exit.data) #define __exit_call __used __section(.exitcall.exit) 这些宏被用来标记一些函数或者初始化数据（不适用于未初始化数据）作为初始化函数。此功能仅仅被用在初始化阶段，内核以此作为线索在使用后释放内存资源用法： 1234static void __initinitme(int x, int y)&#123; extern int z; z = x * y;&#125; 宏init 的使用会在初始化完成后丢弃该函数并收回所占内存，如果该模块被编译进内核，而不是动态加载。宏initdata 同init 类似，只不过对变量有效。宏exit 将忽略“清理收尾”的函数如果该模块被编译进内核。同宏 __init一样，对动态加载模块是无效的。这很容易理解。编译进内核的模块是没有清理收尾工作的,而动态加载的却需要自己完成这些工作。这些宏在头文件linux/init.h定义，用来释放内核占用的内存。 当你在启动时看到这样的Freeingunused kernel memory: 236k freed内核输出，上面的 那些正是内核所释放的。 module_init()与module_exit()123456789101112131415161718192021/** * module_init() - driver initialization entry point * @x: function to be run at kernel boot time or module insertion * * module_init() will either be called during do_initcalls() (if * builtin) or at module insertion time (if a module). There can only * be one per module. */ #define module_init(x) __initcall(x); /** * module_exit() - driver exit entry point * @x: function to be run when driver is removed * * module_exit() will wrap the driver clean-up code * with cleanup_module() when used with rmmod when * the driver is a module. If the driver is statically * compiled into the kernel, module_exit() has no effect. * There can only be one per module. */ #define module_exit(x) __exitcall(x); module_init():驱动的入口点，在内核启动或动态加载模块时被调用module_exit():驱动的结束点，动态卸载模块时被调用，如果被静态链接在内核，则module_exit()没有效果 printk()内核通过printk() 输出的信息具有日志级别，日志级别是通过在 printk() 输出的字符串前加一个带尖括号的整数来控制的，如printk(“&lt;6&gt;Hello, world!/n”);。内核中共提供了八种不同的日志级别，在 linux/kernel.h中有相应的宏对应。 12345678#defineKERN_EMERG "&lt;0&gt;" /* systemis unusable */#defineKERN_ALERT "&lt;1&gt;" /* actionmust be taken immediately */#defineKERN_CRIT "&lt;2&gt;" /*critical conditions */#defineKERN_ERR "&lt;3&gt;" /* error conditions */#defineKERN_WARNING "&lt;4&gt;" /* warningconditions */#defineKERN_NOTICE "&lt;5&gt;" /* normal butsignificant */#defineKERN_INFO "&lt;6&gt;" /*informational */#defineKERN_DEBUG "&lt;7&gt;" /*debug-level messages */ 所以 printk()可以这样用：printk(KERN_INFO “Hello, world!/n”);。未指定日志级别的 printk()采用的默认级别是 DEFAULT_MESSAGE_LOGLEVEL，这个宏在 kernel/printk.c 中被定义为整数4，即对应KERN_WARNING。在/proc/sys/kernel/printk 会显示4个数值（可由 echo修改），分别表示当前控制台日志级别、未明确指定日志级别的默认消息日志级别、最小（最高）允许设置的控制台日志级别、引导时默认的日志级别。当 printk()中的消息日志级别小于当前控制台日志级别时，printk 的信息（要有/n符）就会在控制台上显示。但无论当前控制台日志级别是何值，通过 /proc/kmsg（或使用dmesg）总能查看。另外如果配置好并运行了 syslogd 或 klogd，没有在控制台上显示的 printk 的信息也会追加到 /var/log/syslog 中。 Makefile文件KERNELRELEASE是在内核源码的顶层Makefile中定义的一个变量，在第一次读取执行此Makefile时，KERNELRELEASE没有被定义，所以make将读取执行else之后的内容如果make的目标是clean，直接执行clean操作，然后结束。如果make的目标为all时 1-C $(KDIR)指明跳转到内核源码目录下读取那里的Makefile；M=$(PWD)表明然后返回到当前目录继续读入、执行当前的Makefile。 当从内核源码目录返回时，KERNELRELEASE已被定义，kbuild也被启动去解析kbuild语法的语句，make将继续读取else之前的内容。else之前的内容为kbuild语法的语句，指明模块源码中各文件的依赖关系，以及要生成的目标模块名。obj-m后面跟的就是最终的模块名，hello.o,make 会在该目录下自动找到hello.c文件进行编译hello.o可能依赖多个文件或者模块，那么在obj-m后面就可以添加下面语句hello-objs:=file.o file1.o]]></content>
      <categories>
        <category>Linux驱动程序</category>
      </categories>
      <tags>
        <tag>Linux驱动程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux设备驱动_HelloWorld]]></title>
    <url>%2F2018%2F04%2F18%2Flinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-HelloWorld%2F</url>
    <content type="text"><![CDATA[环境介绍 宿主机：Win10家庭版 Vmware14.0安装Ubuntu16.04.4系统 开始 虚拟机系统安装完毕后，进入系统，运行命令窗口，切换至root账户 新建hello.c文件hello.c 12345678910111213141516171819#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt; static int __init hello_init(void)&#123; printk(KERN_NOTICE "hello world!\n"); return 0;&#125;static void __exit hello_exit(void)&#123; printk(KERN_NOTICE "hello exit!\n");&#125; module_init(hello_init);module_exit(hello_exit); MODULE_LICENSE("GPL");MODULE_AUTHOR("zhou");MODULE_DESCRIPTION("Hello world module"); 新建Makefile文件（M大写）Makeflie 12345678910ifneq ($(KERNELRELEASE),)obj-m :=hello.o elseKDIR:= /lib/modules/$(shell uname -r)/buildall: make -C $(KDIR) M=$(PWD) modulesclean: rm -f *.ko *.o *.mod.o *.mod.c *.order *.symversendif 输入“make”进行编译 1234567891011root@ubuntu:~/driver_hello# lshello.c Makefileroot@ubuntu:~/driver_hello# makemake -C /lib/modules/4.13.0-36-generic/build M=/root/driver_hello modulesmake[1]: Entering directory '/usr/src/linux-headers-4.13.0-36-generic' CC [M] /root/driver_hello/hello.o Building modules, stage 2. MODPOST 1 modules CC /root/driver_hello/hello.mod.o LD [M] /root/driver_hello/hello.komake[1]: Leaving directory '/usr/src/linux-headers-4.13.0-36-generic' 加载模块 1root@ubuntu:~/driver_hello# insmod hello.ko 查看以安装模块 123456root@ubuntu:~/driver_hello# lsmodModule Size Used byhello 16384 0vmw_vsock_vmci_transport 28672 2vsock 36864 3 vmw_vsock_vmci_transport...... 卸载模块 1root@ubuntu:~/driver_hello# rmmod hello.ko 此时你会发现，驱动加载后终端里什么输出也没有，不用急，因为printk是内核输出函数，要查看的话，还要执行下列指令。 1root@ubuntu:~/driver_hello# dmesg | tail]]></content>
      <categories>
        <category>Linux驱动程序</category>
      </categories>
      <tags>
        <tag>Linux驱动程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记帐单]]></title>
    <url>%2F2018%2F04%2F17%2F%E8%AE%B0%E5%B8%90%E5%8D%95%2F</url>
    <content type="text"><![CDATA[花了好多钱 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[华为RH2288H V3 安装操作系统]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%8D%8E%E4%B8%BARH2288H-V3-%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[华为RH2288H V3服务器重新安装Windows Server 2008 R2操作系统，系统安装在一块独立的硬盘上，此方法不适合将系统安装在Raid阵列上。 安装系统前不要插任何第三方的卡！！！ 安装系统驱动前不要插任何第三方卡！！！ 安装操作系统 首先制作启动盘，本次使用工具为WinSetupFromUSB-1-8。 制作完启动盘后将U盘插入服务器USB口（网上言论说多数U盘会不识别，但我的正常识别：闪迪32GB USB3.0）。 开机，等待到达BIOS启动项界面 说明： ​ 界面参数说明如下： 按“F5”选择键盘类型，可选择键盘类型包括美式键盘和法式键盘。按“Delete”/“F4”进入BIOS Setup Utility界面。按“F11”/“F3”进入启动管理界面，在此界面可以选择启动设备进行启动。按“F12”，从网络启动快捷方式。 进入启动管理界面后，找到U盘设备启动。 接下来就跟普通装系统一样了。 安装驱动 到华为网站下载“FusionServer_iDriver-Windows-Driver-V329.zip”（版本会有变化） 解压进入路径“FusionServer_iDriver-Windows-Driver-V329.zip\Windows-Driver-V329\win2k8r2sp1” 解压“onboard_driver_win2k8r2sp1.iso”，进入文件夹“onboard_driver_win2k8r2sp1” 打开cmd，切换到驱动程序文件的路径 输入以下命令安装所有驱动程序：install.bat install “all” 安装完成后，您可以在工作路径下找到result.txt。在该文件中，您可以找到该操作的结果和信息。 安装后，网卡、USB3.0、Raid卡被识别（应该还有其他被识别的驱动）。在设备管理器中还有许多未被识别的设备。 到华为网站下载“FusionServer_Tools-ServiceCD2.0-V132.zip”（版本会有变化） 解压后进入文件夹，使用虚拟光驱工具加载“FusionServer Tools-ServiceCD2.0-V132.iso”。切记不可直接解压运行，直接解压运行会报错。 加载虚拟光驱后运行“InstallWinDriver.exe”，安装驱动，重启。 重启过后所有系统驱动即可安装完毕。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello_world!]]></title>
    <url>%2F2018%2F04%2F10%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[关于建站这个坑已经挖了很久了，之前由于种种一拖再拖，最近终于把这个坑给填上。 域名：zhoushanbao.top(zhoushanbao.com被别人注册了，联系持有者未得到回应，.top也挺好的，要啥自行车啊) 服务器：搬瓦工的设备，国内服务器建站还需要备案，暂时用着 使用WordPress开源博客软件，功能强大 知识积累，生活记录 2018年04月10日 站点成立，希望可以长久运行下去。 更新：域名变更xbao.org 更新：域名变更xbao.me 更新：环境变更至Hexo]]></content>
  </entry>
</search>
